MLton ge2a8395 (built Wed Jul 17 18:58:06 EDT 2013 on csdhcp-120-227.cs.purdue.edu)
  created this file on Thu Aug 08 17:40:55 2013.
Do not edit this file.
Flag settings: 
   align: 4
   atMLtons: ()
   chunk: coalesce 4096
   closureConvertGlobalize: true
   closureConvertShrink: true
   codegen: x86
   contifyIntoMain: false
   debug: false
   defaultChar: char8
   defaultWideChar: widechar32
   defaultInt: int32
   defaultReal: real64
   defaultWord: word32
   diag passes: []
   drop passes: []
   elaborate allowConstant (default): false
   elaborate allowConstant (enabled): true
   elaborate allowFFI (default): false
   elaborate allowFFI (enabled): true
   elaborate allowPrim (default): false
   elaborate allowPrim (enabled): true
   elaborate allowOverload (default): false
   elaborate allowOverload (enabled): true
   elaborate allowRebindEquals (default): false
   elaborate allowRebindEquals (enabled): true
   elaborate deadCode (default): false
   elaborate deadCode (enabled): true
   elaborate forceUsed (default): false
   elaborate forceUsed (enabled): true
   elaborate ffiStr (default): 
   elaborate ffiStr (enabled): true
   elaborate nonexhaustiveExnMatch (default): default
   elaborate nonexhaustiveExnMatch (enabled): true
   elaborate nonexhaustiveMatch (default): warn
   elaborate nonexhaustiveMatch (enabled): true
   elaborate redundantMatch (default): warn
   elaborate redundantMatch (enabled): true
   elaborate resolveScope (default): strdec
   elaborate resolveScope (enabled): true
   elaborate sequenceNonUnit (default): ignore
   elaborate sequenceNonUnit (enabled): true
   elaborate warnUnused (default): false
   elaborate warnUnused (enabled): true
   elaborate only: false
   emit main: true
   export header: None
   exn history: false
   generated output format: executable
   gc check: Limit
   indentation: 3
   inlineIntoMain: true
   inlineLeafA: {loops = true, repeat = true, size = Some 20}
   inlineLeafB: {loops = true, repeat = true, size = Some 40}
   inlineNonRec: {small = 60, product = 320}
   input file: hello.core-ml
   keep CoreML: true
   keep def use: true
   keep dot: false
   keep Machine: false
   keep passes: []
   keep RSSA: false
   keep SSA: false
   keep SSA2: false
   keep SXML: false
   keep XML: false
   extra_: false
   lib dir: /Users/gowtham/git/mlton/newexecs/usr/local/lib/mlton
   lib target dir: /Users/gowtham/git/mlton/newexecs/usr/local/lib/mlton/targets/self
   loop passes: 1
   mark cards: true
   max function size: 10000
   mlb path vars: [{var = MLTON_ROOT, path = $(LIB_MLTON_DIR)/sml}, {var = SML_LIB, path = $(LIB_MLTON_DIR)/sml}]
   native commented: 0
   native live stack: false
   native optimize: 1
   native move hoist: true
   native copy prop: true
   native copy prop cutoff: 1000
   native cutoff: 100
   native live transfer: 8
   native shuffle: true
   native ieee fp: false
   native split: Some 20000
   optimizationPasses: []
   polyvariance: Some {hofo = true, rounds = 2, small = 30, product = 300}
   prefer abs paths: false
   prof passes: []
   profile: None
   profile branch: false
   profile C: []
   profile IL: ProfileSource
   profile include/exclude: []
   profile raise: false
   profile stack: false
   profile val: false
   show basis: None
   show def-use: None
   show types: true
   target: self
   target arch: X86
   target OS: Linux
   type check: false
   verbosity: Top
   warn unrecognized annotation: true
   warn deprecated features: true
   zone cut depth: 100


Decs:
datatype bool = false
		| true
	 'a_0 list = nil
		     | :: of 'a_0 * 'a_0 list
	 'a_1 ref = ref of 'a_1
exception Bind
exception Match
exception Overflow
val rec
   not: bool -> bool = 
      (fn x_0: bool =>
       case x_0 of
	 (b: bool) => case b of true => false | false => true)
val detectOverflow: bool = 0x1
val safe: bool = 0x1
val bufSize: int32 = 0x1000
val name: exn -> string = (fn x_1: exn => Exn_name (x_1))
exception Div
exception Domain
exception Fail8 of string
exception Fail16 of char16 vector
exception Fail32 of char32 vector
exception Overflow
exception Size
exception Subscript
val ('b, 'a) wrapOverflow: ('a -> 'b) -> 'a -> 'b =
   (fn x_2: 'a -> 'b =>
    case x_2 of
      f: 'a -> 'b =>
      (fn x_3: 'a =>
       case x_3 of
	 a: 'a => (f a) handle x_4 => case x_4 of Overflow => raise Overflow))
datatype Primitive.Order.t = LESS
			     | EQUAL
			     | GREATER
datatype 'a Primitive.Option.t = NONE
				 | SOME of 'a
val 'a deref: 'a ref -> 'a = (fn x_5: 'a ref => Ref_deref['a] (x_5))
val 'a assign: 'a ref * 'a -> unit =
   (fn x_6: 'a ref * 'a =>
    case x_6 of
      (x_8: 'a ref, x_7: 'a) => Ref_assign['a] (x_8, x_7))
val setHandler: (exn -> unit) -> unit =
   (fn x_9: exn -> unit =>
    TopLevel_setHandler (x_9))
val setSuffix: (unit -> unit) -> unit =
   (fn x_10: unit -> unit =>
    TopLevel_setSuffix (x_10))
val not: bool -> bool = not
val ''a =: ''a * ''a -> bool =
   (fn x_11: ''a * ''a =>
    case x_11 of
      (x_13: ''a, x_12: ''a) => MLton_equal[''a] (x_13, x_12))
val ''a_2 <>: ''a_2 * ''a_2 -> bool =
   (fn x_14: ''a_2 * ''a_2 =>
    case x_14 of
      (x: ''a_2, y: ''a_2) => (not (= (''a_2) (x, y))))
val idFromInt8ToWord8: int8 -> word8 =
   (fn x_15: int8 =>
    WordU8_extdToWord8 (x_15))
val idFromInt16ToWord16: int16 -> word16 =
   (fn x_16: int16 =>
    WordU16_extdToWord16 (x_16))
val idFromInt32ToWord32: int32 -> word32 =
   (fn x_17: int32 =>
    WordU32_extdToWord32 (x_17))
val idFromInt64ToWord64: int64 -> word64 =
   (fn x_18: int64 =>
    WordU64_extdToWord64 (x_18))
val idFromWord8ToInt8: word8 -> int8 =
   (fn x_19: word8 =>
    WordU8_extdToWord8 (x_19))
val idFromWord16ToInt16: word16 -> int16 =
   (fn x_20: word16 =>
    WordU16_extdToWord16 (x_20))
val idFromWord32ToInt32: word32 -> int32 =
   (fn x_21: word32 =>
    WordU32_extdToWord32 (x_21))
val idFromWord64ToInt64: word64 -> int64 =
   (fn x_22: word64 =>
    WordU64_extdToWord64 (x_22))
val zextdFromInt8ToInt8: int8 -> int8 =
   (fn x_23: int8 =>
    WordU8_extdToWord8 (x_23))
val zextdFromInt8ToInt16: int8 -> int16 =
   (fn x_24: int8 =>
    WordU8_extdToWord16 (x_24))
val zextdFromInt8ToInt32: int8 -> int32 =
   (fn x_25: int8 =>
    WordU8_extdToWord32 (x_25))
val zextdFromInt8ToInt64: int8 -> int64 =
   (fn x_26: int8 =>
    WordU8_extdToWord64 (x_26))
val zextdFromInt8ToWord8: int8 -> word8 =
   (fn x_27: int8 =>
    WordU8_extdToWord8 (x_27))
val zextdFromInt8ToWord16: int8 -> word16 =
   (fn x_28: int8 =>
    WordU8_extdToWord16 (x_28))
val zextdFromInt8ToWord32: int8 -> word32 =
   (fn x_29: int8 =>
    WordU8_extdToWord32 (x_29))
val zextdFromInt8ToWord64: int8 -> word64 =
   (fn x_30: int8 =>
    WordU8_extdToWord64 (x_30))
val zextdFromInt16ToInt8: int16 -> int8 =
   (fn x_31: int16 =>
    WordU16_extdToWord8 (x_31))
val zextdFromInt16ToInt16: int16 -> int16 =
   (fn x_32: int16 =>
    WordU16_extdToWord16 (x_32))
val zextdFromInt16ToInt32: int16 -> int32 =
   (fn x_33: int16 =>
    WordU16_extdToWord32 (x_33))
val zextdFromInt16ToInt64: int16 -> int64 =
   (fn x_34: int16 =>
    WordU16_extdToWord64 (x_34))
val zextdFromInt16ToWord8: int16 -> word8 =
   (fn x_35: int16 =>
    WordU16_extdToWord8 (x_35))
val zextdFromInt16ToWord16: int16 -> word16 =
   (fn x_36: int16 =>
    WordU16_extdToWord16 (x_36))
val zextdFromInt16ToWord32: int16 -> word32 =
   (fn x_37: int16 =>
    WordU16_extdToWord32 (x_37))
val zextdFromInt16ToWord64: int16 -> word64 =
   (fn x_38: int16 =>
    WordU16_extdToWord64 (x_38))
val zextdFromInt32ToInt8: int32 -> int8 =
   (fn x_39: int32 =>
    WordU32_extdToWord8 (x_39))
val zextdFromInt32ToInt16: int32 -> int16 =
   (fn x_40: int32 =>
    WordU32_extdToWord16 (x_40))
val zextdFromInt32ToInt32: int32 -> int32 =
   (fn x_41: int32 =>
    WordU32_extdToWord32 (x_41))
val zextdFromInt32ToInt64: int32 -> int64 =
   (fn x_42: int32 =>
    WordU32_extdToWord64 (x_42))
val zextdFromInt32ToWord8: int32 -> word8 =
   (fn x_43: int32 =>
    WordU32_extdToWord8 (x_43))
val zextdFromInt32ToWord16: int32 -> word16 =
   (fn x_44: int32 =>
    WordU32_extdToWord16 (x_44))
val zextdFromInt32ToWord32: int32 -> word32 =
   (fn x_45: int32 =>
    WordU32_extdToWord32 (x_45))
val zextdFromInt32ToWord64: int32 -> word64 =
   (fn x_46: int32 =>
    WordU32_extdToWord64 (x_46))
val zextdFromInt64ToInt8: int64 -> int8 =
   (fn x_47: int64 =>
    WordU64_extdToWord8 (x_47))
val zextdFromInt64ToInt16: int64 -> int16 =
   (fn x_48: int64 =>
    WordU64_extdToWord16 (x_48))
val zextdFromInt64ToInt32: int64 -> int32 =
   (fn x_49: int64 =>
    WordU64_extdToWord32 (x_49))
val zextdFromInt64ToInt64: int64 -> int64 =
   (fn x_50: int64 =>
    WordU64_extdToWord64 (x_50))
val zextdFromInt64ToWord8: int64 -> word8 =
   (fn x_51: int64 =>
    WordU64_extdToWord8 (x_51))
val zextdFromInt64ToWord16: int64 -> word16 =
   (fn x_52: int64 =>
    WordU64_extdToWord16 (x_52))
val zextdFromInt64ToWord32: int64 -> word32 =
   (fn x_53: int64 =>
    WordU64_extdToWord32 (x_53))
val zextdFromInt64ToWord64: int64 -> word64 =
   (fn x_54: int64 =>
    WordU64_extdToWord64 (x_54))
val zextdFromWord8ToInt8: word8 -> int8 =
   (fn x_55: word8 =>
    WordU8_extdToWord8 (x_55))
val zextdFromWord8ToInt16: word8 -> int16 =
   (fn x_56: word8 =>
    WordU8_extdToWord16 (x_56))
val zextdFromWord8ToInt32: word8 -> int32 =
   (fn x_57: word8 =>
    WordU8_extdToWord32 (x_57))
val zextdFromWord8ToInt64: word8 -> int64 =
   (fn x_58: word8 =>
    WordU8_extdToWord64 (x_58))
val zextdFromWord8ToWord8: word8 -> word8 =
   (fn x_59: word8 =>
    WordU8_extdToWord8 (x_59))
val zextdFromWord8ToWord16: word8 -> word16 =
   (fn x_60: word8 =>
    WordU8_extdToWord16 (x_60))
val zextdFromWord8ToWord32: word8 -> word32 =
   (fn x_61: word8 =>
    WordU8_extdToWord32 (x_61))
val zextdFromWord8ToWord64: word8 -> word64 =
   (fn x_62: word8 =>
    WordU8_extdToWord64 (x_62))
val zextdFromWord16ToInt8: word16 -> int8 =
   (fn x_63: word16 =>
    WordU16_extdToWord8 (x_63))
val zextdFromWord16ToInt16: word16 -> int16 =
   (fn x_64: word16 =>
    WordU16_extdToWord16 (x_64))
val zextdFromWord16ToInt32: word16 -> int32 =
   (fn x_65: word16 =>
    WordU16_extdToWord32 (x_65))
val zextdFromWord16ToInt64: word16 -> int64 =
   (fn x_66: word16 =>
    WordU16_extdToWord64 (x_66))
val zextdFromWord16ToWord8: word16 -> word8 =
   (fn x_67: word16 =>
    WordU16_extdToWord8 (x_67))
val zextdFromWord16ToWord16: word16 -> word16 =
   (fn x_68: word16 =>
    WordU16_extdToWord16 (x_68))
val zextdFromWord16ToWord32: word16 -> word32 =
   (fn x_69: word16 =>
    WordU16_extdToWord32 (x_69))
val zextdFromWord16ToWord64: word16 -> word64 =
   (fn x_70: word16 =>
    WordU16_extdToWord64 (x_70))
val zextdFromWord32ToInt8: word32 -> int8 =
   (fn x_71: word32 =>
    WordU32_extdToWord8 (x_71))
val zextdFromWord32ToInt16: word32 -> int16 =
   (fn x_72: word32 =>
    WordU32_extdToWord16 (x_72))
val zextdFromWord32ToInt32: word32 -> int32 =
   (fn x_73: word32 =>
    WordU32_extdToWord32 (x_73))
val zextdFromWord32ToInt64: word32 -> int64 =
   (fn x_74: word32 =>
    WordU32_extdToWord64 (x_74))
val zextdFromWord32ToWord8: word32 -> word8 =
   (fn x_75: word32 =>
    WordU32_extdToWord8 (x_75))
val zextdFromWord32ToWord16: word32 -> word16 =
   (fn x_76: word32 =>
    WordU32_extdToWord16 (x_76))
val zextdFromWord32ToWord32: word32 -> word32 =
   (fn x_77: word32 =>
    WordU32_extdToWord32 (x_77))
val zextdFromWord32ToWord64: word32 -> word64 =
   (fn x_78: word32 =>
    WordU32_extdToWord64 (x_78))
val zextdFromWord64ToInt8: word64 -> int8 =
   (fn x_79: word64 =>
    WordU64_extdToWord8 (x_79))
val zextdFromWord64ToInt16: word64 -> int16 =
   (fn x_80: word64 =>
    WordU64_extdToWord16 (x_80))
val zextdFromWord64ToInt32: word64 -> int32 =
   (fn x_81: word64 =>
    WordU64_extdToWord32 (x_81))
val zextdFromWord64ToInt64: word64 -> int64 =
   (fn x_82: word64 =>
    WordU64_extdToWord64 (x_82))
val zextdFromWord64ToWord8: word64 -> word8 =
   (fn x_83: word64 =>
    WordU64_extdToWord8 (x_83))
val zextdFromWord64ToWord16: word64 -> word16 =
   (fn x_84: word64 =>
    WordU64_extdToWord16 (x_84))
val zextdFromWord64ToWord32: word64 -> word32 =
   (fn x_85: word64 =>
    WordU64_extdToWord32 (x_85))
val zextdFromWord64ToWord64: word64 -> word64 =
   (fn x_86: word64 =>
    WordU64_extdToWord64 (x_86))
val sextdFromInt8ToInt8: int8 -> int8 =
   (fn x_87: int8 =>
    WordS8_extdToWord8 (x_87))
val sextdFromInt8ToInt16: int8 -> int16 =
   (fn x_88: int8 =>
    WordS8_extdToWord16 (x_88))
val sextdFromInt8ToInt32: int8 -> int32 =
   (fn x_89: int8 =>
    WordS8_extdToWord32 (x_89))
val sextdFromInt8ToInt64: int8 -> int64 =
   (fn x_90: int8 =>
    WordS8_extdToWord64 (x_90))
val sextdFromInt8ToWord8: int8 -> word8 =
   (fn x_91: int8 =>
    WordS8_extdToWord8 (x_91))
val sextdFromInt8ToWord16: int8 -> word16 =
   (fn x_92: int8 =>
    WordS8_extdToWord16 (x_92))
val sextdFromInt8ToWord32: int8 -> word32 =
   (fn x_93: int8 =>
    WordS8_extdToWord32 (x_93))
val sextdFromInt8ToWord64: int8 -> word64 =
   (fn x_94: int8 =>
    WordS8_extdToWord64 (x_94))
val sextdFromInt16ToInt8: int16 -> int8 =
   (fn x_95: int16 =>
    WordS16_extdToWord8 (x_95))
val sextdFromInt16ToInt16: int16 -> int16 =
   (fn x_96: int16 =>
    WordS16_extdToWord16 (x_96))
val sextdFromInt16ToInt32: int16 -> int32 =
   (fn x_97: int16 =>
    WordS16_extdToWord32 (x_97))
val sextdFromInt16ToInt64: int16 -> int64 =
   (fn x_98: int16 =>
    WordS16_extdToWord64 (x_98))
val sextdFromInt16ToWord8: int16 -> word8 =
   (fn x_99: int16 =>
    WordS16_extdToWord8 (x_99))
val sextdFromInt16ToWord16: int16 -> word16 =
   (fn x_100: int16 =>
    WordS16_extdToWord16 (x_100))
val sextdFromInt16ToWord32: int16 -> word32 =
   (fn x_101: int16 =>
    WordS16_extdToWord32 (x_101))
val sextdFromInt16ToWord64: int16 -> word64 =
   (fn x_102: int16 =>
    WordS16_extdToWord64 (x_102))
val sextdFromInt32ToInt8: int32 -> int8 =
   (fn x_103: int32 =>
    WordS32_extdToWord8 (x_103))
val sextdFromInt32ToInt16: int32 -> int16 =
   (fn x_104: int32 =>
    WordS32_extdToWord16 (x_104))
val sextdFromInt32ToInt32: int32 -> int32 =
   (fn x_105: int32 =>
    WordS32_extdToWord32 (x_105))
val sextdFromInt32ToInt64: int32 -> int64 =
   (fn x_106: int32 =>
    WordS32_extdToWord64 (x_106))
val sextdFromInt32ToWord8: int32 -> word8 =
   (fn x_107: int32 =>
    WordS32_extdToWord8 (x_107))
val sextdFromInt32ToWord16: int32 -> word16 =
   (fn x_108: int32 =>
    WordS32_extdToWord16 (x_108))
val sextdFromInt32ToWord32: int32 -> word32 =
   (fn x_109: int32 =>
    WordS32_extdToWord32 (x_109))
val sextdFromInt32ToWord64: int32 -> word64 =
   (fn x_110: int32 =>
    WordS32_extdToWord64 (x_110))
val sextdFromInt64ToInt8: int64 -> int8 =
   (fn x_111: int64 =>
    WordS64_extdToWord8 (x_111))
val sextdFromInt64ToInt16: int64 -> int16 =
   (fn x_112: int64 =>
    WordS64_extdToWord16 (x_112))
val sextdFromInt64ToInt32: int64 -> int32 =
   (fn x_113: int64 =>
    WordS64_extdToWord32 (x_113))
val sextdFromInt64ToInt64: int64 -> int64 =
   (fn x_114: int64 =>
    WordS64_extdToWord64 (x_114))
val sextdFromInt64ToWord8: int64 -> word8 =
   (fn x_115: int64 =>
    WordS64_extdToWord8 (x_115))
val sextdFromInt64ToWord16: int64 -> word16 =
   (fn x_116: int64 =>
    WordS64_extdToWord16 (x_116))
val sextdFromInt64ToWord32: int64 -> word32 =
   (fn x_117: int64 =>
    WordS64_extdToWord32 (x_117))
val sextdFromInt64ToWord64: int64 -> word64 =
   (fn x_118: int64 =>
    WordS64_extdToWord64 (x_118))
val sextdFromWord8ToInt8: word8 -> int8 =
   (fn x_119: word8 =>
    WordS8_extdToWord8 (x_119))
val sextdFromWord8ToInt16: word8 -> int16 =
   (fn x_120: word8 =>
    WordS8_extdToWord16 (x_120))
val sextdFromWord8ToInt32: word8 -> int32 =
   (fn x_121: word8 =>
    WordS8_extdToWord32 (x_121))
val sextdFromWord8ToInt64: word8 -> int64 =
   (fn x_122: word8 =>
    WordS8_extdToWord64 (x_122))
val sextdFromWord8ToWord8: word8 -> word8 =
   (fn x_123: word8 =>
    WordS8_extdToWord8 (x_123))
val sextdFromWord8ToWord16: word8 -> word16 =
   (fn x_124: word8 =>
    WordS8_extdToWord16 (x_124))
val sextdFromWord8ToWord32: word8 -> word32 =
   (fn x_125: word8 =>
    WordS8_extdToWord32 (x_125))
val sextdFromWord8ToWord64: word8 -> word64 =
   (fn x_126: word8 =>
    WordS8_extdToWord64 (x_126))
val sextdFromWord16ToInt8: word16 -> int8 =
   (fn x_127: word16 =>
    WordS16_extdToWord8 (x_127))
val sextdFromWord16ToInt16: word16 -> int16 =
   (fn x_128: word16 =>
    WordS16_extdToWord16 (x_128))
val sextdFromWord16ToInt32: word16 -> int32 =
   (fn x_129: word16 =>
    WordS16_extdToWord32 (x_129))
val sextdFromWord16ToInt64: word16 -> int64 =
   (fn x_130: word16 =>
    WordS16_extdToWord64 (x_130))
val sextdFromWord16ToWord8: word16 -> word8 =
   (fn x_131: word16 =>
    WordS16_extdToWord8 (x_131))
val sextdFromWord16ToWord16: word16 -> word16 =
   (fn x_132: word16 =>
    WordS16_extdToWord16 (x_132))
val sextdFromWord16ToWord32: word16 -> word32 =
   (fn x_133: word16 =>
    WordS16_extdToWord32 (x_133))
val sextdFromWord16ToWord64: word16 -> word64 =
   (fn x_134: word16 =>
    WordS16_extdToWord64 (x_134))
val sextdFromWord32ToInt8: word32 -> int8 =
   (fn x_135: word32 =>
    WordS32_extdToWord8 (x_135))
val sextdFromWord32ToInt16: word32 -> int16 =
   (fn x_136: word32 =>
    WordS32_extdToWord16 (x_136))
val sextdFromWord32ToInt32: word32 -> int32 =
   (fn x_137: word32 =>
    WordS32_extdToWord32 (x_137))
val sextdFromWord32ToInt64: word32 -> int64 =
   (fn x_138: word32 =>
    WordS32_extdToWord64 (x_138))
val sextdFromWord32ToWord8: word32 -> word8 =
   (fn x_139: word32 =>
    WordS32_extdToWord8 (x_139))
val sextdFromWord32ToWord16: word32 -> word16 =
   (fn x_140: word32 =>
    WordS32_extdToWord16 (x_140))
val sextdFromWord32ToWord32: word32 -> word32 =
   (fn x_141: word32 =>
    WordS32_extdToWord32 (x_141))
val sextdFromWord32ToWord64: word32 -> word64 =
   (fn x_142: word32 =>
    WordS32_extdToWord64 (x_142))
val sextdFromWord64ToInt8: word64 -> int8 =
   (fn x_143: word64 =>
    WordS64_extdToWord8 (x_143))
val sextdFromWord64ToInt16: word64 -> int16 =
   (fn x_144: word64 =>
    WordS64_extdToWord16 (x_144))
val sextdFromWord64ToInt32: word64 -> int32 =
   (fn x_145: word64 =>
    WordS64_extdToWord32 (x_145))
val sextdFromWord64ToInt64: word64 -> int64 =
   (fn x_146: word64 =>
    WordS64_extdToWord64 (x_146))
val sextdFromWord64ToWord8: word64 -> word8 =
   (fn x_147: word64 =>
    WordS64_extdToWord8 (x_147))
val sextdFromWord64ToWord16: word64 -> word16 =
   (fn x_148: word64 =>
    WordS64_extdToWord16 (x_148))
val sextdFromWord64ToWord32: word64 -> word32 =
   (fn x_149: word64 =>
    WordS64_extdToWord32 (x_149))
val sextdFromWord64ToWord64: word64 -> word64 =
   (fn x_150: word64 =>
    WordS64_extdToWord64 (x_150))
val sizeInBits: int32 = 0x1
val sizeInBits: int32 = 0x2
val sizeInBits: int32 = 0x3
val sizeInBits: int32 = 0x4
val sizeInBits: int32 = 0x5
val sizeInBits: int32 = 0x6
val sizeInBits: int32 = 0x7
val sizeInBits: int32 = 0x8
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val <<?: word8 * word32 -> word8 =
   (fn x_151: word8 * word32 =>
    case x_151 of
      (x_153: word8, x_152: word32) => Word8_lshift (x_153, x_152))
val ~: word8 -> word8 = (fn x_154: word8 => Word8_neg (x_154))
val notb: word8 -> word8 = (fn x_155: word8 => Word8_notb (x_155))
val orb: word8 * word8 -> word8 =
   (fn x_156: word8 * word8 =>
    case x_156 of
      (x_158: word8, x_157: word8) => Word8_orb (x_158, x_157))
val ~>>?: word8 * word32 -> word8 =
   (fn x_159: word8 * word32 =>
    case x_159 of
      (x_161: word8, x_160: word32) => WordS8_rshift (x_161, x_160))
val >>?: word8 * word32 -> word8 =
   (fn x_162: word8 * word32 =>
    case x_162 of
      (x_164: word8, x_163: word32) => WordU8_rshift (x_164, x_163))
val sizeInBits: int32 = 0x9
val sizeInBits: int32 = 0xA
val sizeInBits: int32 = 0xB
val sizeInBits: int32 = 0xC
val sizeInBits: int32 = 0xD
val sizeInBits: int32 = 0xE
val sizeInBits: int32 = 0xF
val sizeInBits: int32 = 0x10
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val <<?: word16 * word32 -> word16 =
   (fn x_165: word16 * word32 =>
    case x_165 of
      (x_167: word16, x_166: word32) => Word16_lshift (x_167, x_166))
val ~: word16 -> word16 = (fn x_168: word16 => Word16_neg (x_168))
val notb: word16 -> word16 = (fn x_169: word16 => Word16_notb (x_169))
val orb: word16 * word16 -> word16 =
   (fn x_170: word16 * word16 =>
    case x_170 of
      (x_172: word16, x_171: word16) => Word16_orb (x_172, x_171))
val ~>>?: word16 * word32 -> word16 =
   (fn x_173: word16 * word32 =>
    case x_173 of
      (x_175: word16, x_174: word32) => WordS16_rshift (x_175, x_174))
val >>?: word16 * word32 -> word16 =
   (fn x_176: word16 * word32 =>
    case x_176 of
      (x_178: word16, x_177: word32) => WordU16_rshift (x_178, x_177))
val sizeInBits: int32 = 0x11
val sizeInBits: int32 = 0x12
val sizeInBits: int32 = 0x13
val sizeInBits: int32 = 0x14
val sizeInBits: int32 = 0x15
val sizeInBits: int32 = 0x16
val sizeInBits: int32 = 0x17
val sizeInBits: int32 = 0x18
val sizeInBits: int32 = 0x19
val sizeInBits: int32 = 0x1A
val sizeInBits: int32 = 0x1B
val sizeInBits: int32 = 0x1C
val sizeInBits: int32 = 0x1D
val sizeInBits: int32 = 0x1E
val sizeInBits: int32 = 0x1F
val sizeInBits: int32 = 0x20
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val +: word32 * word32 -> word32 =
   (fn x_179: word32 * word32 =>
    case x_179 of
      (x_181: word32, x_180: word32) => Word32_add (x_181, x_180))
val andb: word32 * word32 -> word32 =
   (fn x_182: word32 * word32 =>
    case x_182 of
      (x_184: word32, x_183: word32) => Word32_andb (x_184, x_183))
val <<?: word32 * word32 -> word32 =
   (fn x_185: word32 * word32 =>
    case x_185 of
      (x_187: word32, x_186: word32) => Word32_lshift (x_187, x_186))
val ~: word32 -> word32 = (fn x_188: word32 => Word32_neg (x_188))
val notb: word32 -> word32 = (fn x_189: word32 => Word32_notb (x_189))
val orb: word32 * word32 -> word32 =
   (fn x_190: word32 * word32 =>
    case x_190 of
      (x_192: word32, x_191: word32) => Word32_orb (x_192, x_191))
val ~>>?: word32 * word32 -> word32 =
   (fn x_193: word32 * word32 =>
    case x_193 of
      (x_195: word32, x_194: word32) => WordS32_rshift (x_195, x_194))
val >>?: word32 * word32 -> word32 =
   (fn x_196: word32 * word32 =>
    case x_196 of
      (x_198: word32, x_197: word32) => WordU32_rshift (x_198, x_197))
val -: word32 * word32 -> word32 =
   (fn x_199: word32 * word32 =>
    case x_199 of
      (x_201: word32, x_200: word32) => Word32_sub (x_201, x_200))
val xorb: word32 * word32 -> word32 =
   (fn x_202: word32 * word32 =>
    case x_202 of
      (x_204: word32, x_203: word32) => Word32_xorb (x_204, x_203))
val <: word32 * word32 -> bool =
   (fn x_205: word32 * word32 =>
    case x_205 of
      (x_207: word32, x_206: word32) => WordU32_lt (x_207, x_206))
val <: word32 * word32 -> bool = <
val rec
   <=: word32 * word32 -> bool = 
      (fn x_208: word32 * word32 =>
       case x_208 of
	 ((a: word32, b: word32)) => (not (< (b, a))))
val rec
   >=: word32 * word32 -> bool = 
      (fn x_209: word32 * word32 =>
       case x_209 of
	 ((a: word32, b: word32)) => (<= (b, a)))
val sizeInBits: int32 = 0x40
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val +: word64 * word64 -> word64 =
   (fn x_210: word64 * word64 =>
    case x_210 of
      (x_212: word64, x_211: word64) => Word64_add (x_212, x_211))
val andb: word64 * word64 -> word64 =
   (fn x_213: word64 * word64 =>
    case x_213 of
      (x_215: word64, x_214: word64) => Word64_andb (x_215, x_214))
val <<?: word64 * word32 -> word64 =
   (fn x_216: word64 * word32 =>
    case x_216 of
      (x_218: word64, x_217: word32) => Word64_lshift (x_218, x_217))
val *: word64 * word64 -> word64 =
   (fn x_219: word64 * word64 =>
    case x_219 of
      (x_221: word64, x_220: word64) => WordU64_mul (x_221, x_220))
val ~: word64 -> word64 = (fn x_222: word64 => Word64_neg (x_222))
val notb: word64 -> word64 = (fn x_223: word64 => Word64_notb (x_223))
val orb: word64 * word64 -> word64 =
   (fn x_224: word64 * word64 =>
    case x_224 of
      (x_226: word64, x_225: word64) => Word64_orb (x_226, x_225))
val ~>>?: word64 * word32 -> word64 =
   (fn x_227: word64 * word32 =>
    case x_227 of
      (x_229: word64, x_228: word32) => WordS64_rshift (x_229, x_228))
val >>?: word64 * word32 -> word64 =
   (fn x_230: word64 * word32 =>
    case x_230 of
      (x_232: word64, x_231: word32) => WordU64_rshift (x_232, x_231))
val -: word64 * word64 -> word64 =
   (fn x_233: word64 * word64 =>
    case x_233 of
      (x_235: word64, x_234: word64) => Word64_sub (x_235, x_234))
val xorb: word64 * word64 -> word64 =
   (fn x_236: word64 * word64 =>
    case x_236 of
      (x_238: word64, x_237: word64) => Word64_xorb (x_238, x_237))
val <: word64 * word64 -> bool =
   (fn x_239: word64 * word64 =>
    case x_239 of
      (x_241: word64, x_240: word64) => WordU64_lt (x_241, x_240))
val <: word64 * word64 -> bool = <
val sizeInBits: int32 = 0x1
val sizeInBits: int32 = 0x2
val sizeInBits: int32 = 0x3
val sizeInBits: int32 = 0x4
val sizeInBits: int32 = 0x5
val sizeInBits: int32 = 0x6
val sizeInBits: int32 = 0x7
val sizeInBits: int32 = 0x8
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val <: int8 * int8 -> bool =
   (fn x_242: int8 * int8 =>
    case x_242 of
      (x_244: int8, x_243: int8) => WordS8_lt (x_244, x_243))
val <: int8 * int8 -> bool = <
val rec
   >: int8 * int8 -> bool = 
      (fn x_245: int8 * int8 =>
       case x_245 of
	 ((a: int8, b: int8)) => (< (b, a)))
val sizeInBits: int32 = 0x9
val sizeInBits: int32 = 0xA
val sizeInBits: int32 = 0xB
val sizeInBits: int32 = 0xC
val sizeInBits: int32 = 0xD
val sizeInBits: int32 = 0xE
val sizeInBits: int32 = 0xF
val sizeInBits: int32 = 0x10
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val <: int16 * int16 -> bool =
   (fn x_246: int16 * int16 =>
    case x_246 of
      (x_248: int16, x_247: int16) => WordS16_lt (x_248, x_247))
val <: int16 * int16 -> bool = <
val rec
   >: int16 * int16 -> bool = 
      (fn x_249: int16 * int16 =>
       case x_249 of
	 ((a: int16, b: int16)) => (< (b, a)))
val sizeInBits: int32 = 0x11
val sizeInBits: int32 = 0x12
val sizeInBits: int32 = 0x13
val sizeInBits: int32 = 0x14
val sizeInBits: int32 = 0x15
val sizeInBits: int32 = 0x16
val sizeInBits: int32 = 0x17
val sizeInBits: int32 = 0x18
val sizeInBits: int32 = 0x19
val sizeInBits: int32 = 0x1A
val sizeInBits: int32 = 0x1B
val sizeInBits: int32 = 0x1C
val sizeInBits: int32 = 0x1D
val sizeInBits: int32 = 0x1E
val sizeInBits: int32 = 0x1F
val sizeInBits: int32 = 0x20
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val +!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_250: int32 * int32 =>
					 case x_250 of
					   (x_252: int32, x_251: int32) =>
					   WordS32_addCheck (x_252, x_251)))
val +?: int32 * int32 -> int32 =
   (fn x_253: int32 * int32 =>
    case x_253 of
      (x_255: int32, x_254: int32) => Word32_add (x_255, x_254))
val +: int32 * int32 -> int32 = case detectOverflow of true => +! | false => +?
val *!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_256: int32 * int32 =>
					 case x_256 of
					   (x_258: int32, x_257: int32) =>
					   WordS32_mulCheck (x_258, x_257)))
val *?: int32 * int32 -> int32 =
   (fn x_259: int32 * int32 =>
    case x_259 of
      (x_261: int32, x_260: int32) => WordS32_mul (x_261, x_260))
val *: int32 * int32 -> int32 = case detectOverflow of true => *! | false => *?
val ~!: int32 -> int32 =
   (wrapOverflow (int32, int32) (fn x_262: int32 =>
				 Word32_negCheck (x_262)))
val ~?: int32 -> int32 = (fn x_263: int32 => Word32_neg (x_263))
val ~: int32 -> int32 = case detectOverflow of true => ~! | false => ~?
val quotUnsafe: int32 * int32 -> int32 =
   (fn x_264: int32 * int32 =>
    case x_264 of
      (x_266: int32, x_265: int32) => WordS32_quot (x_266, x_265))
val -!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_267: int32 * int32 =>
					 case x_267 of
					   (x_269: int32, x_268: int32) =>
					   WordS32_subCheck (x_269, x_268)))
val -?: int32 * int32 -> int32 =
   (fn x_270: int32 * int32 =>
    case x_270 of
      (x_272: int32, x_271: int32) => Word32_sub (x_272, x_271))
val -: int32 * int32 -> int32 = case detectOverflow of true => -! | false => -?
val remUnsafe: int32 * int32 -> int32 =
   (fn x_273: int32 * int32 =>
    case x_273 of
      (x_275: int32, x_274: int32) => WordS32_rem (x_275, x_274))
val <: int32 * int32 -> bool =
   (fn x_276: int32 * int32 =>
    case x_276 of
      (x_278: int32, x_277: int32) => WordS32_lt (x_278, x_277))
val <: int32 * int32 -> bool = <
val rec
   <=: int32 * int32 -> bool = 
      (fn x_279: int32 * int32 =>
       case x_279 of
	 ((a: int32, b: int32)) => (not (< (b, a))))
val rec
   >: int32 * int32 -> bool = 
      (fn x_280: int32 * int32 =>
       case x_280 of
	 ((a: int32, b: int32)) => (< (b, a)))
val rec
   >=: int32 * int32 -> bool = 
      (fn x_281: int32 * int32 =>
       case x_281 of
	 ((a: int32, b: int32)) => (<= (b, a)))
val sizeInBits: int32 = 0x40
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val +!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_282: int64 * int64 =>
					 case x_282 of
					   (x_284: int64, x_283: int64) =>
					   WordS64_addCheck (x_284, x_283)))
val +?: int64 * int64 -> int64 =
   (fn x_285: int64 * int64 =>
    case x_285 of
      (x_287: int64, x_286: int64) => Word64_add (x_287, x_286))
val +: int64 * int64 -> int64 = case detectOverflow of true => +! | false => +?
val *!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_288: int64 * int64 =>
					 case x_288 of
					   (x_290: int64, x_289: int64) =>
					   WordS64_mulCheck (x_290, x_289)))
val ~!: int64 -> int64 =
   (wrapOverflow (int64, int64) (fn x_291: int64 =>
				 Word64_negCheck (x_291)))
val ~?: int64 -> int64 = (fn x_292: int64 => Word64_neg (x_292))
val ~: int64 -> int64 = case detectOverflow of true => ~! | false => ~?
val quotUnsafe: int64 * int64 -> int64 =
   (fn x_293: int64 * int64 =>
    case x_293 of
      (x_295: int64, x_294: int64) => WordS64_quot (x_295, x_294))
val -!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_296: int64 * int64 =>
					 case x_296 of
					   (x_298: int64, x_297: int64) =>
					   WordS64_subCheck (x_298, x_297)))
val -?: int64 * int64 -> int64 =
   (fn x_299: int64 * int64 =>
    case x_299 of
      (x_301: int64, x_300: int64) => Word64_sub (x_301, x_300))
val -: int64 * int64 -> int64 = case detectOverflow of true => -! | false => -?
val remUnsafe: int64 * int64 -> int64 =
   (fn x_302: int64 * int64 =>
    case x_302 of
      (x_304: int64, x_303: int64) => WordS64_rem (x_304, x_303))
val <: int64 * int64 -> bool =
   (fn x_305: int64 * int64 =>
    case x_305 of
      (x_307: int64, x_306: int64) => WordS64_lt (x_307, x_306))
val <: int64 * int64 -> bool = <
val rec
   <=: int64 * int64 -> bool = 
      (fn x_308: int64 * int64 =>
       case x_308 of
	 ((a: int64, b: int64)) => (not (< (b, a))))
val rec
   >: int64 * int64 -> bool = 
      (fn x_309: int64 * int64 =>
       case x_309 of
	 ((a: int64, b: int64)) => (< (b, a)))
val rec
   >=: int64 * int64 -> bool = 
      (fn x_310: int64 * int64 =>
       case x_310 of
	 ((a: int64, b: int64)) => (<= (b, a)))
val rec
   min: int64 * int64 -> int64 = 
      (fn x_311: int64 * int64 =>
       case x_311 of
	 ((x: int64, y: int64)) => case (< (x, y)) of true => x | false => y)
val rec
   max: int64 * int64 -> int64 = 
      (fn x_312: int64 * int64 =>
       case x_312 of
	 ((x: int64, y: int64)) => case (< (x, y)) of true => y | false => x)
val 'a_165 check: 'a_165 -> 'a_165 =
   (fn x_313: 'a_165 =>
    case x_313 of
      x: 'a_165 => x)
val 'a check_0: 'a -> 'a = check ('a)
val 'a arrayUnsafe: int64 -> 'a array =
   (fn x_314: int64 =>
    Array_array['a] (x_314))
val 'a array0Const: unit -> 'a array =
   (fn x_315: unit =>
    case x_315 of
      () => Array_array0Const['a] ())
val 'a length: 'a array -> int64 =
   (fn x_316: 'a array =>
    Array_length['a] (x_316))
val 'a subUnsafe: 'a array * int64 -> 'a =
   (fn x_317: 'a array * int64 =>
    case x_317 of
      (x_319: 'a array, x_318: int64) => Array_sub['a] (x_319, x_318))
val 'a updateUnsafe: 'a array * int64 * 'a -> unit =
   (fn x_320: 'a array * int64 * 'a =>
    case x_320 of
      (x_323: 'a array, x_322: int64, x_321: 'a) =>
      Array_update['a] (x_323, x_322, x_321))
val 'a fromArrayUnsafe: 'a array -> 'a vector =
   (fn x_324: 'a array =>
    Array_toVector['a] (x_324))
val 'a length: 'a vector -> int64 =
   (fn x_325: 'a vector =>
    Vector_length['a] (x_325))
val 'a subUnsafe: 'a vector * int64 -> 'a =
   (fn x_326: 'a vector * int64 =>
    case x_326 of
      (x_328: 'a vector, x_327: int64) => Vector_sub['a] (x_328, x_327))
val rec
   fromString: string -> string = 
      (fn x_329: string =>
       case x_329 of
	 (s: string) =>
	 case (= (char8) (0x0,
			  (subUnsafe (char8) (s, (- ((length (char8) s), 0x1)))))) of
	   true => s | false => raise (Fail8 "NullString.fromString"))
val +: intInf * intInf * word64 -> intInf =
   (fn x_330: intInf * intInf * word64 =>
    case x_330 of
      (x_333: intInf, x_332: intInf, x_331: word64) =>
      IntInf_add (x_333, x_332, x_331))
val compare: intInf * intInf -> int32 =
   (fn x_334: intInf * intInf =>
    case x_334 of
      (x_336: intInf, x_335: intInf) => IntInf_compare (x_336, x_335))
val fromVector: word64 vector -> intInf =
   (fn x_337: word64 vector =>
    WordVector_toIntInf (x_337))
val fromWord: word64 -> intInf = (fn x_338: word64 => Word_toIntInf (x_338))
val *: intInf * intInf * word64 -> intInf =
   (fn x_339: intInf * intInf * word64 =>
    case x_339 of
      (x_342: intInf, x_341: intInf, x_340: word64) =>
      IntInf_mul (x_342, x_341, x_340))
val ~: intInf * word64 -> intInf =
   (fn x_343: intInf * word64 =>
    case x_343 of
      (x_345: intInf, x_344: word64) => IntInf_neg (x_345, x_344))
val quot: intInf * intInf * word64 -> intInf =
   (fn x_346: intInf * intInf * word64 =>
    case x_346 of
      (x_349: intInf, x_348: intInf, x_347: word64) =>
      IntInf_quot (x_349, x_348, x_347))
val toString: intInf * int32 * word64 -> string =
   (fn x_350: intInf * int32 * word64 =>
    case x_350 of
      (x_353: intInf, x_352: int32, x_351: word64) =>
      IntInf_toString (x_353, x_352, x_351))
val toVector: intInf -> word64 vector =
   (fn x_354: intInf =>
    IntInf_toVector (x_354))
val toWord: intInf -> word64 = (fn x_355: intInf => IntInf_toWord (x_355))
val <: char8 * char8 -> bool =
   (fn x_356: char8 * char8 =>
    case x_356 of
      (x_358: char8, x_357: char8) => WordU8_lt (x_358, x_357))
val idToWord8: char8 -> word8 = (fn x_359: char8 => WordU8_extdToWord8 (x_359))
val idFromWord8: word8 -> char8 =
   (fn x_360: word8 =>
    WordU8_extdToWord8 (x_360))
val <: char8 * char8 -> bool = <
val rec
   <=: char8 * char8 -> bool = 
      (fn x_361: char8 * char8 =>
       case x_361 of
	 ((a: char8, b: char8)) => (not (< (b, a))))
val idToWord16: char16 -> word16 =
   (fn x_362: char16 =>
    WordU16_extdToWord16 (x_362))
val idFromWord16: word16 -> char16 =
   (fn x_363: word16 =>
    WordU16_extdToWord16 (x_363))
val idToWord32: char32 -> word32 =
   (fn x_364: char32 =>
    WordU32_extdToWord32 (x_364))
val idFromWord32: word32 -> char32 =
   (fn x_365: word32 =>
    WordU32_extdToWord32 (x_365))
val realSize: int32 = 0x20
val precision: int32 = 0x18
val acos: real32 -> real32 = (fn x_366: real32 => Real32_Math_acos (x_366))
val asin: real32 -> real32 = (fn x_367: real32 => Real32_Math_asin (x_367))
val atan: real32 -> real32 = (fn x_368: real32 => Real32_Math_atan (x_368))
val atan2: real32 * real32 -> real32 =
   (fn x_369: real32 * real32 =>
    case x_369 of
      (x_371: real32, x_370: real32) => Real32_Math_atan2 (x_371, x_370))
val cos: real32 -> real32 = (fn x_372: real32 => Real32_Math_cos (x_372))
val cosh: real32 -> real32 = (fn x_373: real32 => Real32_Math_cosh (x_373))
val e: real32 =
   (((fn x_374: (unit -> real32) * (real32 -> unit) =>
      case x_374 of
	{1 = #: unit -> real32} => #) ((fn x_376: unit =>
				CPointer_getReal32 (Real32_Math_e (), 0x0)),
			       (fn x_375: real32 =>
				CPointer_setReal32 (Real32_Math_e (), 0x0, x_375)))) ())
val exp: real32 -> real32 = (fn x_377: real32 => Real32_Math_exp (x_377))
val ln: real32 -> real32 = (fn x_378: real32 => Real32_Math_ln (x_378))
val log10: real32 -> real32 = (fn x_379: real32 => Real32_Math_log10 (x_379))
val pi: real32 =
   (((fn x_380: (unit -> real32) * (real32 -> unit) =>
      case x_380 of
	{1 = #: unit -> real32} => #) ((fn x_382: unit =>
				CPointer_getReal32 (Real32_Math_pi (), 0x0)),
			       (fn x_381: real32 =>
				CPointer_setReal32 (Real32_Math_pi (),
						    0x0,
						    x_381)))) ())
val pow: real32 * real32 -> real32 =
   (fn x_383: real32 * real32 =>
    case x_383 of
      (x_385: real32, x_384: real32) => Real32_Math_pow (x_385, x_384))
val sin: real32 -> real32 = (fn x_386: real32 => Real32_Math_sin (x_386))
val sinh: real32 -> real32 = (fn x_387: real32 => Real32_Math_sinh (x_387))
val sqrt: real32 -> real32 = (fn x_388: real32 => Real32_Math_sqrt (x_388))
val tan: real32 -> real32 = (fn x_389: real32 => Real32_Math_tan (x_389))
val tanh: real32 -> real32 = (fn x_390: real32 => Real32_Math_tanh (x_390))
val *: real32 * real32 -> real32 =
   (fn x_391: real32 * real32 =>
    case x_391 of
      (x_393: real32, x_392: real32) => Real32_mul (x_393, x_392))
val *+: real32 * real32 * real32 -> real32 =
   (fn x_394: real32 * real32 * real32 =>
    case x_394 of
      (x_397: real32, x_396: real32, x_395: real32) =>
      Real32_muladd (x_397, x_396, x_395))
val *-: real32 * real32 * real32 -> real32 =
   (fn x_398: real32 * real32 * real32 =>
    case x_398 of
      (x_401: real32, x_400: real32, x_399: real32) =>
      Real32_mulsub (x_401, x_400, x_399))
val +: real32 * real32 -> real32 =
   (fn x_402: real32 * real32 =>
    case x_402 of
      (x_404: real32, x_403: real32) => Real32_add (x_404, x_403))
val -: real32 * real32 -> real32 =
   (fn x_405: real32 * real32 =>
    case x_405 of
      (x_407: real32, x_406: real32) => Real32_sub (x_407, x_406))
val /: real32 * real32 -> real32 =
   (fn x_408: real32 * real32 =>
    case x_408 of
      (x_410: real32, x_409: real32) => Real32_div (x_410, x_409))
val ~: real32 -> real32 = (fn x_411: real32 => Real32_neg (x_411))
val <: real32 * real32 -> bool =
   (fn x_412: real32 * real32 =>
    case x_412 of
      (x_414: real32, x_413: real32) => Real32_lt (x_414, x_413))
val <=: real32 * real32 -> bool =
   (fn x_415: real32 * real32 =>
    case x_415 of
      (x_417: real32, x_416: real32) => Real32_le (x_417, x_416))
val ==: real32 * real32 -> bool =
   (fn x_418: real32 * real32 =>
    case x_418 of
      (x_420: real32, x_419: real32) => Real32_equal (x_420, x_419))
val abs: real32 -> real32 = (fn x_421: real32 => Real32_abs (x_421))
val class: real32 -> int32 = (fn x_422: real32 => Real32_class (x_422))
val frexp: real32 * int32 ref -> real32 =
   (fn x_423: real32 * int32 ref =>
    case x_423 of
      (x_425: real32, x_424: int32 ref) => Real32_frexp (x_425, x_424))
val gdtoa: real32 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_426: real32 * int32 * int32 * int32 * int32 ref =>
    case x_426 of
      (x_431: real32, x_430: int32, x_429: int32, x_428: int32, x_427: int32 ref) =>
      Real32_gdtoa (x_431, x_430, x_429, x_428, x_427))
val ldexp: real32 * int32 -> real32 =
   (fn x_432: real32 * int32 =>
    case x_432 of
      (x_434: real32, x_433: int32) => Real32_ldexp (x_434, x_433))
val maxFinite: real32 =
   (((fn x_435: (unit -> real32) * (real32 -> unit) =>
      case x_435 of
	{1 = #: unit -> real32} => #) ((fn x_437: unit =>
				CPointer_getReal32 (Real32_maxFinite (), 0x0)),
			       (fn x_436: real32 =>
				CPointer_setReal32 (Real32_maxFinite (),
						    0x0,
						    x_436)))) ())
val minNormalPos: real32 =
   (((fn x_438: (unit -> real32) * (real32 -> unit) =>
      case x_438 of
	{1 = #: unit -> real32} => #) ((fn x_440: unit =>
				CPointer_getReal32 (Real32_minNormalPos (), 0x0)),
			       (fn x_439: real32 =>
				CPointer_setReal32 (Real32_minNormalPos (),
						    0x0,
						    x_439)))) ())
val minPos: real32 =
   (((fn x_441: (unit -> real32) * (real32 -> unit) =>
      case x_441 of
	{1 = #: unit -> real32} => #) ((fn x_443: unit =>
				CPointer_getReal32 (Real32_minPos (), 0x0)),
			       (fn x_442: real32 =>
				CPointer_setReal32 (Real32_minPos (), 0x0, x_442)))) ())
val modf: real32 * real32 ref -> real32 =
   (fn x_444: real32 * real32 ref =>
    case x_444 of
      (x_446: real32, x_445: real32 ref) => Real32_modf (x_446, x_445))
val round: real32 -> real32 = (fn x_447: real32 => Real32_round (x_447))
val signBit: real32 -> int32 = (fn x_448: real32 => Real32_signBit (x_448))
val strto: string * int32 -> real32 =
   (fn x_449: string * int32 =>
    case x_449 of
      (x_451: string, x_450: int32) => Real32_strto (x_451, x_450))
val fromInt8Unsafe: int8 -> real32 =
   (fn x_452: int8 =>
    WordS8_rndToReal32 (x_452))
val fromInt16Unsafe: int16 -> real32 =
   (fn x_453: int16 =>
    WordS16_rndToReal32 (x_453))
val fromInt32Unsafe: int32 -> real32 =
   (fn x_454: int32 =>
    WordS32_rndToReal32 (x_454))
val fromInt64Unsafe: int64 -> real32 =
   (fn x_455: int64 =>
    WordS64_rndToReal32 (x_455))
val fromReal32Unsafe: real32 -> real32 =
   (fn x_456: real32 =>
    Real32_rndToReal32 (x_456))
val fromWord8Unsafe: word8 -> real32 =
   (fn x_457: word8 =>
    WordU8_rndToReal32 (x_457))
val fromWord16Unsafe: word16 -> real32 =
   (fn x_458: word16 =>
    WordU16_rndToReal32 (x_458))
val fromWord32Unsafe: word32 -> real32 =
   (fn x_459: word32 =>
    WordU32_rndToReal32 (x_459))
val fromWord64Unsafe: word64 -> real32 =
   (fn x_460: word64 =>
    WordU64_rndToReal32 (x_460))
val toInt8Unsafe: real32 -> int8 =
   (fn x_461: real32 =>
    Real32_rndToWordS8 (x_461))
val toInt16Unsafe: real32 -> int16 =
   (fn x_462: real32 =>
    Real32_rndToWordS16 (x_462))
val toInt32Unsafe: real32 -> int32 =
   (fn x_463: real32 =>
    Real32_rndToWordS32 (x_463))
val toInt64Unsafe: real32 -> int64 =
   (fn x_464: real32 =>
    Real32_rndToWordS64 (x_464))
val toReal32Unsafe: real32 -> real32 =
   (fn x_465: real32 =>
    Real32_rndToReal32 (x_465))
val toWord8Unsafe: real32 -> word8 =
   (fn x_466: real32 =>
    Real32_rndToWordU8 (x_466))
val toWord16Unsafe: real32 -> word16 =
   (fn x_467: real32 =>
    Real32_rndToWordU16 (x_467))
val toWord32Unsafe: real32 -> word32 =
   (fn x_468: real32 =>
    Real32_rndToWordU32 (x_468))
val toWord64Unsafe: real32 -> word64 =
   (fn x_469: real32 =>
    Real32_rndToWordU64 (x_469))
val rec
   >: real32 * real32 -> bool = 
      (fn x_470: real32 * real32 =>
       case x_470 of
	 ((a: real32, b: real32)) => (< (b, a)))
val rec
   >=: real32 * real32 -> bool = 
      (fn x_471: real32 * real32 =>
       case x_471 of
	 ((a: real32, b: real32)) => (<= (b, a)))
val precision: int32 = 0x35
val acos: real64 -> real64 = (fn x_472: real64 => Real64_Math_acos (x_472))
val asin: real64 -> real64 = (fn x_473: real64 => Real64_Math_asin (x_473))
val atan: real64 -> real64 = (fn x_474: real64 => Real64_Math_atan (x_474))
val atan2: real64 * real64 -> real64 =
   (fn x_475: real64 * real64 =>
    case x_475 of
      (x_477: real64, x_476: real64) => Real64_Math_atan2 (x_477, x_476))
val cos: real64 -> real64 = (fn x_478: real64 => Real64_Math_cos (x_478))
val cosh: real64 -> real64 = (fn x_479: real64 => Real64_Math_cosh (x_479))
val e: real64 =
   (((fn x_480: (unit -> real64) * (real64 -> unit) =>
      case x_480 of
	{1 = #: unit -> real64} => #) ((fn x_482: unit =>
				CPointer_getReal64 (Real64_Math_e (), 0x0)),
			       (fn x_481: real64 =>
				CPointer_setReal64 (Real64_Math_e (), 0x0, x_481)))) ())
val exp: real64 -> real64 = (fn x_483: real64 => Real64_Math_exp (x_483))
val ln: real64 -> real64 = (fn x_484: real64 => Real64_Math_ln (x_484))
val log10: real64 -> real64 = (fn x_485: real64 => Real64_Math_log10 (x_485))
val pi: real64 =
   (((fn x_486: (unit -> real64) * (real64 -> unit) =>
      case x_486 of
	{1 = #: unit -> real64} => #) ((fn x_488: unit =>
				CPointer_getReal64 (Real64_Math_pi (), 0x0)),
			       (fn x_487: real64 =>
				CPointer_setReal64 (Real64_Math_pi (),
						    0x0,
						    x_487)))) ())
val pow: real64 * real64 -> real64 =
   (fn x_489: real64 * real64 =>
    case x_489 of
      (x_491: real64, x_490: real64) => Real64_Math_pow (x_491, x_490))
val sin: real64 -> real64 = (fn x_492: real64 => Real64_Math_sin (x_492))
val sinh: real64 -> real64 = (fn x_493: real64 => Real64_Math_sinh (x_493))
val sqrt: real64 -> real64 = (fn x_494: real64 => Real64_Math_sqrt (x_494))
val tan: real64 -> real64 = (fn x_495: real64 => Real64_Math_tan (x_495))
val tanh: real64 -> real64 = (fn x_496: real64 => Real64_Math_tanh (x_496))
val *: real64 * real64 -> real64 =
   (fn x_497: real64 * real64 =>
    case x_497 of
      (x_499: real64, x_498: real64) => Real64_mul (x_499, x_498))
val *+: real64 * real64 * real64 -> real64 =
   (fn x_500: real64 * real64 * real64 =>
    case x_500 of
      (x_503: real64, x_502: real64, x_501: real64) =>
      Real64_muladd (x_503, x_502, x_501))
val *-: real64 * real64 * real64 -> real64 =
   (fn x_504: real64 * real64 * real64 =>
    case x_504 of
      (x_507: real64, x_506: real64, x_505: real64) =>
      Real64_mulsub (x_507, x_506, x_505))
val +: real64 * real64 -> real64 =
   (fn x_508: real64 * real64 =>
    case x_508 of
      (x_510: real64, x_509: real64) => Real64_add (x_510, x_509))
val -: real64 * real64 -> real64 =
   (fn x_511: real64 * real64 =>
    case x_511 of
      (x_513: real64, x_512: real64) => Real64_sub (x_513, x_512))
val /: real64 * real64 -> real64 =
   (fn x_514: real64 * real64 =>
    case x_514 of
      (x_516: real64, x_515: real64) => Real64_div (x_516, x_515))
val ~: real64 -> real64 = (fn x_517: real64 => Real64_neg (x_517))
val <: real64 * real64 -> bool =
   (fn x_518: real64 * real64 =>
    case x_518 of
      (x_520: real64, x_519: real64) => Real64_lt (x_520, x_519))
val <=: real64 * real64 -> bool =
   (fn x_521: real64 * real64 =>
    case x_521 of
      (x_523: real64, x_522: real64) => Real64_le (x_523, x_522))
val ==: real64 * real64 -> bool =
   (fn x_524: real64 * real64 =>
    case x_524 of
      (x_526: real64, x_525: real64) => Real64_equal (x_526, x_525))
val abs: real64 -> real64 = (fn x_527: real64 => Real64_abs (x_527))
val class: real64 -> int32 = (fn x_528: real64 => Real64_class (x_528))
val frexp: real64 * int32 ref -> real64 =
   (fn x_529: real64 * int32 ref =>
    case x_529 of
      (x_531: real64, x_530: int32 ref) => Real64_frexp (x_531, x_530))
val gdtoa: real64 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_532: real64 * int32 * int32 * int32 * int32 ref =>
    case x_532 of
      (x_537: real64, x_536: int32, x_535: int32, x_534: int32, x_533: int32 ref) =>
      Real64_gdtoa (x_537, x_536, x_535, x_534, x_533))
val ldexp: real64 * int32 -> real64 =
   (fn x_538: real64 * int32 =>
    case x_538 of
      (x_540: real64, x_539: int32) => Real64_ldexp (x_540, x_539))
val maxFinite: real64 =
   (((fn x_541: (unit -> real64) * (real64 -> unit) =>
      case x_541 of
	{1 = #: unit -> real64} => #) ((fn x_543: unit =>
				CPointer_getReal64 (Real64_maxFinite (), 0x0)),
			       (fn x_542: real64 =>
				CPointer_setReal64 (Real64_maxFinite (),
						    0x0,
						    x_542)))) ())
val minNormalPos: real64 =
   (((fn x_544: (unit -> real64) * (real64 -> unit) =>
      case x_544 of
	{1 = #: unit -> real64} => #) ((fn x_546: unit =>
				CPointer_getReal64 (Real64_minNormalPos (), 0x0)),
			       (fn x_545: real64 =>
				CPointer_setReal64 (Real64_minNormalPos (),
						    0x0,
						    x_545)))) ())
val minPos: real64 =
   (((fn x_547: (unit -> real64) * (real64 -> unit) =>
      case x_547 of
	{1 = #: unit -> real64} => #) ((fn x_549: unit =>
				CPointer_getReal64 (Real64_minPos (), 0x0)),
			       (fn x_548: real64 =>
				CPointer_setReal64 (Real64_minPos (), 0x0, x_548)))) ())
val modf: real64 * real64 ref -> real64 =
   (fn x_550: real64 * real64 ref =>
    case x_550 of
      (x_552: real64, x_551: real64 ref) => Real64_modf (x_552, x_551))
val round: real64 -> real64 = (fn x_553: real64 => Real64_round (x_553))
val signBit: real64 -> int32 = (fn x_554: real64 => Real64_signBit (x_554))
val strto: string * int32 -> real64 =
   (fn x_555: string * int32 =>
    case x_555 of
      (x_557: string, x_556: int32) => Real64_strto (x_557, x_556))
val fromInt8Unsafe: int8 -> real64 =
   (fn x_558: int8 =>
    WordS8_rndToReal64 (x_558))
val fromInt16Unsafe: int16 -> real64 =
   (fn x_559: int16 =>
    WordS16_rndToReal64 (x_559))
val fromInt32Unsafe: int32 -> real64 =
   (fn x_560: int32 =>
    WordS32_rndToReal64 (x_560))
val fromInt64Unsafe: int64 -> real64 =
   (fn x_561: int64 =>
    WordS64_rndToReal64 (x_561))
val fromReal32Unsafe: real32 -> real64 =
   (fn x_562: real32 =>
    Real32_rndToReal64 (x_562))
val fromWord8Unsafe: word8 -> real64 =
   (fn x_563: word8 =>
    WordU8_rndToReal64 (x_563))
val fromWord16Unsafe: word16 -> real64 =
   (fn x_564: word16 =>
    WordU16_rndToReal64 (x_564))
val fromWord32Unsafe: word32 -> real64 =
   (fn x_565: word32 =>
    WordU32_rndToReal64 (x_565))
val fromWord64Unsafe: word64 -> real64 =
   (fn x_566: word64 =>
    WordU64_rndToReal64 (x_566))
val toInt8Unsafe: real64 -> int8 =
   (fn x_567: real64 =>
    Real64_rndToWordS8 (x_567))
val toInt16Unsafe: real64 -> int16 =
   (fn x_568: real64 =>
    Real64_rndToWordS16 (x_568))
val toInt32Unsafe: real64 -> int32 =
   (fn x_569: real64 =>
    Real64_rndToWordS32 (x_569))
val toInt64Unsafe: real64 -> int64 =
   (fn x_570: real64 =>
    Real64_rndToWordS64 (x_570))
val toReal32Unsafe: real64 -> real32 =
   (fn x_571: real64 =>
    Real64_rndToReal32 (x_571))
val toWord8Unsafe: real64 -> word8 =
   (fn x_572: real64 =>
    Real64_rndToWordU8 (x_572))
val toWord16Unsafe: real64 -> word16 =
   (fn x_573: real64 =>
    Real64_rndToWordU16 (x_573))
val toWord32Unsafe: real64 -> word32 =
   (fn x_574: real64 =>
    Real64_rndToWordU32 (x_574))
val toWord64Unsafe: real64 -> word64 =
   (fn x_575: real64 =>
    Real64_rndToWordU64 (x_575))
val rec
   >: real64 * real64 -> bool = 
      (fn x_576: real64 * real64 =>
       case x_576 of
	 ((a: real64, b: real64)) => (< (b, a)))
val rec
   >=: real64 * real64 -> bool = 
      (fn x_577: real64 * real64 =>
       case x_577 of
	 ((a: real64, b: real64)) => (<= (b, a)))
val subArr: word8 array * int64 -> word8 =
   (fn x_578: word8 array * int64 =>
    case x_578 of
      (x_580: word8 array, x_579: int64) => Word8Array_subWord8 (x_580, x_579))
val subVec: word8 vector * int64 -> word8 =
   (fn x_581: word8 vector * int64 =>
    case x_581 of
      (x_583: word8 vector, x_582: int64) => Word8Vector_subWord8 (x_583, x_582))
val update: word8 array * int64 * word8 -> unit =
   (fn x_584: word8 array * int64 * word8 =>
    case x_584 of
      (x_587: word8 array, x_586: int64, x_585: word8) =>
      Word8Array_updateWord8 (x_587, x_586, x_585))
val subArr: word8 array * int64 -> word16 =
   (fn x_588: word8 array * int64 =>
    case x_588 of
      (x_590: word8 array, x_589: int64) => Word8Array_subWord16 (x_590, x_589))
val subVec: word8 vector * int64 -> word16 =
   (fn x_591: word8 vector * int64 =>
    case x_591 of
      (x_593: word8 vector, x_592: int64) =>
      Word8Vector_subWord16 (x_593, x_592))
val update: word8 array * int64 * word16 -> unit =
   (fn x_594: word8 array * int64 * word16 =>
    case x_594 of
      (x_597: word8 array, x_596: int64, x_595: word16) =>
      Word8Array_updateWord16 (x_597, x_596, x_595))
val subArr: word8 array * int64 -> word32 =
   (fn x_598: word8 array * int64 =>
    case x_598 of
      (x_600: word8 array, x_599: int64) => Word8Array_subWord32 (x_600, x_599))
val subVec: word8 vector * int64 -> word32 =
   (fn x_601: word8 vector * int64 =>
    case x_601 of
      (x_603: word8 vector, x_602: int64) =>
      Word8Vector_subWord32 (x_603, x_602))
val update: word8 array * int64 * word32 -> unit =
   (fn x_604: word8 array * int64 * word32 =>
    case x_604 of
      (x_607: word8 array, x_606: int64, x_605: word32) =>
      Word8Array_updateWord32 (x_607, x_606, x_605))
val subArr: word8 array * int64 -> word64 =
   (fn x_608: word8 array * int64 =>
    case x_608 of
      (x_610: word8 array, x_609: int64) => Word8Array_subWord64 (x_610, x_609))
val subVec: word8 vector * int64 -> word64 =
   (fn x_611: word8 vector * int64 =>
    case x_611 of
      (x_613: word8 vector, x_612: int64) =>
      Word8Vector_subWord64 (x_613, x_612))
val update: word8 array * int64 * word64 -> unit =
   (fn x_614: word8 array * int64 * word64 =>
    case x_614 of
      (x_617: word8 array, x_616: int64, x_615: word64) =>
      Word8Array_updateWord64 (x_617, x_616, x_615))
val castFromWord: word32 -> real32 =
   (fn x_618: word32 =>
    Word32_castToReal32 (x_618))
val castToWord: real32 -> word32 =
   (fn x_619: real32 =>
    Real32_castToWord32 (x_619))
val halt: int32 -> unit = (fn x_620: int32 => MLton_halt (x_620))
val gcState: cpointer =
   (((fn x_621: (unit -> cpointer) * (cpointer -> unit) =>
      case x_621 of
	{1 = #: unit -> cpointer} => #) ((fn x_623: unit =>
				  CPointer_getCPointer (gcStateAddress (), 0x0)),
				 (fn x_622: cpointer =>
				  CPointer_setCPointer (gcStateAddress (),
							0x0,
							x_622)))) ())
datatype Primitive.MLton.Align.t = Align4
				   | Align8
val align: Primitive.MLton.Align.t =
   case 0x4 of
     0x4 => Align4 | 0x8 => Align8 | _ => raise (Fail8 "MLton_Align_align")
datatype Primitive.MLton.CallStack.t = T of word32 array
val callStack: cpointer * word32 array -> unit =
   (fn x_624: cpointer * word32 array =>
    case x_624 of
      (x_626: cpointer, x_625: word32 array) => GC_callStack (x_626, x_625))
val frameIndexSourceSeq: cpointer * word32 -> cpointer =
   (fn x_627: cpointer * word32 =>
    case x_627 of
      (x_629: cpointer, x_628: word32) => GC_frameIndexSourceSeq (x_629, x_628))
val keep: bool = 0x0
val numStackFrames: cpointer -> word32 =
   (fn x_630: cpointer =>
    GC_numStackFrames (x_630))
val sourceName: cpointer * word32 -> word64 =
   (fn x_631: cpointer * word32 =>
    case x_631 of
      (x_633: cpointer, x_632: word32) => GC_sourceName (x_633, x_632))
datatype Primitive.MLton.Codegen.t = Bytecode
				     | C
				     | x86
				     | amd64
val 'a extra: exn -> 'a = (fn x_634: exn => Exn_extra['a] (x_634))
val extra: exn -> Primitive.MLton.CallStack.t Primitive.Option.t =
   extra (Primitive.MLton.CallStack.t Primitive.Option.t)
val keepHistory: bool = 0x0
val 'a setExtendExtra: ('a -> 'a) -> unit =
   (fn x_635: 'a -> 'a =>
    Exn_setExtendExtra['a] (x_635))
val setExtendExtra: (Primitive.MLton.CallStack.t Primitive.Option.t
		     -> Primitive.MLton.CallStack.t Primitive.Option.t)
		    -> unit =
   setExtendExtra (Primitive.MLton.CallStack.t Primitive.Option.t)
val setExtendExtra: (Primitive.MLton.CallStack.t Primitive.Option.t
		     -> Primitive.MLton.CallStack.t Primitive.Option.t)
		    -> unit =
   case keepHistory of
     true =>
     (setExtendExtra (fn x_636: Primitive.MLton.CallStack.t Primitive.Option.t =>
		      case x_636 of
			_ => NONE[Primitive.MLton.CallStack.t]))
     ;setExtendExtra
   | false =>
     (fn x_637: Primitive.MLton.CallStack.t Primitive.Option.t
		-> Primitive.MLton.CallStack.t Primitive.Option.t =>
      case x_637 of
	_ => ())
datatype Primitive.MLton.Platform.Arch.t = Alpha
					   | AMD64
					   | ARM
					   | HPPA
					   | IA64
					   | m68k
					   | MIPS
					   | PowerPC
					   | PowerPC64
					   | S390
					   | Sparc
					   | X86
datatype Primitive.MLton.Platform.Format.t = Archive
					     | Executable
					     | LibArchive
					     | Library
val host: Primitive.MLton.Platform.Format.t =
   case "executable" of
     "archive" => Archive
   | "executable" => Executable
   | "libarchive" => LibArchive
   | "library" => Library
   | _ => raise (Fail8 "strange MLton_Platform_Format")
datatype Primitive.MLton.Platform.OS.t = AIX
					 | Cygwin
					 | Darwin
					 | FreeBSD
					 | Hurd
					 | HPUX
					 | Linux
					 | MinGW
					 | NetBSD
					 | OpenBSD
					 | Solaris
val host: Primitive.MLton.Platform.OS.t =
   case "darwin" of
     "aix" => AIX
   | "cygwin" => Cygwin
   | "darwin" => Darwin
   | "freebsd" => FreeBSD
   | "hurd" => Hurd
   | "hpux" => HPUX
   | "linux" => Linux
   | "mingw" => MinGW
   | "netbsd" => NetBSD
   | "openbsd" => OpenBSD
   | "solaris" => Solaris
   | _ => raise (Fail8 "strange MLton_Platform_OS_host")
val fromWord: word64 -> cpointer =
   (fn x_638: word64 =>
    CPointer_fromWord (x_638))
val null: cpointer = (fromWord 0x0)
val rec
   isNull: cpointer -> bool = 
      (fn x_639: cpointer =>
       case x_639 of
	 (p: cpointer) => (= (cpointer) (p, null)))
val getInt32: cpointer * int64 -> int32 =
   (fn x_640: cpointer * int64 =>
    case x_640 of
      (x_642: cpointer, x_641: int64) => CPointer_getWord32 (x_642, x_641))
val getWord8: cpointer * int64 -> word8 =
   (fn x_643: cpointer * int64 =>
    case x_643 of
      (x_645: cpointer, x_644: int64) => CPointer_getWord8 (x_645, x_644))
val getWord32: cpointer * int64 -> word32 =
   (fn x_646: cpointer * int64 =>
    case x_646 of
      (x_648: cpointer, x_647: int64) => CPointer_getWord32 (x_648, x_647))
val isOn: bool = 0x0
val dummy: cpointer = null
val free: cpointer * cpointer -> unit =
   (fn x_649: cpointer * cpointer =>
    case x_649 of
      (x_651: cpointer, x_650: cpointer) => GC_profileFree (x_651, x_650))
val write: cpointer * cpointer * string -> unit =
   (fn x_652: cpointer * cpointer * string =>
    case x_652 of
      (x_655: cpointer, x_654: cpointer, x_653: string) =>
      GC_profileWrite (x_655, x_654, x_653))
val done: cpointer -> unit = (fn x_656: cpointer => GC_profileDone (x_656))
val getCurrent: cpointer -> cpointer =
   (fn x_657: cpointer =>
    GC_getProfileCurrent (x_657))
val setCurrent: cpointer * cpointer -> unit =
   (fn x_658: cpointer * cpointer =>
    case x_658 of
      (x_660: cpointer, x_659: cpointer) => GC_setProfileCurrent (x_660, x_659))
val atomicState: unit -> word32 =
   (fn x_661: unit =>
    case x_661 of
      () => Thread_atomicState ())
val atomicBegin: unit -> unit =
   (fn x_662: unit =>
    case x_662 of
      () => Thread_atomicBegin ())
val rec
   atomicEnd: unit -> unit = 
      (fn x_663: unit =>
       case x_663 of
	 (()) =>
	 case (= (word32) ((atomicState ()), 0x0)) of
	   true => raise (Fail8 "Thread.atomicEnd")
	 | false =>
	   ((fn x_664: unit =>
	     case x_664 of
	       () => Thread_atomicEnd ()) ()))
val returnToC: unit -> unit =
   (fn x_665: unit =>
    case x_665 of
      () => Thread_returnToC ())
val FP_INFINITE: int32 = 0x2
val FP_NAN: int32 = 0x1
val FP_NORMAL: int32 = 0x4
val FP_SUBNORMAL: int32 = 0x5
val FP_ZERO: int32 = 0x3
val getRoundingMode: unit -> int32 =
   (fn x_666: unit =>
    case x_666 of
      () => IEEEReal_getRoundingMode ())
val FE_DOWNWARD: int32 = 0x400
val FE_NOSUPPORT: int32 = 0xFFFFFFFF
val FE_TONEAREST: int32 = 0x0
val FE_TOWARDZERO: int32 = 0xC00
val FE_UPWARD: int32 = 0x800
val setRoundingMode: int32 -> int32 =
   (fn x_667: int32 =>
    IEEEReal_setRoundingMode (x_667))
val bug: string -> unit = (fn x_668: string => MLton_bug (x_668))
val htons: word16 -> word16 = (fn x_669: word16 => Net_htons (x_669))
val ntohs: word16 -> word16 = (fn x_670: word16 => Net_ntohs (x_670))
val clearErrno: unit -> unit =
   (fn x_671: unit =>
    case x_671 of
      () => Posix_Error_clearErrno ())
val E2BIG: int32 = 0x7
val EACCES: int32 = 0xD
val EADDRINUSE: int32 = 0x30
val EADDRNOTAVAIL: int32 = 0x31
val EAFNOSUPPORT: int32 = 0x2F
val EAGAIN: int32 = 0x23
val EALREADY: int32 = 0x25
val EBADF: int32 = 0x9
val EBADMSG: int32 = 0x5E
val EBUSY: int32 = 0x10
val ECANCELED: int32 = 0x59
val ECHILD: int32 = 0xA
val ECONNABORTED: int32 = 0x35
val ECONNREFUSED: int32 = 0x3D
val ECONNRESET: int32 = 0x36
val EDEADLK: int32 = 0xB
val EDESTADDRREQ: int32 = 0x27
val EDOM: int32 = 0x21
val EDQUOT: int32 = 0x45
val EEXIST: int32 = 0x11
val EFAULT: int32 = 0xE
val EFBIG: int32 = 0x1B
val EHOSTUNREACH: int32 = 0x41
val EIDRM: int32 = 0x5A
val EILSEQ: int32 = 0x5C
val EINPROGRESS: int32 = 0x24
val EINTR: int32 = 0x4
val EINVAL: int32 = 0x16
val EIO: int32 = 0x5
val EISCONN: int32 = 0x38
val EISDIR: int32 = 0x15
val ELOOP: int32 = 0x3E
val EMFILE: int32 = 0x18
val EMLINK: int32 = 0x1F
val EMSGSIZE: int32 = 0x28
val EMULTIHOP: int32 = 0x5F
val ENAMETOOLONG: int32 = 0x3F
val ENETDOWN: int32 = 0x32
val ENETRESET: int32 = 0x34
val ENETUNREACH: int32 = 0x33
val ENFILE: int32 = 0x17
val ENOBUFS: int32 = 0x37
val ENODATA: int32 = 0x60
val ENODEV: int32 = 0x13
val ENOENT: int32 = 0x2
val ENOEXEC: int32 = 0x8
val ENOLCK: int32 = 0x4D
val ENOLINK: int32 = 0x61
val ENOMEM: int32 = 0xC
val ENOMSG: int32 = 0x5B
val ENOPROTOOPT: int32 = 0x2A
val ENOSPC: int32 = 0x1C
val ENOSR: int32 = 0x62
val ENOSTR: int32 = 0x63
val ENOSYS: int32 = 0x4E
val ENOTCONN: int32 = 0x39
val ENOTDIR: int32 = 0x14
val ENOTEMPTY: int32 = 0x42
val ENOTSOCK: int32 = 0x26
val ENOTSUP: int32 = 0x2D
val ENOTTY: int32 = 0x19
val ENXIO: int32 = 0x6
val EOPNOTSUPP: int32 = 0x66
val EOVERFLOW: int32 = 0x54
val EPERM: int32 = 0x1
val EPIPE: int32 = 0x20
val EPROTO: int32 = 0x64
val EPROTONOSUPPORT: int32 = 0x2B
val EPROTOTYPE: int32 = 0x29
val ERANGE: int32 = 0x22
val EROFS: int32 = 0x1E
val ESPIPE: int32 = 0x1D
val ESRCH: int32 = 0x3
val ESTALE: int32 = 0x46
val ETIME: int32 = 0x65
val ETIMEDOUT: int32 = 0x3C
val ETXTBSY: int32 = 0x1A
val EWOULDBLOCK: int32 = 0x23
val EXDEV: int32 = 0x12
val getErrno: unit -> int32 =
   (fn x_672: unit =>
    case x_672 of
      () => Posix_Error_getErrno ())
val strError: int32 -> word64 =
   (fn x_673: int32 =>
    Posix_Error_strError (x_673))
val APPEND: int32 = 0x8
val NONBLOCK: int32 = 0x4
val isReg: word16 -> int32 =
   (fn x_674: word16 =>
    Posix_FileSys_ST_isReg (x_674))
val fstat: int32 -> int32 =
   (fn x_675: int32 =>
    Posix_FileSys_Stat_fstat (x_675))
val getATime: unit -> int64 =
   (fn x_676: unit =>
    case x_676 of
      () => Posix_FileSys_Stat_getATime ())
val getCTime: unit -> int64 =
   (fn x_677: unit =>
    case x_677 of
      () => Posix_FileSys_Stat_getCTime ())
val getDev: unit -> int32 =
   (fn x_678: unit =>
    case x_678 of
      () => Posix_FileSys_Stat_getDev ())
val getGId: unit -> word32 =
   (fn x_679: unit =>
    case x_679 of
      () => Posix_FileSys_Stat_getGId ())
val getINo: unit -> word64 =
   (fn x_680: unit =>
    case x_680 of
      () => Posix_FileSys_Stat_getINo ())
val getMode: unit -> word16 =
   (fn x_681: unit =>
    case x_681 of
      () => Posix_FileSys_Stat_getMode ())
val getMTime: unit -> int64 =
   (fn x_682: unit =>
    case x_682 of
      () => Posix_FileSys_Stat_getMTime ())
val getNLink: unit -> word16 =
   (fn x_683: unit =>
    case x_683 of
      () => Posix_FileSys_Stat_getNLink ())
val getSize: unit -> int64 =
   (fn x_684: unit =>
    case x_684 of
      () => Posix_FileSys_Stat_getSize ())
val getUId: unit -> word32 =
   (fn x_685: unit =>
    case x_685 of
      () => Posix_FileSys_Stat_getUId ())
val close: int32 -> int32 = (fn x_686: int32 => Posix_IO_close (x_686))
val F_SETFL: int32 = 0x4
val fcntl3: int32 * int32 * int32 -> int32 =
   (fn x_687: int32 * int32 * int32 =>
    case x_687 of
      (x_690: int32, x_689: int32, x_688: int32) =>
      Posix_IO_fcntl3 (x_690, x_689, x_688))
val lseek: int32 * int64 * int32 -> int64 =
   (fn x_691: int32 * int64 * int32 =>
    case x_691 of
      (x_694: int32, x_693: int64, x_692: int32) =>
      Posix_IO_lseek (x_694, x_693, x_692))
val readChar8: int32 * char8 array * int32 * word64 -> int64 =
   (fn x_695: int32 * char8 array * int32 * word64 =>
    case x_695 of
      (x_699: int32, x_698: char8 array, x_697: int32, x_696: word64) =>
      Posix_IO_readChar8 (x_699, x_698, x_697, x_696))
val SEEK_CUR: int32 = 0x1
val SEEK_END: int32 = 0x2
val SEEK_SET: int32 = 0x0
val settext: int32 -> unit = (fn x_700: int32 => Posix_IO_settext (x_700))
val writeChar8Arr: int32 * char8 array * int32 * word64 -> int64 =
   (fn x_701: int32 * char8 array * int32 * word64 =>
    case x_701 of
      (x_705: int32, x_704: char8 array, x_703: int32, x_702: word64) =>
      Posix_IO_writeChar8Arr (x_705, x_704, x_703, x_702))
val writeChar8Vec: int32 * string * int32 * word64 -> int64 =
   (fn x_706: int32 * string * int32 * word64 =>
    case x_706 of
      (x_710: int32, x_709: string, x_708: int32, x_707: word64) =>
      Posix_IO_writeChar8Vec (x_710, x_709, x_708, x_707))
val isatty: int32 -> int32 = (fn x_711: int32 => Posix_ProcEnv_isatty (x_711))
val abs: real32 -> real32 = (fn x_712: real32 => Real32_abs (x_712))
val add: real32 * real32 -> real32 =
   (fn x_713: real32 * real32 =>
    case x_713 of
      (x_715: real32, x_714: real32) => Real32_add (x_715, x_714))
val class: real32 -> int32 = (fn x_716: real32 => Real32_class (x_716))
val div: real32 * real32 -> real32 =
   (fn x_717: real32 * real32 =>
    case x_717 of
      (x_719: real32, x_718: real32) => Real32_div (x_719, x_718))
val equal: real32 * real32 -> bool =
   (fn x_720: real32 * real32 =>
    case x_720 of
      (x_722: real32, x_721: real32) => Real32_equal (x_722, x_721))
val frexp: real32 * int32 ref -> real32 =
   (fn x_723: real32 * int32 ref =>
    case x_723 of
      (x_725: real32, x_724: int32 ref) => Real32_frexp (x_725, x_724))
val gdtoa: real32 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_726: real32 * int32 * int32 * int32 * int32 ref =>
    case x_726 of
      (x_731: real32, x_730: int32, x_729: int32, x_728: int32, x_727: int32 ref) =>
      Real32_gdtoa (x_731, x_730, x_729, x_728, x_727))
val ldexp: real32 * int32 -> real32 =
   (fn x_732: real32 * int32 =>
    case x_732 of
      (x_734: real32, x_733: int32) => Real32_ldexp (x_734, x_733))
val le: real32 * real32 -> bool =
   (fn x_735: real32 * real32 =>
    case x_735 of
      (x_737: real32, x_736: real32) => Real32_le (x_737, x_736))
val lt: real32 * real32 -> bool =
   (fn x_738: real32 * real32 =>
    case x_738 of
      (x_740: real32, x_739: real32) => Real32_lt (x_740, x_739))
val acos: real32 -> real32 = (fn x_741: real32 => Real32_Math_acos (x_741))
val asin: real32 -> real32 = (fn x_742: real32 => Real32_Math_asin (x_742))
val atan: real32 -> real32 = (fn x_743: real32 => Real32_Math_atan (x_743))
val atan2: real32 * real32 -> real32 =
   (fn x_744: real32 * real32 =>
    case x_744 of
      (x_746: real32, x_745: real32) => Real32_Math_atan2 (x_746, x_745))
val cos: real32 -> real32 = (fn x_747: real32 => Real32_Math_cos (x_747))
val cosh: real32 -> real32 = (fn x_748: real32 => Real32_Math_cosh (x_748))
val (eGet: unit -> real32, eSet: real32 -> unit) =
   ((fn x_750: unit =>
     CPointer_getReal32 (Real32_Math_e (), 0x0)),
    (fn x_749: real32 =>
     CPointer_setReal32 (Real32_Math_e (), 0x0, x_749)))
val exp: real32 -> real32 = (fn x_751: real32 => Real32_Math_exp (x_751))
val ln: real32 -> real32 = (fn x_752: real32 => Real32_Math_ln (x_752))
val log10: real32 -> real32 = (fn x_753: real32 => Real32_Math_log10 (x_753))
val (piGet: unit -> real32, piSet: real32 -> unit) =
   ((fn x_755: unit =>
     CPointer_getReal32 (Real32_Math_pi (), 0x0)),
    (fn x_754: real32 =>
     CPointer_setReal32 (Real32_Math_pi (), 0x0, x_754)))
val pow: real32 * real32 -> real32 =
   (fn x_756: real32 * real32 =>
    case x_756 of
      (x_758: real32, x_757: real32) => Real32_Math_pow (x_758, x_757))
val sin: real32 -> real32 = (fn x_759: real32 => Real32_Math_sin (x_759))
val sinh: real32 -> real32 = (fn x_760: real32 => Real32_Math_sinh (x_760))
val sqrt: real32 -> real32 = (fn x_761: real32 => Real32_Math_sqrt (x_761))
val tan: real32 -> real32 = (fn x_762: real32 => Real32_Math_tan (x_762))
val tanh: real32 -> real32 = (fn x_763: real32 => Real32_Math_tanh (x_763))
val (maxFiniteGet: unit -> real32, maxFiniteSet: real32 -> unit) =
   ((fn x_765: unit =>
     CPointer_getReal32 (Real32_maxFinite (), 0x0)),
    (fn x_764: real32 =>
     CPointer_setReal32 (Real32_maxFinite (), 0x0, x_764)))
val (minNormalPosGet: unit -> real32, minNormalPosSet: real32 -> unit) =
   ((fn x_767: unit =>
     CPointer_getReal32 (Real32_minNormalPos (), 0x0)),
    (fn x_766: real32 =>
     CPointer_setReal32 (Real32_minNormalPos (), 0x0, x_766)))
val (minPosGet: unit -> real32, minPosSet: real32 -> unit) =
   ((fn x_769: unit =>
     CPointer_getReal32 (Real32_minPos (), 0x0)),
    (fn x_768: real32 =>
     CPointer_setReal32 (Real32_minPos (), 0x0, x_768)))
val modf: real32 * real32 ref -> real32 =
   (fn x_770: real32 * real32 ref =>
    case x_770 of
      (x_772: real32, x_771: real32 ref) => Real32_modf (x_772, x_771))
val mul: real32 * real32 -> real32 =
   (fn x_773: real32 * real32 =>
    case x_773 of
      (x_775: real32, x_774: real32) => Real32_mul (x_775, x_774))
val muladd: real32 * real32 * real32 -> real32 =
   (fn x_776: real32 * real32 * real32 =>
    case x_776 of
      (x_779: real32, x_778: real32, x_777: real32) =>
      Real32_muladd (x_779, x_778, x_777))
val mulsub: real32 * real32 * real32 -> real32 =
   (fn x_780: real32 * real32 * real32 =>
    case x_780 of
      (x_783: real32, x_782: real32, x_781: real32) =>
      Real32_mulsub (x_783, x_782, x_781))
val neg: real32 -> real32 = (fn x_784: real32 => Real32_neg (x_784))
val round: real32 -> real32 = (fn x_785: real32 => Real32_round (x_785))
val signBit: real32 -> int32 = (fn x_786: real32 => Real32_signBit (x_786))
val strto: string * int32 -> real32 =
   (fn x_787: string * int32 =>
    case x_787 of
      (x_789: string, x_788: int32) => Real32_strto (x_789, x_788))
val sub: real32 * real32 -> real32 =
   (fn x_790: real32 * real32 =>
    case x_790 of
      (x_792: real32, x_791: real32) => Real32_sub (x_792, x_791))
val abs: real64 -> real64 = (fn x_793: real64 => Real64_abs (x_793))
val add: real64 * real64 -> real64 =
   (fn x_794: real64 * real64 =>
    case x_794 of
      (x_796: real64, x_795: real64) => Real64_add (x_796, x_795))
val class: real64 -> int32 = (fn x_797: real64 => Real64_class (x_797))
val div: real64 * real64 -> real64 =
   (fn x_798: real64 * real64 =>
    case x_798 of
      (x_800: real64, x_799: real64) => Real64_div (x_800, x_799))
val equal: real64 * real64 -> bool =
   (fn x_801: real64 * real64 =>
    case x_801 of
      (x_803: real64, x_802: real64) => Real64_equal (x_803, x_802))
val frexp: real64 * int32 ref -> real64 =
   (fn x_804: real64 * int32 ref =>
    case x_804 of
      (x_806: real64, x_805: int32 ref) => Real64_frexp (x_806, x_805))
val gdtoa: real64 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_807: real64 * int32 * int32 * int32 * int32 ref =>
    case x_807 of
      (x_812: real64, x_811: int32, x_810: int32, x_809: int32, x_808: int32 ref) =>
      Real64_gdtoa (x_812, x_811, x_810, x_809, x_808))
val ldexp: real64 * int32 -> real64 =
   (fn x_813: real64 * int32 =>
    case x_813 of
      (x_815: real64, x_814: int32) => Real64_ldexp (x_815, x_814))
val le: real64 * real64 -> bool =
   (fn x_816: real64 * real64 =>
    case x_816 of
      (x_818: real64, x_817: real64) => Real64_le (x_818, x_817))
val lt: real64 * real64 -> bool =
   (fn x_819: real64 * real64 =>
    case x_819 of
      (x_821: real64, x_820: real64) => Real64_lt (x_821, x_820))
val acos: real64 -> real64 = (fn x_822: real64 => Real64_Math_acos (x_822))
val asin: real64 -> real64 = (fn x_823: real64 => Real64_Math_asin (x_823))
val atan: real64 -> real64 = (fn x_824: real64 => Real64_Math_atan (x_824))
val atan2: real64 * real64 -> real64 =
   (fn x_825: real64 * real64 =>
    case x_825 of
      (x_827: real64, x_826: real64) => Real64_Math_atan2 (x_827, x_826))
val cos: real64 -> real64 = (fn x_828: real64 => Real64_Math_cos (x_828))
val cosh: real64 -> real64 = (fn x_829: real64 => Real64_Math_cosh (x_829))
val (eGet: unit -> real64, eSet: real64 -> unit) =
   ((fn x_831: unit =>
     CPointer_getReal64 (Real64_Math_e (), 0x0)),
    (fn x_830: real64 =>
     CPointer_setReal64 (Real64_Math_e (), 0x0, x_830)))
val exp: real64 -> real64 = (fn x_832: real64 => Real64_Math_exp (x_832))
val ln: real64 -> real64 = (fn x_833: real64 => Real64_Math_ln (x_833))
val log10: real64 -> real64 = (fn x_834: real64 => Real64_Math_log10 (x_834))
val (piGet: unit -> real64, piSet: real64 -> unit) =
   ((fn x_836: unit =>
     CPointer_getReal64 (Real64_Math_pi (), 0x0)),
    (fn x_835: real64 =>
     CPointer_setReal64 (Real64_Math_pi (), 0x0, x_835)))
val pow: real64 * real64 -> real64 =
   (fn x_837: real64 * real64 =>
    case x_837 of
      (x_839: real64, x_838: real64) => Real64_Math_pow (x_839, x_838))
val sin: real64 -> real64 = (fn x_840: real64 => Real64_Math_sin (x_840))
val sinh: real64 -> real64 = (fn x_841: real64 => Real64_Math_sinh (x_841))
val sqrt: real64 -> real64 = (fn x_842: real64 => Real64_Math_sqrt (x_842))
val tan: real64 -> real64 = (fn x_843: real64 => Real64_Math_tan (x_843))
val tanh: real64 -> real64 = (fn x_844: real64 => Real64_Math_tanh (x_844))
val (maxFiniteGet: unit -> real64, maxFiniteSet: real64 -> unit) =
   ((fn x_846: unit =>
     CPointer_getReal64 (Real64_maxFinite (), 0x0)),
    (fn x_845: real64 =>
     CPointer_setReal64 (Real64_maxFinite (), 0x0, x_845)))
val (minNormalPosGet: unit -> real64, minNormalPosSet: real64 -> unit) =
   ((fn x_848: unit =>
     CPointer_getReal64 (Real64_minNormalPos (), 0x0)),
    (fn x_847: real64 =>
     CPointer_setReal64 (Real64_minNormalPos (), 0x0, x_847)))
val (minPosGet: unit -> real64, minPosSet: real64 -> unit) =
   ((fn x_850: unit =>
     CPointer_getReal64 (Real64_minPos (), 0x0)),
    (fn x_849: real64 =>
     CPointer_setReal64 (Real64_minPos (), 0x0, x_849)))
val modf: real64 * real64 ref -> real64 =
   (fn x_851: real64 * real64 ref =>
    case x_851 of
      (x_853: real64, x_852: real64 ref) => Real64_modf (x_853, x_852))
val mul: real64 * real64 -> real64 =
   (fn x_854: real64 * real64 =>
    case x_854 of
      (x_856: real64, x_855: real64) => Real64_mul (x_856, x_855))
val muladd: real64 * real64 * real64 -> real64 =
   (fn x_857: real64 * real64 * real64 =>
    case x_857 of
      (x_860: real64, x_859: real64, x_858: real64) =>
      Real64_muladd (x_860, x_859, x_858))
val mulsub: real64 * real64 * real64 -> real64 =
   (fn x_861: real64 * real64 * real64 =>
    case x_861 of
      (x_864: real64, x_863: real64, x_862: real64) =>
      Real64_mulsub (x_864, x_863, x_862))
val neg: real64 -> real64 = (fn x_865: real64 => Real64_neg (x_865))
val round: real64 -> real64 = (fn x_866: real64 => Real64_round (x_866))
val signBit: real64 -> int32 = (fn x_867: real64 => Real64_signBit (x_867))
val strto: string * int32 -> real64 =
   (fn x_868: string * int32 =>
    case x_868 of
      (x_870: string, x_869: int32) => Real64_strto (x_870, x_869))
val sub: real64 * real64 -> real64 =
   (fn x_871: real64 * real64 =>
    case x_871 of
      (x_873: real64, x_872: real64) => Real64_sub (x_873, x_872))
val print: string -> unit = (fn x_874: string => Stdio_print (x_874))
val bug: string -> unit = bug
val _ =
   (setHandler (fn x_875: exn =>
		case x_875 of
		  exn: exn =>
		  (print "unhandled exception: ")
		  ;case exn of
		     Fail8 msg: string => (print "Fail ") ;(print msg)
		   | _ => (print (name exn))
		  ;(print "
")
		  ;(bug "unhandled exception in Basis Library")))
val _ =
   (setSuffix (fn x_876: unit =>
	       case x_876 of
		 () => (halt 0x0) ;(bug "missing suffix in Basis Library")))
val rec 'a
   check: 'a * 'a -> unit = 
      (fn x_877: 'a * 'a =>
       case x_877 of
	 ((_, _)) => ())
val () = (check (real32 -> real32) (acos, acos))
val () = (check (real32 -> real32) (asin, asin))
val () = (check (real32 -> real32) (atan, atan))
val () = (check (real32 * real32 -> real32) (atan2, atan2))
val () = (check (real32 -> real32) (cos, cos))
val () = (check (real32 -> real32) (cosh, cosh))
val () =
   (check (unit -> real32) ((fn x_878: unit => case x_878 of () => e), eGet))
val () = (check (real32 -> real32) (exp, exp))
val () = (check (real32 -> real32) (ln, ln))
val () = (check (real32 -> real32) (log10, log10))
val () =
   (check (unit -> real32) ((fn x_879: unit => case x_879 of () => pi), piGet))
val () = (check (real32 * real32 -> real32) (pow, pow))
val () = (check (real32 -> real32) (sin, sin))
val () = (check (real32 -> real32) (sinh, sinh))
val () = (check (real32 -> real32) (sqrt, sqrt))
val () = (check (real32 -> real32) (tan, tan))
val () = (check (real32 -> real32) (tanh, tanh))
val () = (check (real32 -> real32) (abs, abs))
val () = (check (real32 * real32 -> real32) (+, add))
val () = (check (real32 -> int32) (class, class))
val () = (check (real32 * real32 -> real32) (/, div))
val () = (check (real32 * real32 -> bool) (==, equal))
val () = (check (real32 * int32 ref -> real32) (frexp, frexp))
val () =
   (check (real32 * int32 * int32 * int32 * int32 ref -> word64) (gdtoa, gdtoa))
val () = (check (real32 * int32 -> real32) (ldexp, ldexp))
val () = (check (real32 * real32 -> bool) (<=, le))
val () = (check (real32 * real32 -> bool) (<, lt))
val () =
   (check (unit -> real32) ((fn x_880: unit =>
			     case x_880 of
			       () => maxFinite),
			    maxFiniteGet))
val () =
   (check (unit -> real32) ((fn x_881: unit =>
			     case x_881 of
			       () => minNormalPos),
			    minNormalPosGet))
val () =
   (check (unit -> real32) ((fn x_882: unit =>
			     case x_882 of
			       () => minPos),
			    minPosGet))
val () = (check (real32 * real32 ref -> real32) (modf, modf))
val () = (check (real32 * real32 -> real32) (*, mul))
val () = (check (real32 * real32 * real32 -> real32) (*+, muladd))
val () = (check (real32 * real32 * real32 -> real32) (*-, mulsub))
val () = (check (real32 -> real32) (~, neg))
val () = (check (real32 -> real32) (round, round))
val () = (check (real32 -> int32) (signBit, signBit))
val () = (check (string * int32 -> real32) (strto, strto))
val () = (check (real32 * real32 -> real32) (-, sub))
val () = (check (real64 -> real64) (acos, acos))
val () = (check (real64 -> real64) (asin, asin))
val () = (check (real64 -> real64) (atan, atan))
val () = (check (real64 * real64 -> real64) (atan2, atan2))
val () = (check (real64 -> real64) (cos, cos))
val () = (check (real64 -> real64) (cosh, cosh))
val () =
   (check (unit -> real64) ((fn x_883: unit => case x_883 of () => e), eGet))
val () = (check (real64 -> real64) (exp, exp))
val () = (check (real64 -> real64) (ln, ln))
val () = (check (real64 -> real64) (log10, log10))
val () =
   (check (unit -> real64) ((fn x_884: unit => case x_884 of () => pi), piGet))
val () = (check (real64 * real64 -> real64) (pow, pow))
val () = (check (real64 -> real64) (sin, sin))
val () = (check (real64 -> real64) (sinh, sinh))
val () = (check (real64 -> real64) (sqrt, sqrt))
val () = (check (real64 -> real64) (tan, tan))
val () = (check (real64 -> real64) (tanh, tanh))
val () = (check (real64 -> real64) (abs, abs))
val () = (check (real64 * real64 -> real64) (+, add))
val () = (check (real64 -> int32) (class, class))
val () = (check (real64 * real64 -> real64) (/, div))
val () = (check (real64 * real64 -> bool) (==, equal))
val () = (check (real64 * int32 ref -> real64) (frexp, frexp))
val () =
   (check (real64 * int32 * int32 * int32 * int32 ref -> word64) (gdtoa, gdtoa))
val () = (check (real64 * int32 -> real64) (ldexp, ldexp))
val () = (check (real64 * real64 -> bool) (<=, le))
val () = (check (real64 * real64 -> bool) (<, lt))
val () =
   (check (unit -> real64) ((fn x_885: unit =>
			     case x_885 of
			       () => maxFinite),
			    maxFiniteGet))
val () =
   (check (unit -> real64) ((fn x_886: unit =>
			     case x_886 of
			       () => minNormalPos),
			    minNormalPosGet))
val () =
   (check (unit -> real64) ((fn x_887: unit =>
			     case x_887 of
			       () => minPos),
			    minPosGet))
val () = (check (real64 * real64 ref -> real64) (modf, modf))
val () = (check (real64 * real64 -> real64) (*, mul))
val () = (check (real64 * real64 * real64 -> real64) (*+, muladd))
val () = (check (real64 * real64 * real64 -> real64) (*-, mulsub))
val () = (check (real64 -> real64) (~, neg))
val () = (check (real64 -> real64) (round, round))
val () = (check (real64 -> int32) (signBit, signBit))
val () = (check (string * int32 -> real64) (strto, strto))
val () = (check (real64 * real64 -> real64) (-, sub))
val rec ('a, 'b)
   try: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) -> 'b = 
      (fn x_888: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) =>
       case x_888 of
	 ((f: unit -> 'a, k: 'a -> 'b, h: exn -> 'b)) =>
	 let datatype DynamicWind.try.t = A of 'a
					  | E of exn
	 in
	    case (A (f ()))
		 handle x_889 => case x_889 of
				   e: exn => (E e) of
	      A a: 'a => (k a) | E e: exn => (h e)
	 end)
val rec 'a_174
   wind: (unit -> 'a_174) * (unit -> unit) -> 'a_174 = 
      (fn x_890: (unit -> 'a_174) * (unit -> unit) =>
       case x_890 of
	 ((thunk: unit -> 'a_174, cleanup: unit -> unit)) =>
	 (try ('a_174, 'a_174) (thunk,
				(fn x_892: 'a_174 =>
				 case x_892 of
				   a: 'a_174 => (cleanup ()) ;a),
				(fn x_891: exn =>
				 case x_891 of
				   e: exn => (cleanup ()) ;raise e))))
val 'a wind_0: (unit -> 'a) * (unit -> unit) -> 'a = wind ('a)
val castFromInt8ToInt8: int8 -> int8 = sextdFromInt8ToInt8
val castFromInt8ToInt16: int8 -> int16 = sextdFromInt8ToInt16
val castFromInt8ToInt32: int8 -> int32 = sextdFromInt8ToInt32
val castFromInt8ToInt64: int8 -> int64 = sextdFromInt8ToInt64
val castFromInt8ToWord8: int8 -> word8 = sextdFromInt8ToWord8
val castFromInt8ToWord16: int8 -> word16 = sextdFromInt8ToWord16
val castFromInt8ToWord32: int8 -> word32 = sextdFromInt8ToWord32
val castFromInt8ToWord64: int8 -> word64 = sextdFromInt8ToWord64
val castFromInt16ToInt8: int16 -> int8 = sextdFromInt16ToInt8
val castFromInt16ToInt16: int16 -> int16 = sextdFromInt16ToInt16
val castFromInt16ToInt32: int16 -> int32 = sextdFromInt16ToInt32
val castFromInt16ToInt64: int16 -> int64 = sextdFromInt16ToInt64
val castFromInt16ToWord8: int16 -> word8 = sextdFromInt16ToWord8
val castFromInt16ToWord16: int16 -> word16 = sextdFromInt16ToWord16
val castFromInt16ToWord32: int16 -> word32 = sextdFromInt16ToWord32
val castFromInt16ToWord64: int16 -> word64 = sextdFromInt16ToWord64
val castFromInt32ToInt8: int32 -> int8 = sextdFromInt32ToInt8
val castFromInt32ToInt16: int32 -> int16 = sextdFromInt32ToInt16
val castFromInt32ToInt32: int32 -> int32 = sextdFromInt32ToInt32
val castFromInt32ToInt64: int32 -> int64 = sextdFromInt32ToInt64
val castFromInt32ToWord8: int32 -> word8 = sextdFromInt32ToWord8
val castFromInt32ToWord16: int32 -> word16 = sextdFromInt32ToWord16
val castFromInt32ToWord32: int32 -> word32 = sextdFromInt32ToWord32
val castFromInt32ToWord64: int32 -> word64 = sextdFromInt32ToWord64
val castFromInt64ToInt8: int64 -> int8 = sextdFromInt64ToInt8
val castFromInt64ToInt16: int64 -> int16 = sextdFromInt64ToInt16
val castFromInt64ToInt32: int64 -> int32 = sextdFromInt64ToInt32
val castFromInt64ToInt64: int64 -> int64 = sextdFromInt64ToInt64
val castFromInt64ToWord8: int64 -> word8 = sextdFromInt64ToWord8
val castFromInt64ToWord16: int64 -> word16 = sextdFromInt64ToWord16
val castFromInt64ToWord32: int64 -> word32 = sextdFromInt64ToWord32
val castFromInt64ToWord64: int64 -> word64 = sextdFromInt64ToWord64
val castFromWord8ToInt8: word8 -> int8 = zextdFromWord8ToInt8
val castFromWord8ToInt16: word8 -> int16 = zextdFromWord8ToInt16
val castFromWord8ToInt32: word8 -> int32 = zextdFromWord8ToInt32
val castFromWord8ToInt64: word8 -> int64 = zextdFromWord8ToInt64
val castFromWord8ToWord8: word8 -> word8 = zextdFromWord8ToWord8
val castFromWord8ToWord16: word8 -> word16 = zextdFromWord8ToWord16
val castFromWord8ToWord32: word8 -> word32 = zextdFromWord8ToWord32
val castFromWord8ToWord64: word8 -> word64 = zextdFromWord8ToWord64
val castFromWord16ToInt8: word16 -> int8 = zextdFromWord16ToInt8
val castFromWord16ToInt16: word16 -> int16 = zextdFromWord16ToInt16
val castFromWord16ToInt32: word16 -> int32 = zextdFromWord16ToInt32
val castFromWord16ToInt64: word16 -> int64 = zextdFromWord16ToInt64
val castFromWord16ToWord8: word16 -> word8 = zextdFromWord16ToWord8
val castFromWord16ToWord16: word16 -> word16 = zextdFromWord16ToWord16
val castFromWord16ToWord32: word16 -> word32 = zextdFromWord16ToWord32
val castFromWord16ToWord64: word16 -> word64 = zextdFromWord16ToWord64
val castFromWord32ToInt8: word32 -> int8 = zextdFromWord32ToInt8
val castFromWord32ToInt16: word32 -> int16 = zextdFromWord32ToInt16
val castFromWord32ToInt32: word32 -> int32 = zextdFromWord32ToInt32
val castFromWord32ToInt64: word32 -> int64 = zextdFromWord32ToInt64
val castFromWord32ToWord8: word32 -> word8 = zextdFromWord32ToWord8
val castFromWord32ToWord16: word32 -> word16 = zextdFromWord32ToWord16
val castFromWord32ToWord32: word32 -> word32 = zextdFromWord32ToWord32
val castFromWord32ToWord64: word32 -> word64 = zextdFromWord32ToWord64
val castFromWord64ToInt8: word64 -> int8 = zextdFromWord64ToInt8
val castFromWord64ToInt16: word64 -> int16 = zextdFromWord64ToInt16
val castFromWord64ToInt32: word64 -> int32 = zextdFromWord64ToInt32
val castFromWord64ToInt64: word64 -> int64 = zextdFromWord64ToInt64
val castFromWord64ToWord8: word64 -> word8 = zextdFromWord64ToWord8
val castFromWord64ToWord16: word64 -> word16 = zextdFromWord64ToWord16
val castFromWord64ToWord32: word64 -> word32 = zextdFromWord64ToWord32
val castFromWord64ToWord64: word64 -> word64 = zextdFromWord64ToWord64
val rec (''s, ''l)
   make: {zextdFromLargeToSmall: ''l -> ''s, zextdFromSmallToLarge: ''s -> ''l}
	 -> ''l -> ''s = 
      (fn x_893: {zextdFromLargeToSmall: ''l -> ''s,
		  zextdFromSmallToLarge: ''s -> ''l} =>
       case x_893 of
	 ({zextdFromLargeToSmall = zextdFromLargeToSmall: ''l -> ''s,
	   zextdFromSmallToLarge = zextdFromSmallToLarge: ''s -> ''l}) =>
	 case detectOverflow of
	   true =>
	   (fn x_894: ''l =>
	    case x_894 of
	      x: ''l =>
	      let val res: ''s = (zextdFromLargeToSmall x)
	      in
		 case (= (''l) (x, (zextdFromSmallToLarge res))) of
		   true => res | false => raise Overflow
	      end)
	 | false => zextdFromLargeToSmall)
val zchckFromInt8ToInt8: int8 -> int8 = zextdFromInt8ToInt8
val zchckFromInt8ToInt16: int8 -> int16 = zextdFromInt8ToInt16
val zchckFromInt8ToInt32: int8 -> int32 = zextdFromInt8ToInt32
val zchckFromInt8ToInt64: int8 -> int64 = zextdFromInt8ToInt64
val zchckFromInt8ToWord8: int8 -> word8 = zextdFromInt8ToWord8
val zchckFromInt8ToWord16: int8 -> word16 = zextdFromInt8ToWord16
val zchckFromInt8ToWord32: int8 -> word32 = zextdFromInt8ToWord32
val zchckFromInt8ToWord64: int8 -> word64 = zextdFromInt8ToWord64
val zchckFromInt16ToInt8: int16 -> int8 =
   (make (int8, int16) {zextdFromLargeToSmall = zextdFromInt16ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt16})
val zchckFromInt16ToInt16: int16 -> int16 = zextdFromInt16ToInt16
val zchckFromInt16ToInt32: int16 -> int32 = zextdFromInt16ToInt32
val zchckFromInt16ToInt64: int16 -> int64 = zextdFromInt16ToInt64
val zchckFromInt16ToWord8: int16 -> word8 =
   (make (word8, int16) {zextdFromLargeToSmall = zextdFromInt16ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt16})
val zchckFromInt16ToWord16: int16 -> word16 = zextdFromInt16ToWord16
val zchckFromInt16ToWord32: int16 -> word32 = zextdFromInt16ToWord32
val zchckFromInt16ToWord64: int16 -> word64 = zextdFromInt16ToWord64
val zchckFromInt32ToInt8: int32 -> int8 =
   (make (int8, int32) {zextdFromLargeToSmall = zextdFromInt32ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt32})
val zchckFromInt32ToInt16: int32 -> int16 =
   (make (int16, int32) {zextdFromLargeToSmall = zextdFromInt32ToInt16,
			 zextdFromSmallToLarge = zextdFromInt16ToInt32})
val zchckFromInt32ToInt32: int32 -> int32 = zextdFromInt32ToInt32
val zchckFromInt32ToInt64: int32 -> int64 = zextdFromInt32ToInt64
val zchckFromInt32ToWord8: int32 -> word8 =
   (make (word8, int32) {zextdFromLargeToSmall = zextdFromInt32ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt32})
val zchckFromInt32ToWord16: int32 -> word16 =
   (make (word16, int32) {zextdFromLargeToSmall = zextdFromInt32ToWord16,
			  zextdFromSmallToLarge = zextdFromWord16ToInt32})
val zchckFromInt32ToWord32: int32 -> word32 = zextdFromInt32ToWord32
val zchckFromInt32ToWord64: int32 -> word64 = zextdFromInt32ToWord64
val zchckFromInt64ToInt8: int64 -> int8 =
   (make (int8, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt64})
val zchckFromInt64ToInt16: int64 -> int16 =
   (make (int16, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt16,
			 zextdFromSmallToLarge = zextdFromInt16ToInt64})
val zchckFromInt64ToInt32: int64 -> int32 =
   (make (int32, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt32,
			 zextdFromSmallToLarge = zextdFromInt32ToInt64})
val zchckFromInt64ToInt64: int64 -> int64 = zextdFromInt64ToInt64
val zchckFromInt64ToWord8: int64 -> word8 =
   (make (word8, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt64})
val zchckFromInt64ToWord16: int64 -> word16 =
   (make (word16, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord16,
			  zextdFromSmallToLarge = zextdFromWord16ToInt64})
val zchckFromInt64ToWord32: int64 -> word32 =
   (make (word32, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord32,
			  zextdFromSmallToLarge = zextdFromWord32ToInt64})
val zchckFromInt64ToWord64: int64 -> word64 = zextdFromInt64ToWord64
val zchckFromWord8ToInt8: word8 -> int8 = zextdFromWord8ToInt8
val zchckFromWord8ToInt16: word8 -> int16 = zextdFromWord8ToInt16
val zchckFromWord8ToInt32: word8 -> int32 = zextdFromWord8ToInt32
val zchckFromWord8ToInt64: word8 -> int64 = zextdFromWord8ToInt64
val zchckFromWord8ToWord8: word8 -> word8 = zextdFromWord8ToWord8
val zchckFromWord8ToWord16: word8 -> word16 = zextdFromWord8ToWord16
val zchckFromWord8ToWord32: word8 -> word32 = zextdFromWord8ToWord32
val zchckFromWord8ToWord64: word8 -> word64 = zextdFromWord8ToWord64
val zchckFromWord16ToInt8: word16 -> int8 =
   (make (int8, word16) {zextdFromLargeToSmall = zextdFromWord16ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord16})
val zchckFromWord16ToInt16: word16 -> int16 = zextdFromWord16ToInt16
val zchckFromWord16ToInt32: word16 -> int32 = zextdFromWord16ToInt32
val zchckFromWord16ToInt64: word16 -> int64 = zextdFromWord16ToInt64
val zchckFromWord16ToWord8: word16 -> word8 =
   (make (word8, word16) {zextdFromLargeToSmall = zextdFromWord16ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord16})
val zchckFromWord16ToWord16: word16 -> word16 = zextdFromWord16ToWord16
val zchckFromWord16ToWord32: word16 -> word32 = zextdFromWord16ToWord32
val zchckFromWord16ToWord64: word16 -> word64 = zextdFromWord16ToWord64
val zchckFromWord32ToInt8: word32 -> int8 =
   (make (int8, word32) {zextdFromLargeToSmall = zextdFromWord32ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord32})
val zchckFromWord32ToInt16: word32 -> int16 =
   (make (int16, word32) {zextdFromLargeToSmall = zextdFromWord32ToInt16,
			  zextdFromSmallToLarge = zextdFromInt16ToWord32})
val zchckFromWord32ToInt32: word32 -> int32 = zextdFromWord32ToInt32
val zchckFromWord32ToInt64: word32 -> int64 = zextdFromWord32ToInt64
val zchckFromWord32ToWord8: word32 -> word8 =
   (make (word8, word32) {zextdFromLargeToSmall = zextdFromWord32ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord32})
val zchckFromWord32ToWord16: word32 -> word16 =
   (make (word16, word32) {zextdFromLargeToSmall = zextdFromWord32ToWord16,
			   zextdFromSmallToLarge = zextdFromWord16ToWord32})
val zchckFromWord32ToWord32: word32 -> word32 = zextdFromWord32ToWord32
val zchckFromWord32ToWord64: word32 -> word64 = zextdFromWord32ToWord64
val zchckFromWord64ToInt8: word64 -> int8 =
   (make (int8, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord64})
val zchckFromWord64ToInt16: word64 -> int16 =
   (make (int16, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt16,
			  zextdFromSmallToLarge = zextdFromInt16ToWord64})
val zchckFromWord64ToInt32: word64 -> int32 =
   (make (int32, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt32,
			  zextdFromSmallToLarge = zextdFromInt32ToWord64})
val zchckFromWord64ToInt64: word64 -> int64 = zextdFromWord64ToInt64
val zchckFromWord64ToWord8: word64 -> word8 =
   (make (word8, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord64})
val zchckFromWord64ToWord16: word64 -> word16 =
   (make (word16, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord16,
			   zextdFromSmallToLarge = zextdFromWord16ToWord64})
val zchckFromWord64ToWord32: word64 -> word32 =
   (make (word32, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord32,
			   zextdFromSmallToLarge = zextdFromWord32ToWord64})
val zchckFromWord64ToWord64: word64 -> word64 = zextdFromWord64ToWord64
val rec (''s, ''l)
   make: {sextdFromLargeToSmall: ''l -> ''s, sextdFromSmallToLarge: ''s -> ''l}
	 -> ''l -> ''s = 
      (fn x_895: {sextdFromLargeToSmall: ''l -> ''s,
		  sextdFromSmallToLarge: ''s -> ''l} =>
       case x_895 of
	 ({sextdFromLargeToSmall = sextdFromLargeToSmall: ''l -> ''s,
	   sextdFromSmallToLarge = sextdFromSmallToLarge: ''s -> ''l}) =>
	 case detectOverflow of
	   true =>
	   (fn x_896: ''l =>
	    case x_896 of
	      x: ''l =>
	      let val res: ''s = (sextdFromLargeToSmall x)
	      in
		 case (= (''l) (x, (sextdFromSmallToLarge res))) of
		   true => res | false => raise Overflow
	      end)
	 | false => sextdFromLargeToSmall)
val schckFromInt8ToInt8: int8 -> int8 = sextdFromInt8ToInt8
val schckFromInt8ToInt16: int8 -> int16 = sextdFromInt8ToInt16
val schckFromInt8ToInt32: int8 -> int32 = sextdFromInt8ToInt32
val schckFromInt8ToInt64: int8 -> int64 = sextdFromInt8ToInt64
val schckFromInt8ToWord8: int8 -> word8 = sextdFromInt8ToWord8
val schckFromInt8ToWord16: int8 -> word16 = sextdFromInt8ToWord16
val schckFromInt8ToWord32: int8 -> word32 = sextdFromInt8ToWord32
val schckFromInt8ToWord64: int8 -> word64 = sextdFromInt8ToWord64
val schckFromInt16ToInt8: int16 -> int8 =
   (make (int8, int16) {sextdFromLargeToSmall = sextdFromInt16ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt16})
val schckFromInt16ToInt16: int16 -> int16 = sextdFromInt16ToInt16
val schckFromInt16ToInt32: int16 -> int32 = sextdFromInt16ToInt32
val schckFromInt16ToInt64: int16 -> int64 = sextdFromInt16ToInt64
val schckFromInt16ToWord8: int16 -> word8 =
   (make (word8, int16) {sextdFromLargeToSmall = sextdFromInt16ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt16})
val schckFromInt16ToWord16: int16 -> word16 = sextdFromInt16ToWord16
val schckFromInt16ToWord32: int16 -> word32 = sextdFromInt16ToWord32
val schckFromInt16ToWord64: int16 -> word64 = sextdFromInt16ToWord64
val schckFromInt32ToInt8: int32 -> int8 =
   (make (int8, int32) {sextdFromLargeToSmall = sextdFromInt32ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt32})
val schckFromInt32ToInt16: int32 -> int16 =
   (make (int16, int32) {sextdFromLargeToSmall = sextdFromInt32ToInt16,
			 sextdFromSmallToLarge = sextdFromInt16ToInt32})
val schckFromInt32ToInt32: int32 -> int32 = sextdFromInt32ToInt32
val schckFromInt32ToInt64: int32 -> int64 = sextdFromInt32ToInt64
val schckFromInt32ToWord8: int32 -> word8 =
   (make (word8, int32) {sextdFromLargeToSmall = sextdFromInt32ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt32})
val schckFromInt32ToWord16: int32 -> word16 =
   (make (word16, int32) {sextdFromLargeToSmall = sextdFromInt32ToWord16,
			  sextdFromSmallToLarge = sextdFromWord16ToInt32})
val schckFromInt32ToWord32: int32 -> word32 = sextdFromInt32ToWord32
val schckFromInt32ToWord64: int32 -> word64 = sextdFromInt32ToWord64
val schckFromInt64ToInt8: int64 -> int8 =
   (make (int8, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt64})
val schckFromInt64ToInt16: int64 -> int16 =
   (make (int16, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt16,
			 sextdFromSmallToLarge = sextdFromInt16ToInt64})
val schckFromInt64ToInt32: int64 -> int32 =
   (make (int32, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt32,
			 sextdFromSmallToLarge = sextdFromInt32ToInt64})
val schckFromInt64ToInt64: int64 -> int64 = sextdFromInt64ToInt64
val schckFromInt64ToWord8: int64 -> word8 =
   (make (word8, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt64})
val schckFromInt64ToWord16: int64 -> word16 =
   (make (word16, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord16,
			  sextdFromSmallToLarge = sextdFromWord16ToInt64})
val schckFromInt64ToWord32: int64 -> word32 =
   (make (word32, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord32,
			  sextdFromSmallToLarge = sextdFromWord32ToInt64})
val schckFromInt64ToWord64: int64 -> word64 = sextdFromInt64ToWord64
val schckFromWord8ToInt8: word8 -> int8 = sextdFromWord8ToInt8
val schckFromWord8ToInt16: word8 -> int16 = sextdFromWord8ToInt16
val schckFromWord8ToInt32: word8 -> int32 = sextdFromWord8ToInt32
val schckFromWord8ToInt64: word8 -> int64 = sextdFromWord8ToInt64
val schckFromWord8ToWord8: word8 -> word8 = sextdFromWord8ToWord8
val schckFromWord8ToWord16: word8 -> word16 = sextdFromWord8ToWord16
val schckFromWord8ToWord32: word8 -> word32 = sextdFromWord8ToWord32
val schckFromWord8ToWord64: word8 -> word64 = sextdFromWord8ToWord64
val schckFromWord16ToInt8: word16 -> int8 =
   (make (int8, word16) {sextdFromLargeToSmall = sextdFromWord16ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord16})
val schckFromWord16ToInt16: word16 -> int16 = sextdFromWord16ToInt16
val schckFromWord16ToInt32: word16 -> int32 = sextdFromWord16ToInt32
val schckFromWord16ToInt64: word16 -> int64 = sextdFromWord16ToInt64
val schckFromWord16ToWord8: word16 -> word8 =
   (make (word8, word16) {sextdFromLargeToSmall = sextdFromWord16ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord16})
val schckFromWord16ToWord16: word16 -> word16 = sextdFromWord16ToWord16
val schckFromWord16ToWord32: word16 -> word32 = sextdFromWord16ToWord32
val schckFromWord16ToWord64: word16 -> word64 = sextdFromWord16ToWord64
val schckFromWord32ToInt8: word32 -> int8 =
   (make (int8, word32) {sextdFromLargeToSmall = sextdFromWord32ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord32})
val schckFromWord32ToInt16: word32 -> int16 =
   (make (int16, word32) {sextdFromLargeToSmall = sextdFromWord32ToInt16,
			  sextdFromSmallToLarge = sextdFromInt16ToWord32})
val schckFromWord32ToInt32: word32 -> int32 = sextdFromWord32ToInt32
val schckFromWord32ToInt64: word32 -> int64 = sextdFromWord32ToInt64
val schckFromWord32ToWord8: word32 -> word8 =
   (make (word8, word32) {sextdFromLargeToSmall = sextdFromWord32ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord32})
val schckFromWord32ToWord16: word32 -> word16 =
   (make (word16, word32) {sextdFromLargeToSmall = sextdFromWord32ToWord16,
			   sextdFromSmallToLarge = sextdFromWord16ToWord32})
val schckFromWord32ToWord32: word32 -> word32 = sextdFromWord32ToWord32
val schckFromWord32ToWord64: word32 -> word64 = sextdFromWord32ToWord64
val schckFromWord64ToInt8: word64 -> int8 =
   (make (int8, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord64})
val schckFromWord64ToInt16: word64 -> int16 =
   (make (int16, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt16,
			  sextdFromSmallToLarge = sextdFromInt16ToWord64})
val schckFromWord64ToInt32: word64 -> int32 =
   (make (int32, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt32,
			  sextdFromSmallToLarge = sextdFromInt32ToWord64})
val schckFromWord64ToInt64: word64 -> int64 = sextdFromWord64ToInt64
val schckFromWord64ToWord8: word64 -> word8 =
   (make (word8, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord64})
val schckFromWord64ToWord16: word64 -> word16 =
   (make (word16, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord16,
			   sextdFromSmallToLarge = sextdFromWord16ToWord64})
val schckFromWord64ToWord32: word64 -> word32 =
   (make (word32, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord32,
			   sextdFromSmallToLarge = sextdFromWord32ToWord64})
val schckFromWord64ToWord64: word64 -> word64 = sextdFromWord64ToWord64
val zextdFromInt8: int8 -> int8 = zextdFromInt8ToInt8
val zextdFromInt16: int16 -> int8 = zextdFromInt16ToInt8
val zextdFromInt32: int32 -> int8 = zextdFromInt32ToInt8
val zextdFromInt64: int64 -> int8 = zextdFromInt64ToInt8
val zextdFromWord8: word8 -> int8 = zextdFromWord8ToInt8
val zextdFromWord16: word16 -> int8 = zextdFromWord16ToInt8
val zextdFromWord32: word32 -> int8 = zextdFromWord32ToInt8
val zextdFromWord64: word64 -> int8 = zextdFromWord64ToInt8
val zextdToInt8: int8 -> int8 = zextdFromInt8ToInt8
val zextdToInt16: int8 -> int16 = zextdFromInt8ToInt16
val zextdToInt32: int8 -> int32 = zextdFromInt8ToInt32
val zextdToInt64: int8 -> int64 = zextdFromInt8ToInt64
val zextdToWord8: int8 -> word8 = zextdFromInt8ToWord8
val zextdToWord16: int8 -> word16 = zextdFromInt8ToWord16
val zextdToWord32: int8 -> word32 = zextdFromInt8ToWord32
val zextdToWord64: int8 -> word64 = zextdFromInt8ToWord64
val sextdFromInt8: int8 -> int8 = sextdFromInt8ToInt8
val sextdFromInt16: int16 -> int8 = sextdFromInt16ToInt8
val sextdFromInt32: int32 -> int8 = sextdFromInt32ToInt8
val sextdFromInt64: int64 -> int8 = sextdFromInt64ToInt8
val sextdFromWord8: word8 -> int8 = sextdFromWord8ToInt8
val sextdFromWord16: word16 -> int8 = sextdFromWord16ToInt8
val sextdFromWord32: word32 -> int8 = sextdFromWord32ToInt8
val sextdFromWord64: word64 -> int8 = sextdFromWord64ToInt8
val sextdToInt8: int8 -> int8 = sextdFromInt8ToInt8
val sextdToInt16: int8 -> int16 = sextdFromInt8ToInt16
val sextdToInt32: int8 -> int32 = sextdFromInt8ToInt32
val sextdToInt64: int8 -> int64 = sextdFromInt8ToInt64
val sextdToWord8: int8 -> word8 = sextdFromInt8ToWord8
val sextdToWord16: int8 -> word16 = sextdFromInt8ToWord16
val sextdToWord32: int8 -> word32 = sextdFromInt8ToWord32
val sextdToWord64: int8 -> word64 = sextdFromInt8ToWord64
val castFromInt8: int8 -> int8 = castFromInt8ToInt8
val castFromInt16: int16 -> int8 = castFromInt16ToInt8
val castFromInt32: int32 -> int8 = castFromInt32ToInt8
val castFromInt64: int64 -> int8 = castFromInt64ToInt8
val castFromWord8: word8 -> int8 = castFromWord8ToInt8
val castFromWord16: word16 -> int8 = castFromWord16ToInt8
val castFromWord32: word32 -> int8 = castFromWord32ToInt8
val castFromWord64: word64 -> int8 = castFromWord64ToInt8
val castToInt8: int8 -> int8 = castFromInt8ToInt8
val castToInt16: int8 -> int16 = castFromInt8ToInt16
val castToInt32: int8 -> int32 = castFromInt8ToInt32
val castToInt64: int8 -> int64 = castFromInt8ToInt64
val castToWord8: int8 -> word8 = castFromInt8ToWord8
val castToWord16: int8 -> word16 = castFromInt8ToWord16
val castToWord32: int8 -> word32 = castFromInt8ToWord32
val castToWord64: int8 -> word64 = castFromInt8ToWord64
val zchckFromInt8: int8 -> int8 = zchckFromInt8ToInt8
val zchckFromInt16: int16 -> int8 = zchckFromInt16ToInt8
val zchckFromInt32: int32 -> int8 = zchckFromInt32ToInt8
val zchckFromInt64: int64 -> int8 = zchckFromInt64ToInt8
val zchckFromWord8: word8 -> int8 = zchckFromWord8ToInt8
val zchckFromWord16: word16 -> int8 = zchckFromWord16ToInt8
val zchckFromWord32: word32 -> int8 = zchckFromWord32ToInt8
val zchckFromWord64: word64 -> int8 = zchckFromWord64ToInt8
val zchckToInt8: int8 -> int8 = zchckFromInt8ToInt8
val zchckToInt16: int8 -> int16 = zchckFromInt8ToInt16
val zchckToInt32: int8 -> int32 = zchckFromInt8ToInt32
val zchckToInt64: int8 -> int64 = zchckFromInt8ToInt64
val zchckToWord8: int8 -> word8 = zchckFromInt8ToWord8
val zchckToWord16: int8 -> word16 = zchckFromInt8ToWord16
val zchckToWord32: int8 -> word32 = zchckFromInt8ToWord32
val zchckToWord64: int8 -> word64 = zchckFromInt8ToWord64
val schckFromInt8: int8 -> int8 = schckFromInt8ToInt8
val schckFromInt16: int16 -> int8 = schckFromInt16ToInt8
val schckFromInt32: int32 -> int8 = schckFromInt32ToInt8
val schckFromInt64: int64 -> int8 = schckFromInt64ToInt8
val schckFromWord8: word8 -> int8 = schckFromWord8ToInt8
val schckFromWord16: word16 -> int8 = schckFromWord16ToInt8
val schckFromWord32: word32 -> int8 = schckFromWord32ToInt8
val schckFromWord64: word64 -> int8 = schckFromWord64ToInt8
val schckToInt8: int8 -> int8 = schckFromInt8ToInt8
val schckToInt16: int8 -> int16 = schckFromInt8ToInt16
val schckToInt32: int8 -> int32 = schckFromInt8ToInt32
val schckToInt64: int8 -> int64 = schckFromInt8ToInt64
val schckToWord8: int8 -> word8 = schckFromInt8ToWord8
val schckToWord16: int8 -> word16 = schckFromInt8ToWord16
val schckToWord32: int8 -> word32 = schckFromInt8ToWord32
val schckToWord64: int8 -> word64 = schckFromInt8ToWord64
val zextdFromInt8: int8 -> int16 = zextdFromInt8ToInt16
val zextdFromInt16: int16 -> int16 = zextdFromInt16ToInt16
val zextdFromInt32: int32 -> int16 = zextdFromInt32ToInt16
val zextdFromInt64: int64 -> int16 = zextdFromInt64ToInt16
val zextdFromWord8: word8 -> int16 = zextdFromWord8ToInt16
val zextdFromWord16: word16 -> int16 = zextdFromWord16ToInt16
val zextdFromWord32: word32 -> int16 = zextdFromWord32ToInt16
val zextdFromWord64: word64 -> int16 = zextdFromWord64ToInt16
val zextdToInt8: int16 -> int8 = zextdFromInt16ToInt8
val zextdToInt16: int16 -> int16 = zextdFromInt16ToInt16
val zextdToInt32: int16 -> int32 = zextdFromInt16ToInt32
val zextdToInt64: int16 -> int64 = zextdFromInt16ToInt64
val zextdToWord8: int16 -> word8 = zextdFromInt16ToWord8
val zextdToWord16: int16 -> word16 = zextdFromInt16ToWord16
val zextdToWord32: int16 -> word32 = zextdFromInt16ToWord32
val zextdToWord64: int16 -> word64 = zextdFromInt16ToWord64
val sextdFromInt8: int8 -> int16 = sextdFromInt8ToInt16
val sextdFromInt16: int16 -> int16 = sextdFromInt16ToInt16
val sextdFromInt32: int32 -> int16 = sextdFromInt32ToInt16
val sextdFromInt64: int64 -> int16 = sextdFromInt64ToInt16
val sextdFromWord8: word8 -> int16 = sextdFromWord8ToInt16
val sextdFromWord16: word16 -> int16 = sextdFromWord16ToInt16
val sextdFromWord32: word32 -> int16 = sextdFromWord32ToInt16
val sextdFromWord64: word64 -> int16 = sextdFromWord64ToInt16
val sextdToInt8: int16 -> int8 = sextdFromInt16ToInt8
val sextdToInt16: int16 -> int16 = sextdFromInt16ToInt16
val sextdToInt32: int16 -> int32 = sextdFromInt16ToInt32
val sextdToInt64: int16 -> int64 = sextdFromInt16ToInt64
val sextdToWord8: int16 -> word8 = sextdFromInt16ToWord8
val sextdToWord16: int16 -> word16 = sextdFromInt16ToWord16
val sextdToWord32: int16 -> word32 = sextdFromInt16ToWord32
val sextdToWord64: int16 -> word64 = sextdFromInt16ToWord64
val castFromInt8: int8 -> int16 = castFromInt8ToInt16
val castFromInt16: int16 -> int16 = castFromInt16ToInt16
val castFromInt32: int32 -> int16 = castFromInt32ToInt16
val castFromInt64: int64 -> int16 = castFromInt64ToInt16
val castFromWord8: word8 -> int16 = castFromWord8ToInt16
val castFromWord16: word16 -> int16 = castFromWord16ToInt16
val castFromWord32: word32 -> int16 = castFromWord32ToInt16
val castFromWord64: word64 -> int16 = castFromWord64ToInt16
val castToInt8: int16 -> int8 = castFromInt16ToInt8
val castToInt16: int16 -> int16 = castFromInt16ToInt16
val castToInt32: int16 -> int32 = castFromInt16ToInt32
val castToInt64: int16 -> int64 = castFromInt16ToInt64
val castToWord8: int16 -> word8 = castFromInt16ToWord8
val castToWord16: int16 -> word16 = castFromInt16ToWord16
val castToWord32: int16 -> word32 = castFromInt16ToWord32
val castToWord64: int16 -> word64 = castFromInt16ToWord64
val zchckFromInt8: int8 -> int16 = zchckFromInt8ToInt16
val zchckFromInt16: int16 -> int16 = zchckFromInt16ToInt16
val zchckFromInt32: int32 -> int16 = zchckFromInt32ToInt16
val zchckFromInt64: int64 -> int16 = zchckFromInt64ToInt16
val zchckFromWord8: word8 -> int16 = zchckFromWord8ToInt16
val zchckFromWord16: word16 -> int16 = zchckFromWord16ToInt16
val zchckFromWord32: word32 -> int16 = zchckFromWord32ToInt16
val zchckFromWord64: word64 -> int16 = zchckFromWord64ToInt16
val zchckToInt8: int16 -> int8 = zchckFromInt16ToInt8
val zchckToInt16: int16 -> int16 = zchckFromInt16ToInt16
val zchckToInt32: int16 -> int32 = zchckFromInt16ToInt32
val zchckToInt64: int16 -> int64 = zchckFromInt16ToInt64
val zchckToWord8: int16 -> word8 = zchckFromInt16ToWord8
val zchckToWord16: int16 -> word16 = zchckFromInt16ToWord16
val zchckToWord32: int16 -> word32 = zchckFromInt16ToWord32
val zchckToWord64: int16 -> word64 = zchckFromInt16ToWord64
val schckFromInt8: int8 -> int16 = schckFromInt8ToInt16
val schckFromInt16: int16 -> int16 = schckFromInt16ToInt16
val schckFromInt32: int32 -> int16 = schckFromInt32ToInt16
val schckFromInt64: int64 -> int16 = schckFromInt64ToInt16
val schckFromWord8: word8 -> int16 = schckFromWord8ToInt16
val schckFromWord16: word16 -> int16 = schckFromWord16ToInt16
val schckFromWord32: word32 -> int16 = schckFromWord32ToInt16
val schckFromWord64: word64 -> int16 = schckFromWord64ToInt16
val schckToInt8: int16 -> int8 = schckFromInt16ToInt8
val schckToInt16: int16 -> int16 = schckFromInt16ToInt16
val schckToInt32: int16 -> int32 = schckFromInt16ToInt32
val schckToInt64: int16 -> int64 = schckFromInt16ToInt64
val schckToWord8: int16 -> word8 = schckFromInt16ToWord8
val schckToWord16: int16 -> word16 = schckFromInt16ToWord16
val schckToWord32: int16 -> word32 = schckFromInt16ToWord32
val schckToWord64: int16 -> word64 = schckFromInt16ToWord64
val zextdFromInt8: int8 -> int32 = zextdFromInt8ToInt32
val zextdFromInt16: int16 -> int32 = zextdFromInt16ToInt32
val zextdFromInt32: int32 -> int32 = zextdFromInt32ToInt32
val zextdFromInt64: int64 -> int32 = zextdFromInt64ToInt32
val zextdFromWord8: word8 -> int32 = zextdFromWord8ToInt32
val zextdFromWord16: word16 -> int32 = zextdFromWord16ToInt32
val zextdFromWord32: word32 -> int32 = zextdFromWord32ToInt32
val zextdFromWord64: word64 -> int32 = zextdFromWord64ToInt32
val zextdToInt8: int32 -> int8 = zextdFromInt32ToInt8
val zextdToInt16: int32 -> int16 = zextdFromInt32ToInt16
val zextdToInt32: int32 -> int32 = zextdFromInt32ToInt32
val zextdToInt64: int32 -> int64 = zextdFromInt32ToInt64
val zextdToWord8: int32 -> word8 = zextdFromInt32ToWord8
val zextdToWord16: int32 -> word16 = zextdFromInt32ToWord16
val zextdToWord32: int32 -> word32 = zextdFromInt32ToWord32
val zextdToWord64: int32 -> word64 = zextdFromInt32ToWord64
val sextdFromInt8: int8 -> int32 = sextdFromInt8ToInt32
val sextdFromInt16: int16 -> int32 = sextdFromInt16ToInt32
val sextdFromInt32: int32 -> int32 = sextdFromInt32ToInt32
val sextdFromInt64: int64 -> int32 = sextdFromInt64ToInt32
val sextdFromWord8: word8 -> int32 = sextdFromWord8ToInt32
val sextdFromWord16: word16 -> int32 = sextdFromWord16ToInt32
val sextdFromWord32: word32 -> int32 = sextdFromWord32ToInt32
val sextdFromWord64: word64 -> int32 = sextdFromWord64ToInt32
val sextdToInt8: int32 -> int8 = sextdFromInt32ToInt8
val sextdToInt16: int32 -> int16 = sextdFromInt32ToInt16
val sextdToInt32: int32 -> int32 = sextdFromInt32ToInt32
val sextdToInt64: int32 -> int64 = sextdFromInt32ToInt64
val sextdToWord8: int32 -> word8 = sextdFromInt32ToWord8
val sextdToWord16: int32 -> word16 = sextdFromInt32ToWord16
val sextdToWord32: int32 -> word32 = sextdFromInt32ToWord32
val sextdToWord64: int32 -> word64 = sextdFromInt32ToWord64
val castFromInt8: int8 -> int32 = castFromInt8ToInt32
val castFromInt16: int16 -> int32 = castFromInt16ToInt32
val castFromInt32: int32 -> int32 = castFromInt32ToInt32
val castFromInt64: int64 -> int32 = castFromInt64ToInt32
val castFromWord8: word8 -> int32 = castFromWord8ToInt32
val castFromWord16: word16 -> int32 = castFromWord16ToInt32
val castFromWord32: word32 -> int32 = castFromWord32ToInt32
val castFromWord64: word64 -> int32 = castFromWord64ToInt32
val castToInt8: int32 -> int8 = castFromInt32ToInt8
val castToInt16: int32 -> int16 = castFromInt32ToInt16
val castToInt32: int32 -> int32 = castFromInt32ToInt32
val castToInt64: int32 -> int64 = castFromInt32ToInt64
val castToWord8: int32 -> word8 = castFromInt32ToWord8
val castToWord16: int32 -> word16 = castFromInt32ToWord16
val castToWord32: int32 -> word32 = castFromInt32ToWord32
val castToWord64: int32 -> word64 = castFromInt32ToWord64
val zchckFromInt8: int8 -> int32 = zchckFromInt8ToInt32
val zchckFromInt16: int16 -> int32 = zchckFromInt16ToInt32
val zchckFromInt32: int32 -> int32 = zchckFromInt32ToInt32
val zchckFromInt64: int64 -> int32 = zchckFromInt64ToInt32
val zchckFromWord8: word8 -> int32 = zchckFromWord8ToInt32
val zchckFromWord16: word16 -> int32 = zchckFromWord16ToInt32
val zchckFromWord32: word32 -> int32 = zchckFromWord32ToInt32
val zchckFromWord64: word64 -> int32 = zchckFromWord64ToInt32
val zchckToInt8: int32 -> int8 = zchckFromInt32ToInt8
val zchckToInt16: int32 -> int16 = zchckFromInt32ToInt16
val zchckToInt32: int32 -> int32 = zchckFromInt32ToInt32
val zchckToInt64: int32 -> int64 = zchckFromInt32ToInt64
val zchckToWord8: int32 -> word8 = zchckFromInt32ToWord8
val zchckToWord16: int32 -> word16 = zchckFromInt32ToWord16
val zchckToWord32: int32 -> word32 = zchckFromInt32ToWord32
val zchckToWord64: int32 -> word64 = zchckFromInt32ToWord64
val schckFromInt8: int8 -> int32 = schckFromInt8ToInt32
val schckFromInt16: int16 -> int32 = schckFromInt16ToInt32
val schckFromInt32: int32 -> int32 = schckFromInt32ToInt32
val schckFromInt64: int64 -> int32 = schckFromInt64ToInt32
val schckFromWord8: word8 -> int32 = schckFromWord8ToInt32
val schckFromWord16: word16 -> int32 = schckFromWord16ToInt32
val schckFromWord32: word32 -> int32 = schckFromWord32ToInt32
val schckFromWord64: word64 -> int32 = schckFromWord64ToInt32
val schckToInt8: int32 -> int8 = schckFromInt32ToInt8
val schckToInt16: int32 -> int16 = schckFromInt32ToInt16
val schckToInt32: int32 -> int32 = schckFromInt32ToInt32
val schckToInt64: int32 -> int64 = schckFromInt32ToInt64
val schckToWord8: int32 -> word8 = schckFromInt32ToWord8
val schckToWord16: int32 -> word16 = schckFromInt32ToWord16
val schckToWord32: int32 -> word32 = schckFromInt32ToWord32
val schckToWord64: int32 -> word64 = schckFromInt32ToWord64
val zextdFromInt8: int8 -> int64 = zextdFromInt8ToInt64
val zextdFromInt16: int16 -> int64 = zextdFromInt16ToInt64
val zextdFromInt32: int32 -> int64 = zextdFromInt32ToInt64
val zextdFromInt64: int64 -> int64 = zextdFromInt64ToInt64
val zextdFromWord8: word8 -> int64 = zextdFromWord8ToInt64
val zextdFromWord16: word16 -> int64 = zextdFromWord16ToInt64
val zextdFromWord32: word32 -> int64 = zextdFromWord32ToInt64
val zextdFromWord64: word64 -> int64 = zextdFromWord64ToInt64
val zextdToInt8: int64 -> int8 = zextdFromInt64ToInt8
val zextdToInt16: int64 -> int16 = zextdFromInt64ToInt16
val zextdToInt32: int64 -> int32 = zextdFromInt64ToInt32
val zextdToInt64: int64 -> int64 = zextdFromInt64ToInt64
val zextdToWord8: int64 -> word8 = zextdFromInt64ToWord8
val zextdToWord16: int64 -> word16 = zextdFromInt64ToWord16
val zextdToWord32: int64 -> word32 = zextdFromInt64ToWord32
val zextdToWord64: int64 -> word64 = zextdFromInt64ToWord64
val sextdFromInt8: int8 -> int64 = sextdFromInt8ToInt64
val sextdFromInt16: int16 -> int64 = sextdFromInt16ToInt64
val sextdFromInt32: int32 -> int64 = sextdFromInt32ToInt64
val sextdFromInt64: int64 -> int64 = sextdFromInt64ToInt64
val sextdFromWord8: word8 -> int64 = sextdFromWord8ToInt64
val sextdFromWord16: word16 -> int64 = sextdFromWord16ToInt64
val sextdFromWord32: word32 -> int64 = sextdFromWord32ToInt64
val sextdFromWord64: word64 -> int64 = sextdFromWord64ToInt64
val sextdToInt8: int64 -> int8 = sextdFromInt64ToInt8
val sextdToInt16: int64 -> int16 = sextdFromInt64ToInt16
val sextdToInt32: int64 -> int32 = sextdFromInt64ToInt32
val sextdToInt64: int64 -> int64 = sextdFromInt64ToInt64
val sextdToWord8: int64 -> word8 = sextdFromInt64ToWord8
val sextdToWord16: int64 -> word16 = sextdFromInt64ToWord16
val sextdToWord32: int64 -> word32 = sextdFromInt64ToWord32
val sextdToWord64: int64 -> word64 = sextdFromInt64ToWord64
val castFromInt8: int8 -> int64 = castFromInt8ToInt64
val castFromInt16: int16 -> int64 = castFromInt16ToInt64
val castFromInt32: int32 -> int64 = castFromInt32ToInt64
val castFromInt64: int64 -> int64 = castFromInt64ToInt64
val castFromWord8: word8 -> int64 = castFromWord8ToInt64
val castFromWord16: word16 -> int64 = castFromWord16ToInt64
val castFromWord32: word32 -> int64 = castFromWord32ToInt64
val castFromWord64: word64 -> int64 = castFromWord64ToInt64
val castToInt8: int64 -> int8 = castFromInt64ToInt8
val castToInt16: int64 -> int16 = castFromInt64ToInt16
val castToInt32: int64 -> int32 = castFromInt64ToInt32
val castToInt64: int64 -> int64 = castFromInt64ToInt64
val castToWord8: int64 -> word8 = castFromInt64ToWord8
val castToWord16: int64 -> word16 = castFromInt64ToWord16
val castToWord32: int64 -> word32 = castFromInt64ToWord32
val castToWord64: int64 -> word64 = castFromInt64ToWord64
val zchckFromInt8: int8 -> int64 = zchckFromInt8ToInt64
val zchckFromInt16: int16 -> int64 = zchckFromInt16ToInt64
val zchckFromInt32: int32 -> int64 = zchckFromInt32ToInt64
val zchckFromInt64: int64 -> int64 = zchckFromInt64ToInt64
val zchckFromWord8: word8 -> int64 = zchckFromWord8ToInt64
val zchckFromWord16: word16 -> int64 = zchckFromWord16ToInt64
val zchckFromWord32: word32 -> int64 = zchckFromWord32ToInt64
val zchckFromWord64: word64 -> int64 = zchckFromWord64ToInt64
val zchckToInt8: int64 -> int8 = zchckFromInt64ToInt8
val zchckToInt16: int64 -> int16 = zchckFromInt64ToInt16
val zchckToInt32: int64 -> int32 = zchckFromInt64ToInt32
val zchckToInt64: int64 -> int64 = zchckFromInt64ToInt64
val zchckToWord8: int64 -> word8 = zchckFromInt64ToWord8
val zchckToWord16: int64 -> word16 = zchckFromInt64ToWord16
val zchckToWord32: int64 -> word32 = zchckFromInt64ToWord32
val zchckToWord64: int64 -> word64 = zchckFromInt64ToWord64
val schckFromInt8: int8 -> int64 = schckFromInt8ToInt64
val schckFromInt16: int16 -> int64 = schckFromInt16ToInt64
val schckFromInt32: int32 -> int64 = schckFromInt32ToInt64
val schckFromInt64: int64 -> int64 = schckFromInt64ToInt64
val schckFromWord8: word8 -> int64 = schckFromWord8ToInt64
val schckFromWord16: word16 -> int64 = schckFromWord16ToInt64
val schckFromWord32: word32 -> int64 = schckFromWord32ToInt64
val schckFromWord64: word64 -> int64 = schckFromWord64ToInt64
val schckToInt8: int64 -> int8 = schckFromInt64ToInt8
val schckToInt16: int64 -> int16 = schckFromInt64ToInt16
val schckToInt32: int64 -> int32 = schckFromInt64ToInt32
val schckToInt64: int64 -> int64 = schckFromInt64ToInt64
val schckToWord8: int64 -> word8 = schckFromInt64ToWord8
val schckToWord16: int64 -> word16 = schckFromInt64ToWord16
val schckToWord32: int64 -> word32 = schckFromInt64ToWord32
val schckToWord64: int64 -> word64 = schckFromInt64ToWord64
val zextdFromInt8: int8 -> word8 = zextdFromInt8ToWord8
val zextdFromInt16: int16 -> word8 = zextdFromInt16ToWord8
val zextdFromInt32: int32 -> word8 = zextdFromInt32ToWord8
val zextdFromInt64: int64 -> word8 = zextdFromInt64ToWord8
val zextdFromWord8: word8 -> word8 = zextdFromWord8ToWord8
val zextdFromWord16: word16 -> word8 = zextdFromWord16ToWord8
val zextdFromWord32: word32 -> word8 = zextdFromWord32ToWord8
val zextdFromWord64: word64 -> word8 = zextdFromWord64ToWord8
val zextdToInt8: word8 -> int8 = zextdFromWord8ToInt8
val zextdToInt16: word8 -> int16 = zextdFromWord8ToInt16
val zextdToInt32: word8 -> int32 = zextdFromWord8ToInt32
val zextdToInt64: word8 -> int64 = zextdFromWord8ToInt64
val zextdToWord8: word8 -> word8 = zextdFromWord8ToWord8
val zextdToWord16: word8 -> word16 = zextdFromWord8ToWord16
val zextdToWord32: word8 -> word32 = zextdFromWord8ToWord32
val zextdToWord64: word8 -> word64 = zextdFromWord8ToWord64
val sextdFromInt8: int8 -> word8 = sextdFromInt8ToWord8
val sextdFromInt16: int16 -> word8 = sextdFromInt16ToWord8
val sextdFromInt32: int32 -> word8 = sextdFromInt32ToWord8
val sextdFromInt64: int64 -> word8 = sextdFromInt64ToWord8
val sextdFromWord8: word8 -> word8 = sextdFromWord8ToWord8
val sextdFromWord16: word16 -> word8 = sextdFromWord16ToWord8
val sextdFromWord32: word32 -> word8 = sextdFromWord32ToWord8
val sextdFromWord64: word64 -> word8 = sextdFromWord64ToWord8
val sextdToInt8: word8 -> int8 = sextdFromWord8ToInt8
val sextdToInt16: word8 -> int16 = sextdFromWord8ToInt16
val sextdToInt32: word8 -> int32 = sextdFromWord8ToInt32
val sextdToInt64: word8 -> int64 = sextdFromWord8ToInt64
val sextdToWord8: word8 -> word8 = sextdFromWord8ToWord8
val sextdToWord16: word8 -> word16 = sextdFromWord8ToWord16
val sextdToWord32: word8 -> word32 = sextdFromWord8ToWord32
val sextdToWord64: word8 -> word64 = sextdFromWord8ToWord64
val castFromInt8: int8 -> word8 = castFromInt8ToWord8
val castFromInt16: int16 -> word8 = castFromInt16ToWord8
val castFromInt32: int32 -> word8 = castFromInt32ToWord8
val castFromInt64: int64 -> word8 = castFromInt64ToWord8
val castFromWord8: word8 -> word8 = castFromWord8ToWord8
val castFromWord16: word16 -> word8 = castFromWord16ToWord8
val castFromWord32: word32 -> word8 = castFromWord32ToWord8
val castFromWord64: word64 -> word8 = castFromWord64ToWord8
val castToInt8: word8 -> int8 = castFromWord8ToInt8
val castToInt16: word8 -> int16 = castFromWord8ToInt16
val castToInt32: word8 -> int32 = castFromWord8ToInt32
val castToInt64: word8 -> int64 = castFromWord8ToInt64
val castToWord8: word8 -> word8 = castFromWord8ToWord8
val castToWord16: word8 -> word16 = castFromWord8ToWord16
val castToWord32: word8 -> word32 = castFromWord8ToWord32
val castToWord64: word8 -> word64 = castFromWord8ToWord64
val zchckFromInt8: int8 -> word8 = zchckFromInt8ToWord8
val zchckFromInt16: int16 -> word8 = zchckFromInt16ToWord8
val zchckFromInt32: int32 -> word8 = zchckFromInt32ToWord8
val zchckFromInt64: int64 -> word8 = zchckFromInt64ToWord8
val zchckFromWord8: word8 -> word8 = zchckFromWord8ToWord8
val zchckFromWord16: word16 -> word8 = zchckFromWord16ToWord8
val zchckFromWord32: word32 -> word8 = zchckFromWord32ToWord8
val zchckFromWord64: word64 -> word8 = zchckFromWord64ToWord8
val zchckToInt8: word8 -> int8 = zchckFromWord8ToInt8
val zchckToInt16: word8 -> int16 = zchckFromWord8ToInt16
val zchckToInt32: word8 -> int32 = zchckFromWord8ToInt32
val zchckToInt64: word8 -> int64 = zchckFromWord8ToInt64
val zchckToWord8: word8 -> word8 = zchckFromWord8ToWord8
val zchckToWord16: word8 -> word16 = zchckFromWord8ToWord16
val zchckToWord32: word8 -> word32 = zchckFromWord8ToWord32
val zchckToWord64: word8 -> word64 = zchckFromWord8ToWord64
val schckFromInt8: int8 -> word8 = schckFromInt8ToWord8
val schckFromInt16: int16 -> word8 = schckFromInt16ToWord8
val schckFromInt32: int32 -> word8 = schckFromInt32ToWord8
val schckFromInt64: int64 -> word8 = schckFromInt64ToWord8
val schckFromWord8: word8 -> word8 = schckFromWord8ToWord8
val schckFromWord16: word16 -> word8 = schckFromWord16ToWord8
val schckFromWord32: word32 -> word8 = schckFromWord32ToWord8
val schckFromWord64: word64 -> word8 = schckFromWord64ToWord8
val schckToInt8: word8 -> int8 = schckFromWord8ToInt8
val schckToInt16: word8 -> int16 = schckFromWord8ToInt16
val schckToInt32: word8 -> int32 = schckFromWord8ToInt32
val schckToInt64: word8 -> int64 = schckFromWord8ToInt64
val schckToWord8: word8 -> word8 = schckFromWord8ToWord8
val schckToWord16: word8 -> word16 = schckFromWord8ToWord16
val schckToWord32: word8 -> word32 = schckFromWord8ToWord32
val schckToWord64: word8 -> word64 = schckFromWord8ToWord64
val zextdFromInt8: int8 -> word16 = zextdFromInt8ToWord16
val zextdFromInt16: int16 -> word16 = zextdFromInt16ToWord16
val zextdFromInt32: int32 -> word16 = zextdFromInt32ToWord16
val zextdFromInt64: int64 -> word16 = zextdFromInt64ToWord16
val zextdFromWord8: word8 -> word16 = zextdFromWord8ToWord16
val zextdFromWord16: word16 -> word16 = zextdFromWord16ToWord16
val zextdFromWord32: word32 -> word16 = zextdFromWord32ToWord16
val zextdFromWord64: word64 -> word16 = zextdFromWord64ToWord16
val zextdToInt8: word16 -> int8 = zextdFromWord16ToInt8
val zextdToInt16: word16 -> int16 = zextdFromWord16ToInt16
val zextdToInt32: word16 -> int32 = zextdFromWord16ToInt32
val zextdToInt64: word16 -> int64 = zextdFromWord16ToInt64
val zextdToWord8: word16 -> word8 = zextdFromWord16ToWord8
val zextdToWord16: word16 -> word16 = zextdFromWord16ToWord16
val zextdToWord32: word16 -> word32 = zextdFromWord16ToWord32
val zextdToWord64: word16 -> word64 = zextdFromWord16ToWord64
val sextdFromInt8: int8 -> word16 = sextdFromInt8ToWord16
val sextdFromInt16: int16 -> word16 = sextdFromInt16ToWord16
val sextdFromInt32: int32 -> word16 = sextdFromInt32ToWord16
val sextdFromInt64: int64 -> word16 = sextdFromInt64ToWord16
val sextdFromWord8: word8 -> word16 = sextdFromWord8ToWord16
val sextdFromWord16: word16 -> word16 = sextdFromWord16ToWord16
val sextdFromWord32: word32 -> word16 = sextdFromWord32ToWord16
val sextdFromWord64: word64 -> word16 = sextdFromWord64ToWord16
val sextdToInt8: word16 -> int8 = sextdFromWord16ToInt8
val sextdToInt16: word16 -> int16 = sextdFromWord16ToInt16
val sextdToInt32: word16 -> int32 = sextdFromWord16ToInt32
val sextdToInt64: word16 -> int64 = sextdFromWord16ToInt64
val sextdToWord8: word16 -> word8 = sextdFromWord16ToWord8
val sextdToWord16: word16 -> word16 = sextdFromWord16ToWord16
val sextdToWord32: word16 -> word32 = sextdFromWord16ToWord32
val sextdToWord64: word16 -> word64 = sextdFromWord16ToWord64
val castFromInt8: int8 -> word16 = castFromInt8ToWord16
val castFromInt16: int16 -> word16 = castFromInt16ToWord16
val castFromInt32: int32 -> word16 = castFromInt32ToWord16
val castFromInt64: int64 -> word16 = castFromInt64ToWord16
val castFromWord8: word8 -> word16 = castFromWord8ToWord16
val castFromWord16: word16 -> word16 = castFromWord16ToWord16
val castFromWord32: word32 -> word16 = castFromWord32ToWord16
val castFromWord64: word64 -> word16 = castFromWord64ToWord16
val castToInt8: word16 -> int8 = castFromWord16ToInt8
val castToInt16: word16 -> int16 = castFromWord16ToInt16
val castToInt32: word16 -> int32 = castFromWord16ToInt32
val castToInt64: word16 -> int64 = castFromWord16ToInt64
val castToWord8: word16 -> word8 = castFromWord16ToWord8
val castToWord16: word16 -> word16 = castFromWord16ToWord16
val castToWord32: word16 -> word32 = castFromWord16ToWord32
val castToWord64: word16 -> word64 = castFromWord16ToWord64
val zchckFromInt8: int8 -> word16 = zchckFromInt8ToWord16
val zchckFromInt16: int16 -> word16 = zchckFromInt16ToWord16
val zchckFromInt32: int32 -> word16 = zchckFromInt32ToWord16
val zchckFromInt64: int64 -> word16 = zchckFromInt64ToWord16
val zchckFromWord8: word8 -> word16 = zchckFromWord8ToWord16
val zchckFromWord16: word16 -> word16 = zchckFromWord16ToWord16
val zchckFromWord32: word32 -> word16 = zchckFromWord32ToWord16
val zchckFromWord64: word64 -> word16 = zchckFromWord64ToWord16
val zchckToInt8: word16 -> int8 = zchckFromWord16ToInt8
val zchckToInt16: word16 -> int16 = zchckFromWord16ToInt16
val zchckToInt32: word16 -> int32 = zchckFromWord16ToInt32
val zchckToInt64: word16 -> int64 = zchckFromWord16ToInt64
val zchckToWord8: word16 -> word8 = zchckFromWord16ToWord8
val zchckToWord16: word16 -> word16 = zchckFromWord16ToWord16
val zchckToWord32: word16 -> word32 = zchckFromWord16ToWord32
val zchckToWord64: word16 -> word64 = zchckFromWord16ToWord64
val schckFromInt8: int8 -> word16 = schckFromInt8ToWord16
val schckFromInt16: int16 -> word16 = schckFromInt16ToWord16
val schckFromInt32: int32 -> word16 = schckFromInt32ToWord16
val schckFromInt64: int64 -> word16 = schckFromInt64ToWord16
val schckFromWord8: word8 -> word16 = schckFromWord8ToWord16
val schckFromWord16: word16 -> word16 = schckFromWord16ToWord16
val schckFromWord32: word32 -> word16 = schckFromWord32ToWord16
val schckFromWord64: word64 -> word16 = schckFromWord64ToWord16
val schckToInt8: word16 -> int8 = schckFromWord16ToInt8
val schckToInt16: word16 -> int16 = schckFromWord16ToInt16
val schckToInt32: word16 -> int32 = schckFromWord16ToInt32
val schckToInt64: word16 -> int64 = schckFromWord16ToInt64
val schckToWord8: word16 -> word8 = schckFromWord16ToWord8
val schckToWord16: word16 -> word16 = schckFromWord16ToWord16
val schckToWord32: word16 -> word32 = schckFromWord16ToWord32
val schckToWord64: word16 -> word64 = schckFromWord16ToWord64
val zextdFromInt8: int8 -> word32 = zextdFromInt8ToWord32
val zextdFromInt16: int16 -> word32 = zextdFromInt16ToWord32
val zextdFromInt32: int32 -> word32 = zextdFromInt32ToWord32
val zextdFromInt64: int64 -> word32 = zextdFromInt64ToWord32
val zextdFromWord8: word8 -> word32 = zextdFromWord8ToWord32
val zextdFromWord16: word16 -> word32 = zextdFromWord16ToWord32
val zextdFromWord32: word32 -> word32 = zextdFromWord32ToWord32
val zextdFromWord64: word64 -> word32 = zextdFromWord64ToWord32
val zextdToInt8: word32 -> int8 = zextdFromWord32ToInt8
val zextdToInt16: word32 -> int16 = zextdFromWord32ToInt16
val zextdToInt32: word32 -> int32 = zextdFromWord32ToInt32
val zextdToInt64: word32 -> int64 = zextdFromWord32ToInt64
val zextdToWord8: word32 -> word8 = zextdFromWord32ToWord8
val zextdToWord16: word32 -> word16 = zextdFromWord32ToWord16
val zextdToWord32: word32 -> word32 = zextdFromWord32ToWord32
val zextdToWord64: word32 -> word64 = zextdFromWord32ToWord64
val sextdFromInt8: int8 -> word32 = sextdFromInt8ToWord32
val sextdFromInt16: int16 -> word32 = sextdFromInt16ToWord32
val sextdFromInt32: int32 -> word32 = sextdFromInt32ToWord32
val sextdFromInt64: int64 -> word32 = sextdFromInt64ToWord32
val sextdFromWord8: word8 -> word32 = sextdFromWord8ToWord32
val sextdFromWord16: word16 -> word32 = sextdFromWord16ToWord32
val sextdFromWord32: word32 -> word32 = sextdFromWord32ToWord32
val sextdFromWord64: word64 -> word32 = sextdFromWord64ToWord32
val sextdToInt8: word32 -> int8 = sextdFromWord32ToInt8
val sextdToInt16: word32 -> int16 = sextdFromWord32ToInt16
val sextdToInt32: word32 -> int32 = sextdFromWord32ToInt32
val sextdToInt64: word32 -> int64 = sextdFromWord32ToInt64
val sextdToWord8: word32 -> word8 = sextdFromWord32ToWord8
val sextdToWord16: word32 -> word16 = sextdFromWord32ToWord16
val sextdToWord32: word32 -> word32 = sextdFromWord32ToWord32
val sextdToWord64: word32 -> word64 = sextdFromWord32ToWord64
val castFromInt8: int8 -> word32 = castFromInt8ToWord32
val castFromInt16: int16 -> word32 = castFromInt16ToWord32
val castFromInt32: int32 -> word32 = castFromInt32ToWord32
val castFromInt64: int64 -> word32 = castFromInt64ToWord32
val castFromWord8: word8 -> word32 = castFromWord8ToWord32
val castFromWord16: word16 -> word32 = castFromWord16ToWord32
val castFromWord32: word32 -> word32 = castFromWord32ToWord32
val castFromWord64: word64 -> word32 = castFromWord64ToWord32
val castToInt8: word32 -> int8 = castFromWord32ToInt8
val castToInt16: word32 -> int16 = castFromWord32ToInt16
val castToInt32: word32 -> int32 = castFromWord32ToInt32
val castToInt64: word32 -> int64 = castFromWord32ToInt64
val castToWord8: word32 -> word8 = castFromWord32ToWord8
val castToWord16: word32 -> word16 = castFromWord32ToWord16
val castToWord32: word32 -> word32 = castFromWord32ToWord32
val castToWord64: word32 -> word64 = castFromWord32ToWord64
val zchckFromInt8: int8 -> word32 = zchckFromInt8ToWord32
val zchckFromInt16: int16 -> word32 = zchckFromInt16ToWord32
val zchckFromInt32: int32 -> word32 = zchckFromInt32ToWord32
val zchckFromInt64: int64 -> word32 = zchckFromInt64ToWord32
val zchckFromWord8: word8 -> word32 = zchckFromWord8ToWord32
val zchckFromWord16: word16 -> word32 = zchckFromWord16ToWord32
val zchckFromWord32: word32 -> word32 = zchckFromWord32ToWord32
val zchckFromWord64: word64 -> word32 = zchckFromWord64ToWord32
val zchckToInt8: word32 -> int8 = zchckFromWord32ToInt8
val zchckToInt16: word32 -> int16 = zchckFromWord32ToInt16
val zchckToInt32: word32 -> int32 = zchckFromWord32ToInt32
val zchckToInt64: word32 -> int64 = zchckFromWord32ToInt64
val zchckToWord8: word32 -> word8 = zchckFromWord32ToWord8
val zchckToWord16: word32 -> word16 = zchckFromWord32ToWord16
val zchckToWord32: word32 -> word32 = zchckFromWord32ToWord32
val zchckToWord64: word32 -> word64 = zchckFromWord32ToWord64
val schckFromInt8: int8 -> word32 = schckFromInt8ToWord32
val schckFromInt16: int16 -> word32 = schckFromInt16ToWord32
val schckFromInt32: int32 -> word32 = schckFromInt32ToWord32
val schckFromInt64: int64 -> word32 = schckFromInt64ToWord32
val schckFromWord8: word8 -> word32 = schckFromWord8ToWord32
val schckFromWord16: word16 -> word32 = schckFromWord16ToWord32
val schckFromWord32: word32 -> word32 = schckFromWord32ToWord32
val schckFromWord64: word64 -> word32 = schckFromWord64ToWord32
val schckToInt8: word32 -> int8 = schckFromWord32ToInt8
val schckToInt16: word32 -> int16 = schckFromWord32ToInt16
val schckToInt32: word32 -> int32 = schckFromWord32ToInt32
val schckToInt64: word32 -> int64 = schckFromWord32ToInt64
val schckToWord8: word32 -> word8 = schckFromWord32ToWord8
val schckToWord16: word32 -> word16 = schckFromWord32ToWord16
val schckToWord32: word32 -> word32 = schckFromWord32ToWord32
val schckToWord64: word32 -> word64 = schckFromWord32ToWord64
val zextdFromInt8: int8 -> word64 = zextdFromInt8ToWord64
val zextdFromInt16: int16 -> word64 = zextdFromInt16ToWord64
val zextdFromInt32: int32 -> word64 = zextdFromInt32ToWord64
val zextdFromInt64: int64 -> word64 = zextdFromInt64ToWord64
val zextdFromWord8: word8 -> word64 = zextdFromWord8ToWord64
val zextdFromWord16: word16 -> word64 = zextdFromWord16ToWord64
val zextdFromWord32: word32 -> word64 = zextdFromWord32ToWord64
val zextdFromWord64: word64 -> word64 = zextdFromWord64ToWord64
val zextdToInt8: word64 -> int8 = zextdFromWord64ToInt8
val zextdToInt16: word64 -> int16 = zextdFromWord64ToInt16
val zextdToInt32: word64 -> int32 = zextdFromWord64ToInt32
val zextdToInt64: word64 -> int64 = zextdFromWord64ToInt64
val zextdToWord8: word64 -> word8 = zextdFromWord64ToWord8
val zextdToWord16: word64 -> word16 = zextdFromWord64ToWord16
val zextdToWord32: word64 -> word32 = zextdFromWord64ToWord32
val zextdToWord64: word64 -> word64 = zextdFromWord64ToWord64
val sextdFromInt8: int8 -> word64 = sextdFromInt8ToWord64
val sextdFromInt16: int16 -> word64 = sextdFromInt16ToWord64
val sextdFromInt32: int32 -> word64 = sextdFromInt32ToWord64
val sextdFromInt64: int64 -> word64 = sextdFromInt64ToWord64
val sextdFromWord8: word8 -> word64 = sextdFromWord8ToWord64
val sextdFromWord16: word16 -> word64 = sextdFromWord16ToWord64
val sextdFromWord32: word32 -> word64 = sextdFromWord32ToWord64
val sextdFromWord64: word64 -> word64 = sextdFromWord64ToWord64
val sextdToInt8: word64 -> int8 = sextdFromWord64ToInt8
val sextdToInt16: word64 -> int16 = sextdFromWord64ToInt16
val sextdToInt32: word64 -> int32 = sextdFromWord64ToInt32
val sextdToInt64: word64 -> int64 = sextdFromWord64ToInt64
val sextdToWord8: word64 -> word8 = sextdFromWord64ToWord8
val sextdToWord16: word64 -> word16 = sextdFromWord64ToWord16
val sextdToWord32: word64 -> word32 = sextdFromWord64ToWord32
val sextdToWord64: word64 -> word64 = sextdFromWord64ToWord64
val castFromInt8: int8 -> word64 = castFromInt8ToWord64
val castFromInt16: int16 -> word64 = castFromInt16ToWord64
val castFromInt32: int32 -> word64 = castFromInt32ToWord64
val castFromInt64: int64 -> word64 = castFromInt64ToWord64
val castFromWord8: word8 -> word64 = castFromWord8ToWord64
val castFromWord16: word16 -> word64 = castFromWord16ToWord64
val castFromWord32: word32 -> word64 = castFromWord32ToWord64
val castFromWord64: word64 -> word64 = castFromWord64ToWord64
val castToInt8: word64 -> int8 = castFromWord64ToInt8
val castToInt16: word64 -> int16 = castFromWord64ToInt16
val castToInt32: word64 -> int32 = castFromWord64ToInt32
val castToInt64: word64 -> int64 = castFromWord64ToInt64
val castToWord8: word64 -> word8 = castFromWord64ToWord8
val castToWord16: word64 -> word16 = castFromWord64ToWord16
val castToWord32: word64 -> word32 = castFromWord64ToWord32
val castToWord64: word64 -> word64 = castFromWord64ToWord64
val zchckFromInt8: int8 -> word64 = zchckFromInt8ToWord64
val zchckFromInt16: int16 -> word64 = zchckFromInt16ToWord64
val zchckFromInt32: int32 -> word64 = zchckFromInt32ToWord64
val zchckFromInt64: int64 -> word64 = zchckFromInt64ToWord64
val zchckFromWord8: word8 -> word64 = zchckFromWord8ToWord64
val zchckFromWord16: word16 -> word64 = zchckFromWord16ToWord64
val zchckFromWord32: word32 -> word64 = zchckFromWord32ToWord64
val zchckFromWord64: word64 -> word64 = zchckFromWord64ToWord64
val zchckToInt8: word64 -> int8 = zchckFromWord64ToInt8
val zchckToInt16: word64 -> int16 = zchckFromWord64ToInt16
val zchckToInt32: word64 -> int32 = zchckFromWord64ToInt32
val zchckToInt64: word64 -> int64 = zchckFromWord64ToInt64
val zchckToWord8: word64 -> word8 = zchckFromWord64ToWord8
val zchckToWord16: word64 -> word16 = zchckFromWord64ToWord16
val zchckToWord32: word64 -> word32 = zchckFromWord64ToWord32
val zchckToWord64: word64 -> word64 = zchckFromWord64ToWord64
val schckFromInt8: int8 -> word64 = schckFromInt8ToWord64
val schckFromInt16: int16 -> word64 = schckFromInt16ToWord64
val schckFromInt32: int32 -> word64 = schckFromInt32ToWord64
val schckFromInt64: int64 -> word64 = schckFromInt64ToWord64
val schckFromWord8: word8 -> word64 = schckFromWord8ToWord64
val schckFromWord16: word16 -> word64 = schckFromWord16ToWord64
val schckFromWord32: word32 -> word64 = schckFromWord32ToWord64
val schckFromWord64: word64 -> word64 = schckFromWord64ToWord64
val schckToInt8: word64 -> int8 = schckFromWord64ToInt8
val schckToInt16: word64 -> int16 = schckFromWord64ToInt16
val schckToInt32: word64 -> int32 = schckFromWord64ToInt32
val schckToInt64: word64 -> int64 = schckFromWord64ToInt64
val schckToWord8: word64 -> word8 = schckFromWord64ToWord8
val schckToWord16: word64 -> word16 = schckFromWord64ToWord16
val schckToWord32: word64 -> word32 = schckFromWord64ToWord32
val schckToWord64: word64 -> word64 = schckFromWord64ToWord64
val idFromIntToWord: int8 -> word8 = idFromInt8ToWord8
val idFromWordToInt: word8 -> int8 = idFromWord8ToInt8
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word8 = (zextdFromWord32 0x0)
val maxWord': word8 = (notb zero)
val zero: int8 = (zextdFromInt32 0x0)
val one: int8 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word8 -> word8) -> int8 -> int8 = 
      (fn x_897: word8 -> word8 =>
       case x_897 of
	 (f: word8 -> word8) =>
	 (fn x_898: int8 =>
	  case x_898 of
	    x: int8 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word8 * word32 -> word8) -> int8 * word32 -> int8 = 
      (fn x_899: word8 * word32 -> word8 =>
       case x_899 of
	 (f: word8 * word32 -> word8) =>
	 (fn x_900: int8 * word32 =>
	  case x_900 of
	    (x: int8, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int8 * word32 -> int8 = (makeShop <<?)
val notb: int8 -> int8 = (makeUnop notb)
val >>?: int8 * word32 -> int8 = (makeShop >>?)
val minInt': int8 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int8 = (>>? ((notb zero), 0x1))
val idFromIntToWord: int16 -> word16 = idFromInt16ToWord16
val idFromWordToInt: word16 -> int16 = idFromWord16ToInt16
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word16 = (zextdFromWord32 0x0)
val maxWord': word16 = (notb zero)
val zero: int16 = (zextdFromInt32 0x0)
val one: int16 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word16 -> word16) -> int16 -> int16 = 
      (fn x_901: word16 -> word16 =>
       case x_901 of
	 (f: word16 -> word16) =>
	 (fn x_902: int16 =>
	  case x_902 of
	    x: int16 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word16 * word32 -> word16) -> int16 * word32 -> int16 = 
      (fn x_903: word16 * word32 -> word16 =>
       case x_903 of
	 (f: word16 * word32 -> word16) =>
	 (fn x_904: int16 * word32 =>
	  case x_904 of
	    (x: int16, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int16 * word32 -> int16 = (makeShop <<?)
val notb: int16 -> int16 = (makeUnop notb)
val >>?: int16 * word32 -> int16 = (makeShop >>?)
val minInt': int16 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int16 = (>>? ((notb zero), 0x1))
val idFromIntToWord: int32 -> word32 = idFromInt32ToWord32
val idFromWordToInt: word32 -> int32 = idFromWord32ToInt32
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word32 = (zextdFromWord32 0x0)
val one: word32 = (zextdFromWord32 0x1)
val maxWord': word32 = (notb zero)
val rec
   log2Word: word32 -> word32 = 
      (fn x_905: word32 =>
       case x_905 of
	 (w: word32) =>
	 let val rec
		loop: word32 * word32 * word32 -> word32 = 
		   (fn x_906: word32 * word32 * word32 =>
		    case x_906 of
		      ((n: word32, s: word32, acc: word32)) =>
		      case (= (word32) (n, one)) of
			true => acc
		      | false =>
			let val (n: word32, acc: word32) =
			       case (>= (n, (<<? (one, s)))) of
				 true => ((>>? (n, s)), (+ (acc, s)))
			       | false => (n, acc)
			in
			   (loop (n, (>>? (s, 0x1)), acc))
			end)
	 in
	    case case safe of
		   true => (= (word32) (w, zero)) | false => false of
	      true => raise Domain
	    | false => (loop (w, (>>? (sizeInBitsWord, 0x1)), 0x0))
	 end)
val rec
   log2: word32 -> int32 = 
      (fn x_907: word32 =>
       case x_907 of
	 (w: word32) => (zextdFromWord32ToInt32 (log2Word w)))
val zero: int32 = (zextdFromInt32 0x0)
val one: int32 = (zextdFromInt32 0x1)
val rec
   makeBinop: (word32 * word32 -> word32) -> int32 * int32 -> int32 = 
      (fn x_908: word32 * word32 -> word32 =>
       case x_908 of
	 (f: word32 * word32 -> word32) =>
	 (fn x_909: int32 * int32 =>
	  case x_909 of
	    (x: int32, y: int32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), (idFromIntToWord y))))))
val rec
   makeUnop: (word32 -> word32) -> int32 -> int32 = 
      (fn x_910: word32 -> word32 =>
       case x_910 of
	 (f: word32 -> word32) =>
	 (fn x_911: int32 =>
	  case x_911 of
	    x: int32 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word32 * word32 -> word32) -> int32 * word32 -> int32 = 
      (fn x_912: word32 * word32 -> word32 =>
       case x_912 of
	 (f: word32 * word32 -> word32) =>
	 (fn x_913: int32 * word32 =>
	  case x_913 of
	    (x: int32, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int32 * word32 -> int32 = (makeShop <<?)
val notb: int32 -> int32 = (makeUnop notb)
val orb: int32 * int32 -> int32 = (makeBinop orb)
val >>?: int32 * word32 -> int32 = (makeShop >>?)
val rec
   log2: int32 -> int32 = 
      (fn x_914: int32 =>
       case x_914 of
	 (i: int32) => (log2 (idFromIntToWord i)))
val minInt': int32 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int32 = (>>? ((notb zero), 0x1))
val rec
   quot: int32 * int32 -> int32 = 
      (fn x_915: int32 * int32 =>
       case x_915 of
	 ((x: int32, y: int32)) =>
	 case case safe of
		true => (= (int32) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case case case detectOverflow of
			    true => true | false => safe of
		       true => (= (int32) (x, minInt')) | false => false of
		  true => (= (int32) (y, (~ one))) | false => false of
	     true =>
	     case detectOverflow of
	       true => raise Overflow | false => minInt'
	   | false => (quotUnsafe (x, y)))
val rec
   rem: int32 * int32 -> int32 = 
      (fn x_916: int32 * int32 =>
       case x_916 of
	 ((x: int32, y: int32)) =>
	 case case safe of
		true => (= (int32) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case (= (int32) (x, minInt')) of
		  true => (= (int32) (y, (~ one))) | false => false of
	     true => zero | false => (remUnsafe (x, y)))
val rec
   mod: int32 * int32 -> int32 = 
      (fn x_917: int32 * int32 =>
       case x_917 of
	 ((x: int32, y: int32)) =>
	 case (>= (x, zero)) of
	   true =>
	   case (> (y, zero)) of
	     true => (remUnsafe (x, y))
	   | false =>
	     case (< (y, zero)) of
	       true =>
	       case (= (int32) (x, zero)) of
		 true => zero
	       | false => (+? ((remUnsafe ((-? (x, one)), y)), (+ (y, one))))
	     | false => raise Div
	 | false =>
	   case (< (y, zero)) of
	     true =>
	     case case (= (int32) (x, minInt')) of
		    true => (= (int32) (y, (~ one))) | false => false of
	       true => zero | false => (remUnsafe (x, y))
	   | false =>
	     case (> (y, zero)) of
	       true => (+? ((remUnsafe ((+? (x, one)), y)), (-? (y, one))))
	     | false => raise Div)
val idFromIntToWord: int32 -> word32 = idFromIntToWord
val <: word32 * word32 -> bool = <
val rec
   ltu: int32 * int32 -> bool = 
      (fn x_918: int32 * int32 =>
       case x_918 of
	 ((i: int32, i': int32)) =>
	 (< ((idFromIntToWord i), (idFromIntToWord i'))))
val <: int32 * int32 -> bool = ltu
val <: int32 * int32 -> bool = <
val rec
   >: int32 * int32 -> bool = 
      (fn x_919: int32 * int32 =>
       case x_919 of
	 ((a: int32, b: int32)) => (< (b, a)))
val gtu: int32 * int32 -> bool = >
val idFromIntToWord: int64 -> word64 = idFromInt64ToWord64
val idFromWordToInt: word64 -> int64 = idFromWord64ToInt64
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word64 = (zextdFromWord32 0x0)
val maxWord': word64 = (notb zero)
val zero: int64 = (zextdFromInt32 0x0)
val one: int64 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word64 -> word64) -> int64 -> int64 = 
      (fn x_920: word64 -> word64 =>
       case x_920 of
	 (f: word64 -> word64) =>
	 (fn x_921: int64 =>
	  case x_921 of
	    x: int64 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word64 * word32 -> word64) -> int64 * word32 -> int64 = 
      (fn x_922: word64 * word32 -> word64 =>
       case x_922 of
	 (f: word64 * word32 -> word64) =>
	 (fn x_923: int64 * word32 =>
	  case x_923 of
	    (x: int64, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int64 * word32 -> int64 = (makeShop <<?)
val notb: int64 -> int64 = (makeUnop notb)
val ~>>?: int64 * word32 -> int64 = (makeShop ~>>?)
val >>?: int64 * word32 -> int64 = (makeShop >>?)
val minInt': int64 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int64 = (>>? ((notb zero), 0x1))
val rec
   quot: int64 * int64 -> int64 = 
      (fn x_924: int64 * int64 =>
       case x_924 of
	 ((x: int64, y: int64)) =>
	 case case safe of
		true => (= (int64) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case case case detectOverflow of
			    true => true | false => safe of
		       true => (= (int64) (x, minInt')) | false => false of
		  true => (= (int64) (y, (~ one))) | false => false of
	     true =>
	     case detectOverflow of
	       true => raise Overflow | false => minInt'
	   | false => (quotUnsafe (x, y)))
val rec
   rem: int64 * int64 -> int64 = 
      (fn x_925: int64 * int64 =>
       case x_925 of
	 ((x: int64, y: int64)) =>
	 case case safe of
		true => (= (int64) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case (= (int64) (x, minInt')) of
		  true => (= (int64) (y, (~ one))) | false => false of
	     true => zero | false => (remUnsafe (x, y)))
val idFromIntToWord: int64 -> word64 = idFromIntToWord
val <: word64 * word64 -> bool = <
val rec
   ltu: int64 * int64 -> bool = 
      (fn x_926: int64 * int64 =>
       case x_926 of
	 ((i: int64, i': int64)) =>
	 (< ((idFromIntToWord i), (idFromIntToWord i'))))
val <: int64 * int64 -> bool = ltu
val <: int64 * int64 -> bool = <
val rec
   <=: int64 * int64 -> bool = 
      (fn x_927: int64 * int64 =>
       case x_927 of
	 ((a: int64, b: int64)) => (not (< (b, a))))
val rec
   >: int64 * int64 -> bool = 
      (fn x_928: int64 * int64 =>
       case x_928 of
	 ((a: int64, b: int64)) => (< (b, a)))
val rec
   >=: int64 * int64 -> bool = 
      (fn x_929: int64 * int64 =>
       case x_929 of
	 ((a: int64, b: int64)) => (<= (b, a)))
val gtu: int64 * int64 -> bool = >
val geu: int64 * int64 -> bool = >=
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> word64 = fInt64
val idFromObjptrInt: int64 -> word64 = f
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val fInt64: word64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: word64 -> int64 = fInt64
val idToObjptrInt: word64 -> int64 = f
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> word64 = fInt64
val zextdFromSeqIndex: int64 -> word64 = f
datatype Primitive.IntInf.rep = Big of word64 vector
				| Small of int64
val zero: intInf = 0
val rec
   isSmall: intInf -> bool = 
      (fn x_930: intInf =>
       case x_930 of
	 (i: intInf) => (<> (word64) (0x0, (andb ((toWord i), 0x1)))))
val rec
   areSmall: intInf * intInf -> bool = 
      (fn x_931: intInf * intInf =>
       case x_931 of
	 ((i: intInf, i': intInf)) =>
	 (<> (word64) (0x0, (andb ((andb ((toWord i), (toWord i'))), 0x1)))))
val rec
   bigNumLimbs: intInf -> int64 = 
      (fn x_932: intInf =>
       case x_932 of
	 (i: intInf) => (- ((length (word64) (toVector i)), 0x1)))
val rec
   numLimbs: intInf -> int64 = 
      (fn x_933: intInf =>
       case x_933 of
	 (i: intInf) =>
	 case (isSmall i) of
	   true => 0x1 | false => (bigNumLimbs i))
val rec
   dropTag: word64 -> word64 = 
      (fn x_934: word64 =>
       case x_934 of
	 (w: word64) => (~>>? (w, 0x1)))
val rec
   dropTagCoerce: intInf -> word64 = 
      (fn x_935: intInf =>
       case x_935 of
	 (i: intInf) => (dropTag (toWord i)))
val rec
   dropTagCoerceInt: intInf -> int64 = 
      (fn x_936: intInf =>
       case x_936 of
	 (i: intInf) => (idToObjptrInt (dropTagCoerce i)))
val rec
   addTag: word64 -> word64 = 
      (fn x_937: word64 =>
       case x_937 of
	 (w: word64) => (orb ((<<? (w, 0x1)), 0x1)))
val rec
   addTagCoerce: word64 -> intInf = 
      (fn x_938: word64 =>
       case x_938 of
	 (w: word64) => (fromWord (addTag w)))
val rec 'a
   make: {other: {eq: 'a * 'a -> bool,
		  isNeg: 'a -> bool,
		  neg: 'a -> 'a,
		  notb: 'a -> 'a,
		  rashift: 'a * word32 -> 'a,
		  rshift: 'a * word32 -> 'a,
		  sizeInBits: int32,
		  zero: 'a},
	  sextdToObjptrWord: 'a -> word64,
	  zextdToMPLimb: 'a -> word64,
	  zextdToObjptrWord: 'a -> word64}
	 -> bool * 'a -> intInf = 
      (fn x_939: {other: {eq: 'a * 'a -> bool,
			  isNeg: 'a -> bool,
			  neg: 'a -> 'a,
			  notb: 'a -> 'a,
			  rashift: 'a * word32 -> 'a,
			  rshift: 'a * word32 -> 'a,
			  sizeInBits: int32,
			  zero: 'a},
		  sextdToObjptrWord: 'a -> word64,
		  zextdToMPLimb: 'a -> word64,
		  zextdToObjptrWord: 'a -> word64} =>
       (fn x_940: bool * 'a =>
	case (x_939, x_940) of
	  ({zextdToMPLimb = zextdToMPLimb: 'a -> word64,
	    zextdToObjptrWord = zextdToObjptrWord: 'a -> word64,
	    sextdToObjptrWord = sextdToObjptrWord: 'a -> word64,
	    other = other: {eq: 'a * 'a -> bool,
			    isNeg: 'a -> bool,
			    neg: 'a -> 'a,
			    notb: 'a -> 'a,
			    rashift: 'a * word32 -> 'a,
			    rshift: 'a * word32 -> 'a,
			    sizeInBits: int32,
			    zero: 'a}},
	   (sextd: bool, w: 'a)) =>
	  case case (> (sizeInBits,
			((fn x_953: {eq: 'a * 'a -> bool,
				     isNeg: 'a -> bool,
				     neg: 'a -> 'a,
				     notb: 'a -> 'a,
				     rashift: 'a * word32 -> 'a,
				     rshift: 'a * word32 -> 'a,
				     sizeInBits: int32,
				     zero: 'a} =>
			  case x_953 of
			    {sizeInBits = #: int32} => #) other))) of
		 true => true
	       | false =>
		 let val shift: word32 = (- (sizeInBitsWord, 0x2))
		     val upperBits: 'a =
			(((fn x_950: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			   case x_950 of
			     {rashift = #: 'a * word32 -> 'a} => #) other) (w, shift))
		     val zeroBits: 'a =
			((fn x_949: {eq: 'a * 'a -> bool,
				     isNeg: 'a -> bool,
				     neg: 'a -> 'a,
				     notb: 'a -> 'a,
				     rashift: 'a * word32 -> 'a,
				     rshift: 'a * word32 -> 'a,
				     sizeInBits: int32,
				     zero: 'a} =>
			  case x_949 of
			    {zero = #: 'a} => #) other)
		     val oneBits: 'a =
			(((fn x_948: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			   case x_948 of
			     {notb = #: 'a -> 'a} => #) other) zeroBits)
		 in
		    case (((fn x_952: {eq: 'a * 'a -> bool,
				       isNeg: 'a -> bool,
				       neg: 'a -> 'a,
				       notb: 'a -> 'a,
				       rashift: 'a * word32 -> 'a,
				       rshift: 'a * word32 -> 'a,
				       sizeInBits: int32,
				       zero: 'a} =>
			    case x_952 of
			      {eq = #: 'a * 'a -> bool} => #) other) (upperBits, zeroBits)) of
		      true => true
		    | false =>
		      case sextd of
			true =>
			(((fn x_951: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			   case x_951 of
			     {eq = #: 'a * 'a -> bool} => #) other) (upperBits, oneBits))
		      | false => false
		 end of
	    true =>
	    case sextd of
	      true => (fromWord (addTag (sextdToObjptrWord w)))
	    | false => (fromWord (addTag (zextdToObjptrWord w)))
	  | false =>
	    let val rec
		   loop: 'a * int64 * (int64 * word64) list
			 -> int64 * (int64 * word64) list = 
		      (fn x_944: 'a * int64 * (int64 * word64) list =>
		       case x_944 of
			 ((w: 'a, i: int64, acc: (int64 * word64) list)) =>
			 case (((fn x_946: {eq: 'a * 'a -> bool,
					    isNeg: 'a -> bool,
					    neg: 'a -> 'a,
					    notb: 'a -> 'a,
					    rashift: 'a * word32 -> 'a,
					    rshift: 'a * word32 -> 'a,
					    sizeInBits: int32,
					    zero: 'a} =>
				 case x_946 of
				   {eq = #: 'a * 'a -> bool} => #) other) (w,
					((fn x_947: {eq: 'a * 'a -> bool,
						     isNeg: 'a -> bool,
						     neg: 'a -> 'a,
						     notb: 'a -> 'a,
						     rashift: 'a * word32 -> 'a,
						     rshift: 'a * word32 -> 'a,
						     sizeInBits: int32,
						     zero: 'a} =>
					  case x_947 of
					    {zero = #: 'a} => #) other))) of
			   true => (i, acc)
			 | false =>
			   let val limb: word64 = (zextdToMPLimb w)
			       val w: 'a =
				  (((fn x_945: {eq: 'a * 'a -> bool,
						isNeg: 'a -> bool,
						neg: 'a -> 'a,
						notb: 'a -> 'a,
						rashift: 'a * word32 -> 'a,
						rshift: 'a * word32 -> 'a,
						sizeInBits: int32,
						zero: 'a} =>
				     case x_945 of
				       {rshift = #: 'a * word32 -> 'a} => #) other) (w, sizeInBitsWord))
			   in
			      (loop (w,
				     (+ (i, 0x1)),
				     (::[int64 * word64] ((i, limb), acc))))
			   end)
		val (n: int64, acc: (int64 * word64) list) =
		   case case sextd of
			  true =>
			  (((fn x_943: {eq: 'a * 'a -> bool,
					isNeg: 'a -> bool,
					neg: 'a -> 'a,
					notb: 'a -> 'a,
					rashift: 'a * word32 -> 'a,
					rshift: 'a * word32 -> 'a,
					sizeInBits: int32,
					zero: 'a} =>
			     case x_943 of
			       {isNeg = #: 'a -> bool} => #) other) w)
			| false => false of
		     true =>
		     (loop ((((fn x_942: {eq: 'a * 'a -> bool,
					  isNeg: 'a -> bool,
					  neg: 'a -> 'a,
					  notb: 'a -> 'a,
					  rashift: 'a * word32 -> 'a,
					  rshift: 'a * word32 -> 'a,
					  sizeInBits: int32,
					  zero: 'a} =>
			       case x_942 of
				 {neg = #: 'a -> 'a} => #) other) w),
			    0x1,
			    [(0x0, 0x1)]))
		   | false => (loop (w, 0x1, [(0x0, 0x0)]))
		val a: word64 array = (arrayUnsafe (word64) n)
		val rec
		   loop: (int64 * word64) list -> unit = 
		      (fn x_941: (int64 * word64) list =>
		       case x_941 of
			 (acc: (int64 * word64) list) =>
			 case acc of
			   [] => ()
			 | ::[int64 * word64] ((i: int64, v: word64),
					       acc: (int64 * word64) list) =>
			   (updateUnsafe (word64) (a, i, v)) ;(loop acc))
		val () = (loop acc)
	    in
	       (fromVector (fromArrayUnsafe (word64) a))
	    end))
val rec
   extdFromWord8: bool * word8 -> intInf = 
      (fn x_954: bool * word8 =>
       case x_954 of
	 ((sextd: bool, w: word8)) =>
	 ((make (word8) {zextdToMPLimb = zextdFromWord8,
			 zextdToObjptrWord = zextdFromWord8,
			 sextdToObjptrWord = sextdFromWord8,
			 other = {sizeInBits = sizeInBits,
				  zero = zero,
				  eq = = (word8),
				  isNeg = (fn x_955: word8 =>
					   case x_955 of
					     w: word8 =>
					     (< ((idFromWord8ToInt8 w), 0x0))),
				  neg = ~,
				  notb = notb,
				  rashift = ~>>?,
				  rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord8: word8 -> intInf = 
      (fn x_956: word8 =>
       case x_956 of
	 (w: word8) => (extdFromWord8 (false, w)))
val rec
   zextdFromInt8: int8 -> intInf = 
      (fn x_957: int8 =>
       case x_957 of
	 (i: int8) => (zextdFromWord8 (idFromInt8ToWord8 i)))
val rec
   sextdFromWord8: word8 -> intInf = 
      (fn x_958: word8 =>
       case x_958 of
	 (w: word8) => (extdFromWord8 (true, w)))
val rec
   sextdFromInt8: int8 -> intInf = 
      (fn x_959: int8 =>
       case x_959 of
	 (i: int8) => (sextdFromWord8 (idFromInt8ToWord8 i)))
val castFromInt8: int8 -> intInf = sextdFromInt8
val castFromWord8: word8 -> intInf = zextdFromWord8
val zchckFromInt8: int8 -> intInf = zextdFromInt8
val zchckFromWord8: word8 -> intInf = zextdFromWord8
val schckFromInt8: int8 -> intInf = sextdFromInt8
val schckFromWord8: word8 -> intInf = sextdFromWord8
val rec
   extdFromWord16: bool * word16 -> intInf = 
      (fn x_960: bool * word16 =>
       case x_960 of
	 ((sextd: bool, w: word16)) =>
	 ((make (word16) {zextdToMPLimb = zextdFromWord16,
			  zextdToObjptrWord = zextdFromWord16,
			  sextdToObjptrWord = sextdFromWord16,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word16),
				   isNeg = (fn x_961: word16 =>
					    case x_961 of
					      w: word16 =>
					      (< ((idFromWord16ToInt16 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord16: word16 -> intInf = 
      (fn x_962: word16 =>
       case x_962 of
	 (w: word16) => (extdFromWord16 (false, w)))
val rec
   zextdFromInt16: int16 -> intInf = 
      (fn x_963: int16 =>
       case x_963 of
	 (i: int16) => (zextdFromWord16 (idFromInt16ToWord16 i)))
val rec
   sextdFromWord16: word16 -> intInf = 
      (fn x_964: word16 =>
       case x_964 of
	 (w: word16) => (extdFromWord16 (true, w)))
val rec
   sextdFromInt16: int16 -> intInf = 
      (fn x_965: int16 =>
       case x_965 of
	 (i: int16) => (sextdFromWord16 (idFromInt16ToWord16 i)))
val castFromInt16: int16 -> intInf = sextdFromInt16
val castFromWord16: word16 -> intInf = zextdFromWord16
val zchckFromInt16: int16 -> intInf = zextdFromInt16
val zchckFromWord16: word16 -> intInf = zextdFromWord16
val schckFromInt16: int16 -> intInf = sextdFromInt16
val schckFromWord16: word16 -> intInf = sextdFromWord16
val rec
   extdFromWord32: bool * word32 -> intInf = 
      (fn x_966: bool * word32 =>
       case x_966 of
	 ((sextd: bool, w: word32)) =>
	 ((make (word32) {zextdToMPLimb = zextdFromWord32,
			  zextdToObjptrWord = zextdFromWord32,
			  sextdToObjptrWord = sextdFromWord32,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word32),
				   isNeg = (fn x_967: word32 =>
					    case x_967 of
					      w: word32 =>
					      (< ((idFromWord32ToInt32 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord32: word32 -> intInf = 
      (fn x_968: word32 =>
       case x_968 of
	 (w: word32) => (extdFromWord32 (false, w)))
val rec
   zextdFromInt32: int32 -> intInf = 
      (fn x_969: int32 =>
       case x_969 of
	 (i: int32) => (zextdFromWord32 (idFromInt32ToWord32 i)))
val rec
   sextdFromWord32: word32 -> intInf = 
      (fn x_970: word32 =>
       case x_970 of
	 (w: word32) => (extdFromWord32 (true, w)))
val rec
   sextdFromInt32: int32 -> intInf = 
      (fn x_971: int32 =>
       case x_971 of
	 (i: int32) => (sextdFromWord32 (idFromInt32ToWord32 i)))
val castFromInt32: int32 -> intInf = sextdFromInt32
val castFromWord32: word32 -> intInf = zextdFromWord32
val zchckFromInt32: int32 -> intInf = zextdFromInt32
val zchckFromWord32: word32 -> intInf = zextdFromWord32
val schckFromInt32: int32 -> intInf = sextdFromInt32
val schckFromWord32: word32 -> intInf = sextdFromWord32
val rec
   extdFromWord64: bool * word64 -> intInf = 
      (fn x_972: bool * word64 =>
       case x_972 of
	 ((sextd: bool, w: word64)) =>
	 ((make (word64) {zextdToMPLimb = zextdFromWord64,
			  zextdToObjptrWord = zextdFromWord64,
			  sextdToObjptrWord = sextdFromWord64,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word64),
				   isNeg = (fn x_973: word64 =>
					    case x_973 of
					      w: word64 =>
					      (< ((idFromWord64ToInt64 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord64: word64 -> intInf = 
      (fn x_974: word64 =>
       case x_974 of
	 (w: word64) => (extdFromWord64 (false, w)))
val rec
   zextdFromInt64: int64 -> intInf = 
      (fn x_975: int64 =>
       case x_975 of
	 (i: int64) => (zextdFromWord64 (idFromInt64ToWord64 i)))
val rec
   sextdFromWord64: word64 -> intInf = 
      (fn x_976: word64 =>
       case x_976 of
	 (w: word64) => (extdFromWord64 (true, w)))
val rec
   sextdFromInt64: int64 -> intInf = 
      (fn x_977: int64 =>
       case x_977 of
	 (i: int64) => (sextdFromWord64 (idFromInt64ToWord64 i)))
val castFromInt64: int64 -> intInf = sextdFromInt64
val castFromWord64: word64 -> intInf = zextdFromWord64
val zchckFromInt64: int64 -> intInf = zextdFromInt64
val zchckFromWord64: word64 -> intInf = zextdFromWord64
val schckFromInt64: int64 -> intInf = sextdFromInt64
val schckFromWord64: word64 -> intInf = sextdFromWord64
val rec 'a_353
   zextdFromIntInf: 'a_353 -> 'a_353 = 
      (fn x_978: 'a_353 =>
       case x_978 of
	 (ii: 'a_353) => ii)
val rec 'a_354
   sextdFromIntInf: 'a_354 -> 'a_354 = 
      (fn x_979: 'a_354 =>
       case x_979 of
	 (ii: 'a_354) => ii)
val rec 'a_355
   castFromIntInf: 'a_355 -> 'a_355 = 
      (fn x_980: 'a_355 =>
       case x_980 of
	 (ii: 'a_355) => ii)
val rec 'a_356
   zchckFromIntInf: 'a_356 -> 'a_356 = 
      (fn x_981: 'a_356 =>
       case x_981 of
	 (ii: 'a_356) => ii)
val rec 'a_357
   schckFromIntInf: 'a_357 -> 'a_357 = 
      (fn x_982: 'a_357 =>
       case x_982 of
	 (ii: 'a_357) => ii)
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val fInt64: int64 -> intInf = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> intInf = fInt64
val sextdFromObjptrInt: int64 -> intInf = f
datatype 'a Primitive.IntInf.ans = Big of bool * bool * 'a
				   | Small of word64
val rec 'a
   make: {other: {lshift: 'a * word32 -> 'a,
		  orb: 'a * 'a -> 'a,
		  sizeInBits: int32,
		  sizeInBitsWord: word32,
		  zero: 'a},
	  zextdFromMPLimb: word64 -> 'a}
	 -> intInf -> 'a Primitive.IntInf.ans = 
      (fn x_983: {other: {lshift: 'a * word32 -> 'a,
			  orb: 'a * 'a -> 'a,
			  sizeInBits: int32,
			  sizeInBitsWord: word32,
			  zero: 'a},
		  zextdFromMPLimb: word64 -> 'a} =>
       (fn x_984: intInf =>
	case (x_983, x_984) of
	  ({zextdFromMPLimb = zextdFromMPLimb: word64 -> 'a,
	    other = other: {lshift: 'a * word32 -> 'a,
			    orb: 'a * 'a -> 'a,
			    sizeInBits: int32,
			    sizeInBitsWord: word32,
			    zero: 'a}},
	   i: intInf) =>
	  case (isSmall i) of
	    true => (Small['a] (dropTagCoerce i))
	  | false =>
	    let val v: word64 vector = (toVector i)
		val n: int64 = (length (word64) v)
		val isneg: bool =
		   (<> (word64) ((subUnsafe (word64) (v, 0x0)), 0x0))
	    in
	       case (>= (sizeInBits,
			 ((fn x_991: {lshift: 'a * word32 -> 'a,
				      orb: 'a * 'a -> 'a,
				      sizeInBits: int32,
				      sizeInBitsWord: word32,
				      zero: 'a} =>
			   case x_991 of
			     {sizeInBits = #: int32} => #) other))) of
		 true =>
		 let val limbsPer: int64 = 0x1
		     val limb: word64 = (subUnsafe (word64) (v, 0x1))
		     val extra: bool =
			case (> (n, (+ (limbsPer, 0x1)))) of
			  true => true
			| false =>
			  (<> (word64) ((>>? (limb,
					      ((fn x_985: {lshift: 'a * word32
								   -> 'a,
							   orb: 'a * 'a -> 'a,
							   sizeInBits: int32,
							   sizeInBitsWord: word32,
							   zero: 'a} =>
						case x_985 of
						  {sizeInBitsWord = #: word32} =>
						  #) other))),
					0x0))
		     val ans: 'a = (zextdFromMPLimb limb)
		 in
		    (Big['a] (isneg, extra, ans))
		 end
	       | false =>
		 let val limbsPer: int64 =
			(sextdFromInt32 (quot (((fn x_990: {lshift: 'a * word32
								    -> 'a,
							    orb: 'a * 'a -> 'a,
							    sizeInBits: int32,
							    sizeInBitsWord: word32,
							    zero: 'a} =>
						 case x_990 of
						   {sizeInBits = #: int32} => #) other),
					       sizeInBits)))
		     val extra: bool = (> (n, (+ (limbsPer, 0x1))))
		     val ans: 'a =
			let val rec
			       loop: int64 * 'a -> 'a = 
				  (fn x_986: int64 * 'a =>
				   case x_986 of
				     ((i: int64, ans: 'a)) =>
				     case (> (i, 0x0)) of
				       true =>
				       let val limb: word64 =
					      (subUnsafe (word64) (v, i))
					   val ans: 'a =
					      (((fn x_987: {lshift: 'a * word32
								    -> 'a,
							    orb: 'a * 'a -> 'a,
							    sizeInBits: int32,
							    sizeInBitsWord: word32,
							    zero: 'a} =>
						 case x_987 of
						   {orb = #: 'a * 'a -> 'a} => #) other) ((((fn x_988: {lshift: 'a * word32 -> 'a,
						     orb: 'a * 'a -> 'a,
						     sizeInBits: int32,
						     sizeInBitsWord: word32,
						     zero: 'a} =>
					  case x_988 of
					    {lshift = #: 'a * word32 -> 'a} => #) other) (ans, sizeInBitsWord)),
				       (zextdFromMPLimb limb)))
				       in
					  (loop ((- (i, 0x1)), ans))
				       end
				     | false => ans)
			in
			   (loop ((min ((- (n, 0x1)), limbsPer)),
				  ((fn x_989: {lshift: 'a * word32 -> 'a,
					       orb: 'a * 'a -> 'a,
					       sizeInBits: int32,
					       sizeInBitsWord: word32,
					       zero: 'a} =>
				    case x_989 of
				      {zero = #: 'a} => #) other)))
			end
		 in
		    (Big['a] (isneg, extra, ans))
		 end
	    end))
val chckToWord8Aux: intInf -> word8 Primitive.IntInf.ans =
   (make (word8) {zextdFromMPLimb = zextdToWord8,
		  other = {sizeInBits = sizeInBits,
			   sizeInBitsWord = sizeInBitsWord,
			   zero = zero,
			   lshift = <<?,
			   orb = orb}})
val rec
   sextdToWord8: intInf -> word8 = 
      (fn x_992: intInf =>
       case x_992 of
	 (i: intInf) =>
	 case (chckToWord8Aux i) of
	   Small[word8] w: word64 => (sextdToWord8 w)
	 | Big[word8] (isneg: bool, _, ans: word8) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt8: intInf -> int8 = 
      (fn x_993: intInf =>
       case x_993 of
	 (i: intInf) => (idFromWord8ToInt8 (sextdToWord8 i)))
val zextdToWord8: intInf -> word8 = sextdToWord8
val rec
   zextdToInt8: intInf -> int8 = 
      (fn x_994: intInf =>
       case x_994 of
	 (i: intInf) => (idFromWord8ToInt8 (zextdToWord8 i)))
val castToWord8: intInf -> word8 = sextdToWord8
val castToInt8: intInf -> int8 = sextdToInt8
val rec
   schckToWord8: intInf -> word8 = 
      (fn x_995: intInf =>
       case x_995 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord8 i)
	 | false =>
	   case (chckToWord8Aux i) of
	     Small[word8] w: word64 => (schckToWord8 w)
	   | Big[word8] (isneg: bool, extra: bool, ans: word8) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word8 = (~ ans)
		     val ans': int8 = (idFromWord8ToInt8 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int8 = (idFromWord8ToInt8 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt8: intInf -> int8 = 
      (fn x_996: intInf =>
       case x_996 of
	 (i: intInf) => (idFromWord8ToInt8 (schckToWord8 i)))
val rec
   zchckToWord8: intInf -> word8 = 
      (fn x_997: intInf =>
       case x_997 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord8 i)
	 | false =>
	   case (chckToWord8Aux i) of
	     Small[word8] w: word64 => (schckToWord8 w)
	   | Big[word8] (isneg: bool, extra: bool, ans: word8) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt8: intInf -> int8 = 
      (fn x_998: intInf =>
       case x_998 of
	 (i: intInf) => (idFromWord8ToInt8 (zchckToWord8 i)))
val chckToWord16Aux: intInf -> word16 Primitive.IntInf.ans =
   (make (word16) {zextdFromMPLimb = zextdToWord16,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord16: intInf -> word16 = 
      (fn x_999: intInf =>
       case x_999 of
	 (i: intInf) =>
	 case (chckToWord16Aux i) of
	   Small[word16] w: word64 => (sextdToWord16 w)
	 | Big[word16] (isneg: bool, _, ans: word16) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt16: intInf -> int16 = 
      (fn x_1000: intInf =>
       case x_1000 of
	 (i: intInf) => (idFromWord16ToInt16 (sextdToWord16 i)))
val zextdToWord16: intInf -> word16 = sextdToWord16
val rec
   zextdToInt16: intInf -> int16 = 
      (fn x_1001: intInf =>
       case x_1001 of
	 (i: intInf) => (idFromWord16ToInt16 (zextdToWord16 i)))
val castToWord16: intInf -> word16 = sextdToWord16
val castToInt16: intInf -> int16 = sextdToInt16
val rec
   schckToWord16: intInf -> word16 = 
      (fn x_1002: intInf =>
       case x_1002 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord16 i)
	 | false =>
	   case (chckToWord16Aux i) of
	     Small[word16] w: word64 => (schckToWord16 w)
	   | Big[word16] (isneg: bool, extra: bool, ans: word16) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word16 = (~ ans)
		     val ans': int16 = (idFromWord16ToInt16 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int16 = (idFromWord16ToInt16 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt16: intInf -> int16 = 
      (fn x_1003: intInf =>
       case x_1003 of
	 (i: intInf) => (idFromWord16ToInt16 (schckToWord16 i)))
val rec
   zchckToWord16: intInf -> word16 = 
      (fn x_1004: intInf =>
       case x_1004 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord16 i)
	 | false =>
	   case (chckToWord16Aux i) of
	     Small[word16] w: word64 => (schckToWord16 w)
	   | Big[word16] (isneg: bool, extra: bool, ans: word16) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt16: intInf -> int16 = 
      (fn x_1005: intInf =>
       case x_1005 of
	 (i: intInf) => (idFromWord16ToInt16 (zchckToWord16 i)))
val chckToWord32Aux: intInf -> word32 Primitive.IntInf.ans =
   (make (word32) {zextdFromMPLimb = zextdToWord32,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord32: intInf -> word32 = 
      (fn x_1006: intInf =>
       case x_1006 of
	 (i: intInf) =>
	 case (chckToWord32Aux i) of
	   Small[word32] w: word64 => (sextdToWord32 w)
	 | Big[word32] (isneg: bool, _, ans: word32) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt32: intInf -> int32 = 
      (fn x_1007: intInf =>
       case x_1007 of
	 (i: intInf) => (idFromWord32ToInt32 (sextdToWord32 i)))
val zextdToWord32: intInf -> word32 = sextdToWord32
val rec
   zextdToInt32: intInf -> int32 = 
      (fn x_1008: intInf =>
       case x_1008 of
	 (i: intInf) => (idFromWord32ToInt32 (zextdToWord32 i)))
val castToWord32: intInf -> word32 = sextdToWord32
val castToInt32: intInf -> int32 = sextdToInt32
val rec
   schckToWord32: intInf -> word32 = 
      (fn x_1009: intInf =>
       case x_1009 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord32 i)
	 | false =>
	   case (chckToWord32Aux i) of
	     Small[word32] w: word64 => (schckToWord32 w)
	   | Big[word32] (isneg: bool, extra: bool, ans: word32) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word32 = (~ ans)
		     val ans': int32 = (idFromWord32ToInt32 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int32 = (idFromWord32ToInt32 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt32: intInf -> int32 = 
      (fn x_1010: intInf =>
       case x_1010 of
	 (i: intInf) => (idFromWord32ToInt32 (schckToWord32 i)))
val rec
   zchckToWord32: intInf -> word32 = 
      (fn x_1011: intInf =>
       case x_1011 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord32 i)
	 | false =>
	   case (chckToWord32Aux i) of
	     Small[word32] w: word64 => (schckToWord32 w)
	   | Big[word32] (isneg: bool, extra: bool, ans: word32) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt32: intInf -> int32 = 
      (fn x_1012: intInf =>
       case x_1012 of
	 (i: intInf) => (idFromWord32ToInt32 (zchckToWord32 i)))
val chckToWord64Aux: intInf -> word64 Primitive.IntInf.ans =
   (make (word64) {zextdFromMPLimb = zextdToWord64,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord64: intInf -> word64 = 
      (fn x_1013: intInf =>
       case x_1013 of
	 (i: intInf) =>
	 case (chckToWord64Aux i) of
	   Small[word64] w: word64 => (sextdToWord64 w)
	 | Big[word64] (isneg: bool, _, ans: word64) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt64: intInf -> int64 = 
      (fn x_1014: intInf =>
       case x_1014 of
	 (i: intInf) => (idFromWord64ToInt64 (sextdToWord64 i)))
val zextdToWord64: intInf -> word64 = sextdToWord64
val rec
   zextdToInt64: intInf -> int64 = 
      (fn x_1015: intInf =>
       case x_1015 of
	 (i: intInf) => (idFromWord64ToInt64 (zextdToWord64 i)))
val castToWord64: intInf -> word64 = sextdToWord64
val castToInt64: intInf -> int64 = sextdToInt64
val rec
   schckToWord64: intInf -> word64 = 
      (fn x_1016: intInf =>
       case x_1016 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord64 i)
	 | false =>
	   case (chckToWord64Aux i) of
	     Small[word64] w: word64 => (schckToWord64 w)
	   | Big[word64] (isneg: bool, extra: bool, ans: word64) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word64 = (~ ans)
		     val ans': int64 = (idFromWord64ToInt64 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int64 = (idFromWord64ToInt64 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt64: intInf -> int64 = 
      (fn x_1017: intInf =>
       case x_1017 of
	 (i: intInf) => (idFromWord64ToInt64 (schckToWord64 i)))
val rec
   zchckToWord64: intInf -> word64 = 
      (fn x_1018: intInf =>
       case x_1018 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord64 i)
	 | false =>
	   case (chckToWord64Aux i) of
	     Small[word64] w: word64 => (schckToWord64 w)
	   | Big[word64] (isneg: bool, extra: bool, ans: word64) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt64: intInf -> int64 = 
      (fn x_1019: intInf =>
       case x_1019 of
	 (i: intInf) => (idFromWord64ToInt64 (zchckToWord64 i)))
val rec 'a_360
   zextdToIntInf: 'a_360 -> 'a_360 = 
      (fn x_1020: 'a_360 =>
       case x_1020 of
	 (ii: 'a_360) => ii)
val rec 'a_361
   sextdToIntInf: 'a_361 -> 'a_361 = 
      (fn x_1021: 'a_361 =>
       case x_1021 of
	 (ii: 'a_361) => ii)
val rec 'a_362
   castToIntInf: 'a_362 -> 'a_362 = 
      (fn x_1022: 'a_362 =>
       case x_1022 of
	 (ii: 'a_362) => ii)
val rec 'a_363
   zchckToIntInf: 'a_363 -> 'a_363 = 
      (fn x_1023: 'a_363 =>
       case x_1023 of
	 (ii: 'a_363) => ii)
val rec 'a_364
   schckToIntInf: 'a_364 -> 'a_364 = 
      (fn x_1024: 'a_364 =>
       case x_1024 of
	 (ii: 'a_364) => ii)
val bytesPerMPLimb: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerCounter: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerLength: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerHeader: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerArrayHeader: word64 =
   (+ (bytesPerCounter, (+ (bytesPerLength, bytesPerHeader))))
val rec
   reserve: int64 * int64 -> word64 = 
      (fn x_1025: int64 * int64 =>
       case x_1025 of
	 ((num: int64, extra: int64)) =>
	 (+ ((* (bytesPerMPLimb, (zextdFromSeqIndex num))),
	     (+ ((* (bytesPerMPLimb, (zextdFromSeqIndex extra))),
		 (+ (bytesPerMPLimb,
		     (+ (bytesPerArrayHeader,
			 case align of
			   Align4 => 0x3 | Align8 => 0x7)))))))))
val badObjptrInt: int64 = (~>>? (minInt', 0x1))
val badObjptrWord: word64 = (idFromObjptrInt badObjptrInt)
val badObjptrWordTagged: word64 = (addTag badObjptrWord)
val negBadIntInf: intInf = (sextdFromObjptrInt (~ badObjptrInt))
val rec
   sameSignBit: word64 * word64 -> bool = 
      (fn x_1026: word64 * word64 =>
       case x_1026 of
	 ((lhs: word64, rhs: word64)) =>
	 (>= ((idToObjptrInt (xorb (lhs, rhs))), 0x0)))
val rec
   make: (int64 * int64 -> int64)
	 * (intInf * intInf * word64 -> intInf)
	 * (int64 * int64 -> int64)
	 * int64
	 -> intInf * intInf -> intInf = 
      (fn x_1027: (int64 * int64 -> int64)
		  * (intInf * intInf * word64 -> intInf)
		  * (int64 * int64 -> int64)
		  * int64 =>
       (fn x_1028: intInf * intInf =>
	case (x_1027, x_1028) of
	  ((smallOp: int64 * int64 -> int64,
	    bigOp: intInf * intInf * word64 -> intInf,
	    limbsFn: int64 * int64 -> int64,
	    extra: int64),
	   (lhs: intInf, rhs: intInf)) =>
	  let val res: intInf Primitive.Option.t =
		 case (areSmall (lhs, rhs)) of
		   true =>
		   let val lhsw: word64 = (dropTagCoerce lhs)
		       val lhsi: int64 = (idToObjptrInt lhsw)
		       val rhsw: word64 = (dropTagCoerce rhs)
		       val rhsi: int64 = (idToObjptrInt rhsw)
		       val ansi: int64 = (smallOp (lhsi, rhsi))
		       val answ: word64 = (idFromObjptrInt ansi)
		       val ans: word64 = (addTag answ)
		   in
		      case (sameSignBit (ans, answ)) of
			true => (SOME[intInf] (fromWord ans))
		      | false => NONE[intInf]
		   end
		   handle x_1029 => case x_1029 of
				      Overflow => NONE[intInf]
		 | false => NONE[intInf]
	  in
	     case res of
	       NONE[intInf] =>
	       (bigOp (lhs,
		       rhs,
		       (reserve ((limbsFn ((numLimbs lhs), (numLimbs rhs))),
				 extra))))
	     | SOME[intInf] i: intInf => i
	  end))
val bigAdd: intInf * intInf -> intInf = (make (+!, +, max, 0x1))
val bigMul: intInf * intInf -> intInf = (make (*!, *, +, 0x0))
val rec
   bigNeg: intInf -> intInf = 
      (fn x_1030: intInf =>
       case x_1030 of
	 (arg: intInf) =>
	 case (isSmall arg) of
	   true =>
	   let val argw: word64 = (toWord arg)
	   in
	      case (= (word64) (argw, badObjptrWordTagged)) of
		true => negBadIntInf | false => (fromWord (- (0x2, argw)))
	   end
	 | false => (~ (arg, (reserve ((numLimbs arg), 0x1)))))
val rec
   bigQuot: intInf * intInf -> intInf = 
      (fn x_1031: intInf * intInf =>
       case x_1031 of
	 ((num: intInf, den: intInf)) =>
	 case (areSmall (num, den)) of
	   true =>
	   let val numw: word64 = (dropTagCoerce num)
	       val numi: int64 = (idToObjptrInt numw)
	       val denw: word64 = (dropTagCoerce den)
	       val deni: int64 = (idToObjptrInt denw)
	   in
	      case case (= (word64) (numw, badObjptrWord)) of
		     true => (= (int64) (deni, 0xFFFFFFFFFFFFFFFF))
		   | false => false of
		true => negBadIntInf
	      | false =>
		let val ansi: int64 = (quot (numi, deni))
		    val answ: word64 = (idFromObjptrInt ansi)
		    val ans: word64 = (addTag answ)
		in
		   (fromWord ans)
		end
	   end
	 | false =>
	   let val nlimbs: int64 = (numLimbs num)
	       val dlimbs: int64 = (numLimbs den)
	   in
	      case (< (nlimbs, dlimbs)) of
		true => zero
	      | false =>
		case (= (intInf) (den, zero)) of
		  true => raise Div
		| false =>
		  (quot (num, den, (reserve ((- (nlimbs, dlimbs)), 0x2))))
	   end)
val rec 'a
   make: (int64 * int64 -> 'a) * (int32 * int32 -> 'a) -> intInf * intInf -> 'a = 
      (fn x_1032: (int64 * int64 -> 'a) * (int32 * int32 -> 'a) =>
       (fn x_1033: intInf * intInf =>
	case (x_1032, x_1033) of
	  ((smallTest: int64 * int64 -> 'a, int32Test: int32 * int32 -> 'a),
	   (lhs: intInf, rhs: intInf)) =>
	  case (areSmall (lhs, rhs)) of
	    true =>
	    (smallTest ((idToObjptrInt (toWord lhs)),
			(idToObjptrInt (toWord rhs))))
	  | false => (int32Test ((compare (lhs, rhs)), 0x0))))
val bigLT: intInf * intInf -> bool = (make (bool) (<, <))
val rec
   mkBigCvt: {base: int32, smallCvt: int64 -> string} -> intInf -> string = 
      (fn x_1034: {base: int32, smallCvt: int64 -> string} =>
       (fn x_1035: intInf =>
	case (x_1034, x_1035) of
	  ({base = base: int32, smallCvt = smallCvt: int64 -> string},
	   arg: intInf) =>
	  case (isSmall arg) of
	    true => (smallCvt (dropTagCoerceInt arg))
	  | false =>
	    let val bpd: int32 = (log2 base)
		val bpl: int32 = sizeInBits
		val dpl: int32 =
		   (+ ((quot (bpl, bpd)),
		       case (= (int32) ((mod (bpl, bpd)), 0x0)) of
			 true => 0x0 | false => 0x1))
		val bytes: word64 =
		   (+ ((+ (bytesPerArrayHeader,
			   (+ (0x1, case align of Align4 => 0x3 | Align8 => 0x7)))),
		       (* ((zextdFromInt32 dpl),
			   (zextdFromSeqIndex (numLimbs arg))))))
	    in
	       (toString (arg, base, bytes))
	    end))
val addTagCoerce: word64 -> intInf = addTagCoerce
val +: intInf * intInf -> intInf = bigAdd
val *: intInf * intInf -> intInf = bigMul
val ~: intInf -> intInf = bigNeg
val quot: intInf * intInf -> intInf = bigQuot
val <: intInf * intInf -> bool = bigLT
val mkCvt: {base: int32, smallCvt: int64 -> string} -> intInf -> string =
   mkBigCvt
val zextdFromInt8ToIntInf: int8 -> intInf = zextdFromInt8
val zextdFromInt16ToIntInf: int16 -> intInf = zextdFromInt16
val zextdFromInt32ToIntInf: int32 -> intInf = zextdFromInt32
val zextdFromInt64ToIntInf: int64 -> intInf = zextdFromInt64
val zextdFromWord8ToIntInf: word8 -> intInf = zextdFromWord8
val zextdFromWord16ToIntInf: word16 -> intInf = zextdFromWord16
val zextdFromWord32ToIntInf: word32 -> intInf = zextdFromWord32
val zextdFromWord64ToIntInf: word64 -> intInf = zextdFromWord64
val zextdFromIntInfToInt8: intInf -> int8 = zextdToInt8
val zextdFromIntInfToInt16: intInf -> int16 = zextdToInt16
val zextdFromIntInfToInt32: intInf -> int32 = zextdToInt32
val zextdFromIntInfToInt64: intInf -> int64 = zextdToInt64
val zextdFromIntInfToWord8: intInf -> word8 = zextdToWord8
val zextdFromIntInfToWord16: intInf -> word16 = zextdToWord16
val zextdFromIntInfToWord32: intInf -> word32 = zextdToWord32
val zextdFromIntInfToWord64: intInf -> word64 = zextdToWord64
val sextdFromInt8ToIntInf: int8 -> intInf = sextdFromInt8
val sextdFromInt16ToIntInf: int16 -> intInf = sextdFromInt16
val sextdFromInt32ToIntInf: int32 -> intInf = sextdFromInt32
val sextdFromInt64ToIntInf: int64 -> intInf = sextdFromInt64
val sextdFromWord8ToIntInf: word8 -> intInf = sextdFromWord8
val sextdFromWord16ToIntInf: word16 -> intInf = sextdFromWord16
val sextdFromWord32ToIntInf: word32 -> intInf = sextdFromWord32
val sextdFromWord64ToIntInf: word64 -> intInf = sextdFromWord64
val sextdFromIntInfToInt8: intInf -> int8 = sextdToInt8
val sextdFromIntInfToInt16: intInf -> int16 = sextdToInt16
val sextdFromIntInfToInt32: intInf -> int32 = sextdToInt32
val sextdFromIntInfToInt64: intInf -> int64 = sextdToInt64
val sextdFromIntInfToWord8: intInf -> word8 = sextdToWord8
val sextdFromIntInfToWord16: intInf -> word16 = sextdToWord16
val sextdFromIntInfToWord32: intInf -> word32 = sextdToWord32
val sextdFromIntInfToWord64: intInf -> word64 = sextdToWord64
val castFromInt8ToIntInf: int8 -> intInf = castFromInt8
val castFromInt16ToIntInf: int16 -> intInf = castFromInt16
val castFromInt32ToIntInf: int32 -> intInf = castFromInt32
val castFromInt64ToIntInf: int64 -> intInf = castFromInt64
val castFromWord8ToIntInf: word8 -> intInf = castFromWord8
val castFromWord16ToIntInf: word16 -> intInf = castFromWord16
val castFromWord32ToIntInf: word32 -> intInf = castFromWord32
val castFromWord64ToIntInf: word64 -> intInf = castFromWord64
val castFromIntInfToInt8: intInf -> int8 = castToInt8
val castFromIntInfToInt16: intInf -> int16 = castToInt16
val castFromIntInfToInt32: intInf -> int32 = castToInt32
val castFromIntInfToInt64: intInf -> int64 = castToInt64
val castFromIntInfToWord8: intInf -> word8 = castToWord8
val castFromIntInfToWord16: intInf -> word16 = castToWord16
val castFromIntInfToWord32: intInf -> word32 = castToWord32
val castFromIntInfToWord64: intInf -> word64 = castToWord64
val zchckFromInt8ToIntInf: int8 -> intInf = zchckFromInt8
val zchckFromInt16ToIntInf: int16 -> intInf = zchckFromInt16
val zchckFromInt32ToIntInf: int32 -> intInf = zchckFromInt32
val zchckFromInt64ToIntInf: int64 -> intInf = zchckFromInt64
val zchckFromWord8ToIntInf: word8 -> intInf = zchckFromWord8
val zchckFromWord16ToIntInf: word16 -> intInf = zchckFromWord16
val zchckFromWord32ToIntInf: word32 -> intInf = zchckFromWord32
val zchckFromWord64ToIntInf: word64 -> intInf = zchckFromWord64
val zchckFromIntInfToInt8: intInf -> int8 = zchckToInt8
val zchckFromIntInfToInt16: intInf -> int16 = zchckToInt16
val zchckFromIntInfToInt32: intInf -> int32 = zchckToInt32
val zchckFromIntInfToInt64: intInf -> int64 = zchckToInt64
val zchckFromIntInfToWord8: intInf -> word8 = zchckToWord8
val zchckFromIntInfToWord16: intInf -> word16 = zchckToWord16
val zchckFromIntInfToWord32: intInf -> word32 = zchckToWord32
val zchckFromIntInfToWord64: intInf -> word64 = zchckToWord64
val schckFromInt8ToIntInf: int8 -> intInf = schckFromInt8
val schckFromInt16ToIntInf: int16 -> intInf = schckFromInt16
val schckFromInt32ToIntInf: int32 -> intInf = schckFromInt32
val schckFromInt64ToIntInf: int64 -> intInf = schckFromInt64
val schckFromWord8ToIntInf: word8 -> intInf = schckFromWord8
val schckFromWord16ToIntInf: word16 -> intInf = schckFromWord16
val schckFromWord32ToIntInf: word32 -> intInf = schckFromWord32
val schckFromWord64ToIntInf: word64 -> intInf = schckFromWord64
val schckFromIntInfToInt8: intInf -> int8 = schckToInt8
val schckFromIntInfToInt16: intInf -> int16 = schckToInt16
val schckFromIntInfToInt32: intInf -> int32 = schckToInt32
val schckFromIntInfToInt64: intInf -> int64 = schckToInt64
val schckFromIntInfToWord8: intInf -> word8 = schckToWord8
val schckFromIntInfToWord16: intInf -> word16 = schckToWord16
val schckFromIntInfToWord32: intInf -> word32 = schckToWord32
val schckFromIntInfToWord64: intInf -> word64 = schckToWord64
val zextdFromIntInf: intInf -> int8 = zextdFromIntInfToInt8
val zextdToIntInf: int8 -> intInf = zextdFromInt8ToIntInf
val sextdFromIntInf: intInf -> int8 = sextdFromIntInfToInt8
val sextdToIntInf: int8 -> intInf = sextdFromInt8ToIntInf
val castFromIntInf: intInf -> int8 = castFromIntInfToInt8
val castToIntInf: int8 -> intInf = castFromInt8ToIntInf
val zchckFromIntInf: intInf -> int8 = zchckFromIntInfToInt8
val zchckToIntInf: int8 -> intInf = zchckFromInt8ToIntInf
val schckFromIntInf: intInf -> int8 = schckFromIntInfToInt8
val schckToIntInf: int8 -> intInf = schckFromInt8ToIntInf
val zextdFromIntInf: intInf -> int16 = zextdFromIntInfToInt16
val zextdToIntInf: int16 -> intInf = zextdFromInt16ToIntInf
val sextdFromIntInf: intInf -> int16 = sextdFromIntInfToInt16
val sextdToIntInf: int16 -> intInf = sextdFromInt16ToIntInf
val castFromIntInf: intInf -> int16 = castFromIntInfToInt16
val castToIntInf: int16 -> intInf = castFromInt16ToIntInf
val zchckFromIntInf: intInf -> int16 = zchckFromIntInfToInt16
val zchckToIntInf: int16 -> intInf = zchckFromInt16ToIntInf
val schckFromIntInf: intInf -> int16 = schckFromIntInfToInt16
val schckToIntInf: int16 -> intInf = schckFromInt16ToIntInf
val zextdFromIntInf: intInf -> int32 = zextdFromIntInfToInt32
val zextdToIntInf: int32 -> intInf = zextdFromInt32ToIntInf
val sextdFromIntInf: intInf -> int32 = sextdFromIntInfToInt32
val sextdToIntInf: int32 -> intInf = sextdFromInt32ToIntInf
val castFromIntInf: intInf -> int32 = castFromIntInfToInt32
val castToIntInf: int32 -> intInf = castFromInt32ToIntInf
val zchckFromIntInf: intInf -> int32 = zchckFromIntInfToInt32
val zchckToIntInf: int32 -> intInf = zchckFromInt32ToIntInf
val schckFromIntInf: intInf -> int32 = schckFromIntInfToInt32
val schckToIntInf: int32 -> intInf = schckFromInt32ToIntInf
val zextdFromIntInf: intInf -> int64 = zextdFromIntInfToInt64
val zextdToIntInf: int64 -> intInf = zextdFromInt64ToIntInf
val sextdFromIntInf: intInf -> int64 = sextdFromIntInfToInt64
val sextdToIntInf: int64 -> intInf = sextdFromInt64ToIntInf
val castFromIntInf: intInf -> int64 = castFromIntInfToInt64
val castToIntInf: int64 -> intInf = castFromInt64ToIntInf
val zchckFromIntInf: intInf -> int64 = zchckFromIntInfToInt64
val zchckToIntInf: int64 -> intInf = zchckFromInt64ToIntInf
val schckFromIntInf: intInf -> int64 = schckFromIntInfToInt64
val schckToIntInf: int64 -> intInf = schckFromInt64ToIntInf
val zextdFromIntInf: intInf -> word8 = zextdFromIntInfToWord8
val zextdToIntInf: word8 -> intInf = zextdFromWord8ToIntInf
val sextdFromIntInf: intInf -> word8 = sextdFromIntInfToWord8
val sextdToIntInf: word8 -> intInf = sextdFromWord8ToIntInf
val castFromIntInf: intInf -> word8 = castFromIntInfToWord8
val castToIntInf: word8 -> intInf = castFromWord8ToIntInf
val zchckFromIntInf: intInf -> word8 = zchckFromIntInfToWord8
val zchckToIntInf: word8 -> intInf = zchckFromWord8ToIntInf
val schckFromIntInf: intInf -> word8 = schckFromIntInfToWord8
val schckToIntInf: word8 -> intInf = schckFromWord8ToIntInf
val zextdFromIntInf: intInf -> word16 = zextdFromIntInfToWord16
val zextdToIntInf: word16 -> intInf = zextdFromWord16ToIntInf
val sextdFromIntInf: intInf -> word16 = sextdFromIntInfToWord16
val sextdToIntInf: word16 -> intInf = sextdFromWord16ToIntInf
val castFromIntInf: intInf -> word16 = castFromIntInfToWord16
val castToIntInf: word16 -> intInf = castFromWord16ToIntInf
val zchckFromIntInf: intInf -> word16 = zchckFromIntInfToWord16
val zchckToIntInf: word16 -> intInf = zchckFromWord16ToIntInf
val schckFromIntInf: intInf -> word16 = schckFromIntInfToWord16
val schckToIntInf: word16 -> intInf = schckFromWord16ToIntInf
val zextdFromIntInf: intInf -> word32 = zextdFromIntInfToWord32
val zextdToIntInf: word32 -> intInf = zextdFromWord32ToIntInf
val sextdFromIntInf: intInf -> word32 = sextdFromIntInfToWord32
val sextdToIntInf: word32 -> intInf = sextdFromWord32ToIntInf
val castFromIntInf: intInf -> word32 = castFromIntInfToWord32
val castToIntInf: word32 -> intInf = castFromWord32ToIntInf
val zchckFromIntInf: intInf -> word32 = zchckFromIntInfToWord32
val zchckToIntInf: word32 -> intInf = zchckFromWord32ToIntInf
val schckFromIntInf: intInf -> word32 = schckFromIntInfToWord32
val schckToIntInf: word32 -> intInf = schckFromWord32ToIntInf
val zextdFromIntInf: intInf -> word64 = zextdFromIntInfToWord64
val zextdToIntInf: word64 -> intInf = zextdFromWord64ToIntInf
val sextdFromIntInf: intInf -> word64 = sextdFromIntInfToWord64
val sextdToIntInf: word64 -> intInf = sextdFromWord64ToIntInf
val castFromIntInf: intInf -> word64 = castFromIntInfToWord64
val castToIntInf: word64 -> intInf = castFromWord64ToIntInf
val zchckFromIntInf: intInf -> word64 = zchckFromIntInfToWord64
val zchckToIntInf: word64 -> intInf = zchckFromWord64ToIntInf
val schckFromIntInf: intInf -> word64 = schckFromIntInfToWord64
val schckToIntInf: word64 -> intInf = schckFromWord64ToIntInf
val zextdToIntInf_0: intInf -> intInf = zextdToIntInf (intInf)
val zextdFromIntInf_0: intInf -> intInf = zextdFromIntInf (intInf)
val zchckToIntInf_0: intInf -> intInf = zchckToIntInf (intInf)
val zchckFromIntInf_0: intInf -> intInf = zchckFromIntInf (intInf)
val sextdToIntInf_0: intInf -> intInf = sextdToIntInf (intInf)
val sextdFromIntInf_0: intInf -> intInf = sextdFromIntInf (intInf)
val schckToIntInf_0: intInf -> intInf = schckToIntInf (intInf)
val schckFromIntInf_0: intInf -> intInf = schckFromIntInf (intInf)
val castToIntInf_0: intInf -> intInf = castToIntInf (intInf)
val castFromIntInf_0: intInf -> intInf = castFromIntInf (intInf)
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt64: int64 -> int8 = zextdFromInt64
val fIntInf: intInf -> int8 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt64: int8 -> int64 = zextdToInt64
val fIntInf: int8 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt64: int64 -> int8 = sextdFromInt64
val fIntInf: intInf -> int8 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt64: int8 -> int64 = sextdToInt64
val fIntInf: int8 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt64: int64 -> int8 = castFromInt64
val fIntInf: intInf -> int8 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt64: int8 -> int64 = castToInt64
val fIntInf: int8 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt64: int64 -> int8 = zchckFromInt64
val fIntInf: intInf -> int8 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt64: int8 -> int64 = zchckToInt64
val fIntInf: int8 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt64: int64 -> int8 = schckFromInt64
val fIntInf: intInf -> int8 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt64: int8 -> int64 = schckToInt64
val fIntInf: int8 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt32: int32 -> int8 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt32: int8 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt32: int32 -> int8 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt32: int8 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt32: int32 -> int8 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt32: int8 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt32: int32 -> int8 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt32: int8 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt32: int32 -> int8 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt32: int8 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt32: int32 -> int8 = zextdFromInt32
val fInt64: int64 -> int8 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt32: int8 -> int32 = zextdToInt32
val fInt64: int8 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt32: int32 -> int8 = sextdFromInt32
val fInt64: int64 -> int8 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt32: int8 -> int32 = sextdToInt32
val fInt64: int8 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt32: int32 -> int8 = castFromInt32
val fInt64: int64 -> int8 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt32: int8 -> int32 = castToInt32
val fInt64: int8 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt32: int32 -> int8 = zchckFromInt32
val fInt64: int64 -> int8 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt32: int8 -> int32 = zchckToInt32
val fInt64: int8 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt32: int32 -> int8 = schckFromInt32
val fInt64: int64 -> int8 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt32: int8 -> int32 = schckToInt32
val fInt64: int8 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord64: word64 -> int8 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord64: int8 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord64: word64 -> int8 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord64: int8 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord64: word64 -> int8 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord64: int8 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord64: word64 -> int8 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord64: int8 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord64: word64 -> int8 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord64: int8 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord32: word32 -> int8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord32: int8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord32: word32 -> int8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord32: int8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord32: word32 -> int8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord32: int8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord32: word32 -> int8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord32: int8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord32: word32 -> int8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord32: int8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord32: word32 -> int8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord32: int8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord32: word32 -> int8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord32: int8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord32: word32 -> int8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord32: int8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord32: word32 -> int8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord32: int8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord32: word32 -> int8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord32: int8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt64: int64 -> int16 = zextdFromInt64
val fIntInf: intInf -> int16 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt64: int16 -> int64 = zextdToInt64
val fIntInf: int16 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt64: int64 -> int16 = sextdFromInt64
val fIntInf: intInf -> int16 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt64: int16 -> int64 = sextdToInt64
val fIntInf: int16 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt64: int64 -> int16 = castFromInt64
val fIntInf: intInf -> int16 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt64: int16 -> int64 = castToInt64
val fIntInf: int16 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt64: int64 -> int16 = zchckFromInt64
val fIntInf: intInf -> int16 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt64: int16 -> int64 = zchckToInt64
val fIntInf: int16 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt64: int64 -> int16 = schckFromInt64
val fIntInf: intInf -> int16 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt64: int16 -> int64 = schckToInt64
val fIntInf: int16 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt32: int32 -> int16 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt32: int16 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt32: int32 -> int16 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt32: int16 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt32: int32 -> int16 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt32: int16 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt32: int32 -> int16 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt32: int16 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt32: int32 -> int16 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt32: int16 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt32: int32 -> int16 = zextdFromInt32
val fInt64: int64 -> int16 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt32: int16 -> int32 = zextdToInt32
val fInt64: int16 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt32: int32 -> int16 = sextdFromInt32
val fInt64: int64 -> int16 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt32: int16 -> int32 = sextdToInt32
val fInt64: int16 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt32: int32 -> int16 = castFromInt32
val fInt64: int64 -> int16 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt32: int16 -> int32 = castToInt32
val fInt64: int16 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt32: int32 -> int16 = zchckFromInt32
val fInt64: int64 -> int16 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt32: int16 -> int32 = zchckToInt32
val fInt64: int16 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt32: int32 -> int16 = schckFromInt32
val fInt64: int64 -> int16 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt32: int16 -> int32 = schckToInt32
val fInt64: int16 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord64: word64 -> int16 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord64: int16 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord64: word64 -> int16 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord64: int16 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord64: word64 -> int16 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord64: int16 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord64: word64 -> int16 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord64: int16 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord64: word64 -> int16 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord64: int16 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord32: word32 -> int16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord32: int16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord32: word32 -> int16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord32: int16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord32: word32 -> int16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord32: int16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord32: word32 -> int16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord32: int16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord32: word32 -> int16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord32: int16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord32: word32 -> int16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord32: int16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord32: word32 -> int16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord32: int16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord32: word32 -> int16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord32: int16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord32: word32 -> int16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord32: int16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord32: word32 -> int16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord32: int16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt64: int64 -> int32 = zextdFromInt64
val fIntInf: intInf -> int32 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val fInt64: int32 -> int64 = zextdToInt64
val fIntInf: int32 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zextdToInt: int32 -> int32 = f
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt64: int64 -> int32 = sextdFromInt64
val fIntInf: intInf -> int32 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt64: int32 -> int64 = sextdToInt64
val fIntInf: int32 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt64: int64 -> int32 = castFromInt64
val fIntInf: intInf -> int32 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt64: int32 -> int64 = castToInt64
val fIntInf: int32 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt64: int64 -> int32 = zchckFromInt64
val fIntInf: intInf -> int32 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt64: int32 -> int64 = zchckToInt64
val fIntInf: int32 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val fInt64: int64 -> int32 = schckFromInt64
val fIntInf: intInf -> int32 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckFromInt: int32 -> int32 = f
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val fInt64: int32 -> int64 = schckToInt64
val fIntInf: int32 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckToInt: int32 -> int32 = f
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt32: int32 -> int32 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt32: int32 -> int32 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt32: int32 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt32: int32 -> int32 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt32: int32 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt32: int32 -> int32 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt32: int32 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt32: int32 -> int32 = zextdFromInt32
val fInt64: int64 -> int32 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val fInt64: int32 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt32: int32 -> int32 = sextdFromInt32
val fInt64: int64 -> int32 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt32: int32 -> int32 = sextdToInt32
val fInt64: int32 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt32: int32 -> int32 = castFromInt32
val fInt64: int64 -> int32 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt32: int32 -> int32 = castToInt32
val fInt64: int32 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt32: int32 -> int32 = zchckFromInt32
val fInt64: int64 -> int32 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt32: int32 -> int32 = zchckToInt32
val fInt64: int32 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val fInt64: int64 -> int32 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val fInt64: int32 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord64: word64 -> int32 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord64: int32 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord64: word64 -> int32 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord64: int32 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord64: word64 -> int32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord64: int32 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord64: word64 -> int32 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord64: int32 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord64: word64 -> int32 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord64: int32 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord32: word32 -> int32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord32: int32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord32: word32 -> int32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord32: int32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord32: word32 -> int32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord32: int32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord32: word32 -> int32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord32: int32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord32: word32 -> int32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord32: int32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord32: word32 -> int32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord32: int32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord32: word32 -> int32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord32: int32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord32: word32 -> int32 = castFromWord32
val fWord64: word64 -> int32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord32
val f: word64 -> int32 = fWord64
val castFromSysWord: word64 -> int32 = f
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord32: int32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord32: word32 -> int32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord32: int32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord32: word32 -> int32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord32: int32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt64: int64 -> int64 = zextdFromInt64
val fIntInf: intInf -> int64 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt64: int64 -> int64 = zextdToInt64
val fIntInf: int64 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt64: int64 -> int64 = sextdFromInt64
val fIntInf: intInf -> int64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt64: int64 -> int64 = sextdToInt64
val fIntInf: int64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt64: int64 -> int64 = castFromInt64
val fIntInf: intInf -> int64 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt64: int64 -> int64 = castToInt64
val fIntInf: int64 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt64: int64 -> int64 = zchckFromInt64
val fIntInf: intInf -> int64 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt64: int64 -> int64 = zchckToInt64
val fIntInf: int64 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val fIntInf: intInf -> int64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val schckFromInt: int32 -> int64 = f
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckToInt: int64 -> int32 = f
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt32: int32 -> int64 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt32: int64 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt32: int32 -> int64 = castFromInt32
val fInt64: int64 -> int64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> int64 = fInt64
val castFromFixedInt: int64 -> int64 = f
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt32: int64 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt32: int32 -> int64 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt32: int64 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt32: int32 -> int64 = zextdFromInt32
val fInt64: int64 -> int64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt32: int64 -> int32 = zextdToInt32
val fInt64: int64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val fInt64: int64 -> int64 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val fInt64: int64 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt32: int32 -> int64 = castFromInt32
val fInt64: int64 -> int64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt32: int64 -> int32 = castToInt32
val fInt64: int64 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt32: int32 -> int64 = zchckFromInt32
val fInt64: int64 -> int64 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt32: int64 -> int32 = zchckToInt32
val fInt64: int64 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val f: int64 -> intInf = fIntInf
val schckToLargeInt: int64 -> intInf = f
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord64: word64 -> int64 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord64: int64 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord64: word64 -> int64 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord64: int64 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord64: word64 -> int64 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord64: int64 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord64: word64 -> int64 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord64: int64 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord64: word64 -> int64 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord64: int64 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord32: word32 -> int64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord32: int64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord32: word32 -> int64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord32: int64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord32: word32 -> int64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord32: int64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord32: word32 -> int64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord32: int64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord32: word32 -> int64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord32: int64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord32: word32 -> int64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord32: int64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord32: word32 -> int64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord32: int64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord32: word32 -> int64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord32: int64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord32: word32 -> int64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord32: int64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord32: word32 -> int64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord32: int64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt64: int64 -> intInf = zextdFromInt64
val fIntInf: intInf -> intInf = zextdFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt64: intInf -> int64 = zextdToInt64
val fIntInf: intInf -> intInf = zextdToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt64: int64 -> intInf = sextdFromInt64
val fIntInf: intInf -> intInf = sextdFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt64: intInf -> int64 = sextdToInt64
val fIntInf: intInf -> intInf = sextdToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt64: int64 -> intInf = castFromInt64
val fIntInf: intInf -> intInf = castFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt64: intInf -> int64 = castToInt64
val fIntInf: intInf -> intInf = castToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt64: int64 -> intInf = zchckFromInt64
val fIntInf: intInf -> intInf = zchckFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt64: intInf -> int64 = zchckToInt64
val fIntInf: intInf -> intInf = zchckToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt64: int64 -> intInf = schckFromInt64
val fIntInf: intInf -> intInf = schckFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt64: intInf -> int64 = schckToInt64
val fIntInf: intInf -> intInf = schckToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt32: int32 -> intInf = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt32: intInf -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt32: intInf -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt32: int32 -> intInf = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt32: intInf -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt32: int32 -> intInf = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt32: intInf -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt32: int32 -> intInf = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt32: intInf -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt32: int32 -> intInf = zextdFromInt32
val fInt64: int64 -> intInf = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt32: intInf -> int32 = zextdToInt32
val fInt64: intInf -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val fInt64: int64 -> intInf = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt32: intInf -> int32 = sextdToInt32
val fInt64: intInf -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt32: int32 -> intInf = castFromInt32
val fInt64: int64 -> intInf = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt32: intInf -> int32 = castToInt32
val fInt64: intInf -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt32: int32 -> intInf = zchckFromInt32
val fInt64: int64 -> intInf = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt32: intInf -> int32 = zchckToInt32
val fInt64: intInf -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt32: int32 -> intInf = schckFromInt32
val fInt64: int64 -> intInf = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt32: intInf -> int32 = schckToInt32
val fInt64: intInf -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord64: word64 -> intInf = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord64: intInf -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord64: word64 -> intInf = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord64: intInf -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord64: word64 -> intInf = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord64: intInf -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord64: word64 -> intInf = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord64: intInf -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord64: word64 -> intInf = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord64: intInf -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord32: word32 -> intInf = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord32: intInf -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord32: word32 -> intInf = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord32: intInf -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord32: word32 -> intInf = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord32: intInf -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord32: word32 -> intInf = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord32: intInf -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord32: word32 -> intInf = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord32: intInf -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord32: word32 -> intInf = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord32: intInf -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord32: word32 -> intInf = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord32: intInf -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord32: word32 -> intInf = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord32: intInf -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord32: word32 -> intInf = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord32: intInf -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord32: word32 -> intInf = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord32: intInf -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt64: int64 -> word8 = zextdFromInt64
val fIntInf: intInf -> word8 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt64: word8 -> int64 = zextdToInt64
val fIntInf: word8 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt64: int64 -> word8 = sextdFromInt64
val fIntInf: intInf -> word8 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt64: word8 -> int64 = sextdToInt64
val fIntInf: word8 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt64: int64 -> word8 = castFromInt64
val fIntInf: intInf -> word8 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt64: word8 -> int64 = castToInt64
val fIntInf: word8 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt64: int64 -> word8 = zchckFromInt64
val fIntInf: intInf -> word8 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt64: word8 -> int64 = zchckToInt64
val fIntInf: word8 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt64: int64 -> word8 = schckFromInt64
val fIntInf: intInf -> word8 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt64: word8 -> int64 = schckToInt64
val fIntInf: word8 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt32: int32 -> word8 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt32: word8 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt32: int32 -> word8 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt32: word8 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt32: int32 -> word8 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt32: word8 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt32: int32 -> word8 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt32: word8 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt32: int32 -> word8 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt32: word8 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt32: int32 -> word8 = zextdFromInt32
val fInt64: int64 -> word8 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt32: word8 -> int32 = zextdToInt32
val fInt64: word8 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt32: int32 -> word8 = sextdFromInt32
val fInt64: int64 -> word8 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt32: word8 -> int32 = sextdToInt32
val fInt64: word8 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt32: int32 -> word8 = castFromInt32
val fInt64: int64 -> word8 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt32: word8 -> int32 = castToInt32
val fInt64: word8 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt32: int32 -> word8 = zchckFromInt32
val fInt64: int64 -> word8 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt32: word8 -> int32 = zchckToInt32
val fInt64: word8 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt32: int32 -> word8 = schckFromInt32
val fInt64: int64 -> word8 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt32: word8 -> int32 = schckToInt32
val fInt64: word8 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord64: word64 -> word8 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord64: word8 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord64: word64 -> word8 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord64: word8 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord64: word64 -> word8 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord64: word8 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord64: word64 -> word8 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord64: word8 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord64: word64 -> word8 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord64: word8 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord32: word32 -> word8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord32: word8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord32: word32 -> word8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord32: word8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord32: word32 -> word8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord32: word8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord32: word32 -> word8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord32: word8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord32: word32 -> word8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord32: word8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord32: word32 -> word8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord32: word8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord32: word32 -> word8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord32: word8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord32: word32 -> word8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord32: word8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord32: word32 -> word8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord32: word8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord32: word32 -> word8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord32: word8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt64: int64 -> word16 = zextdFromInt64
val fIntInf: intInf -> word16 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt64: word16 -> int64 = zextdToInt64
val fIntInf: word16 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt64: int64 -> word16 = sextdFromInt64
val fIntInf: intInf -> word16 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt64: word16 -> int64 = sextdToInt64
val fIntInf: word16 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt64: int64 -> word16 = castFromInt64
val fIntInf: intInf -> word16 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt64: word16 -> int64 = castToInt64
val fIntInf: word16 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt64: int64 -> word16 = zchckFromInt64
val fIntInf: intInf -> word16 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt32: word16 -> int32 = zchckToInt32
val fInt64: word16 -> int64 = zchckToInt64
val fIntInf: word16 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val f: word16 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zchckToInt: word16 -> int32 = f
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt64: int64 -> word16 = schckFromInt64
val fIntInf: intInf -> word16 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt64: word16 -> int64 = schckToInt64
val fIntInf: word16 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt32: int32 -> word16 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt32: word16 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt32: int32 -> word16 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt32: word16 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt32: int32 -> word16 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt32: word16 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt32: int32 -> word16 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt32: word16 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt32: int32 -> word16 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt32: word16 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt32: int32 -> word16 = zextdFromInt32
val fInt64: int64 -> word16 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt32: word16 -> int32 = zextdToInt32
val fInt64: word16 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt32: int32 -> word16 = sextdFromInt32
val fInt64: int64 -> word16 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt32: word16 -> int32 = sextdToInt32
val fInt64: word16 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt32: int32 -> word16 = castFromInt32
val fInt64: int64 -> word16 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt32: word16 -> int32 = castToInt32
val fInt64: word16 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt32: int32 -> word16 = zchckFromInt32
val fInt64: int64 -> word16 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt32: word16 -> int32 = zchckToInt32
val fInt64: word16 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt32: int32 -> word16 = schckFromInt32
val fInt64: int64 -> word16 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt32: word16 -> int32 = schckToInt32
val fInt64: word16 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord64: word64 -> word16 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord64: word16 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord64: word64 -> word16 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord64: word16 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord64: word64 -> word16 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord64: word16 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord64: word64 -> word16 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord64: word16 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord64: word64 -> word16 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord64: word16 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord32: word32 -> word16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord32: word16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord32: word32 -> word16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord32: word16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord32: word32 -> word16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord32: word16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord32: word32 -> word16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord32: word16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord32: word32 -> word16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord32: word16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord32: word32 -> word16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord32: word16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord32: word32 -> word16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord32: word16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord32: word32 -> word16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord32: word16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord32: word32 -> word16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord32: word16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord32: word32 -> word16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord32: word16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt64: int64 -> word32 = zextdFromInt64
val fIntInf: intInf -> word32 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt64: word32 -> int64 = zextdToInt64
val fIntInf: word32 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt64: int64 -> word32 = sextdFromInt64
val fIntInf: intInf -> word32 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt64: word32 -> int64 = sextdToInt64
val fIntInf: word32 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt64: int64 -> word32 = castFromInt64
val fIntInf: intInf -> word32 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt64: word32 -> int64 = castToInt64
val fIntInf: word32 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt64: int64 -> word32 = zchckFromInt64
val fIntInf: intInf -> word32 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val fInt64: word32 -> int64 = zchckToInt64
val fIntInf: word32 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val f: word32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zchckToInt: word32 -> int32 = f
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt64: int64 -> word32 = schckFromInt64
val fIntInf: intInf -> word32 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt64: word32 -> int64 = schckToInt64
val fIntInf: word32 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt32: int32 -> word32 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt32: word32 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt32: int32 -> word32 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt32: word32 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt32: int32 -> word32 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt32: word32 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt32: int32 -> word32 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt32: int32 -> word32 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt32: word32 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt32: int32 -> word32 = zextdFromInt32
val fInt64: int64 -> word32 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt32: word32 -> int32 = zextdToInt32
val fInt64: word32 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt32: int32 -> word32 = sextdFromInt32
val fInt64: int64 -> word32 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt32: word32 -> int32 = sextdToInt32
val fInt64: word32 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt32: int32 -> word32 = castFromInt32
val fInt64: int64 -> word32 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt32: word32 -> int32 = castToInt32
val fInt64: word32 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt32: int32 -> word32 = zchckFromInt32
val fInt64: int64 -> word32 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val fInt64: word32 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt32: int32 -> word32 = schckFromInt32
val fInt64: int64 -> word32 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt32: word32 -> int32 = schckToInt32
val fInt64: word32 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord64: word64 -> word32 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord64: word32 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord64: word64 -> word32 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord64: word32 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord64: word64 -> word32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord64: word32 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord64: word64 -> word32 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord64: word32 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord64: word64 -> word32 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord64: word32 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord32: word32 -> word32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord32: word32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord32: word32 -> word32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord32: word32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord32: word32 -> word32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord32: word32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord32: word32 -> word32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord32: word32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord32: word32 -> word32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord32: word32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord32: word32 -> word32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord32: word32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord32: word32 -> word32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord32: word32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord32: word32 -> word32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord32: word32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord32: word32 -> word32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord32: word32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord32: word32 -> word32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord32: word32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt64: int64 -> word64 = zextdFromInt64
val fIntInf: intInf -> word64 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt64: word64 -> int64 = zextdToInt64
val fIntInf: word64 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val fInt64: int64 -> word64 = sextdFromInt64
val fIntInf: intInf -> word64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> word64 = fInt32
val _ = fInt64
val _ = fIntInf
val sextdFromInt: int32 -> word64 = f
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt64: word64 -> int64 = sextdToInt64
val fIntInf: word64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt64: int64 -> word64 = castFromInt64
val fIntInf: intInf -> word64 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt64: word64 -> int64 = castToInt64
val fIntInf: word64 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt64: int64 -> word64 = zchckFromInt64
val fIntInf: intInf -> word64 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt64: word64 -> int64 = zchckToInt64
val fIntInf: word64 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt64: int64 -> word64 = schckFromInt64
val fIntInf: intInf -> word64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt64: word64 -> int64 = schckToInt64
val fIntInf: word64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt32: word64 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt32: int32 -> word64 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt32: word64 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt32: int32 -> word64 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt32: word64 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt32: int32 -> word64 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt32: word64 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val fInt64: word64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val fInt64: int64 -> word64 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt32: word64 -> int32 = sextdToInt32
val fInt64: word64 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt32: int32 -> word64 = castFromInt32
val fInt64: int64 -> word64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt32: word64 -> int32 = castToInt32
val fInt64: word64 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt32: int32 -> word64 = zchckFromInt32
val fInt64: int64 -> word64 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt32: word64 -> int32 = zchckToInt32
val fInt64: word64 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt32: int32 -> word64 = schckFromInt32
val fInt64: int64 -> word64 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt32: word64 -> int32 = schckToInt32
val fInt64: word64 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord64: word64 -> word64 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord64: word64 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord64: word64 -> word64 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord64: word64 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord64: word64 -> word64 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord64: word64 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord64: word64 -> word64 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord64: word64 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord64: word64 -> word64 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord64: word64 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord32: word32 -> word64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord32: word64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord32: word32 -> word64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord32: word64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord32: word32 -> word64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord32: word64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord32: word32 -> word64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord32: word64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord32: word32 -> word64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord32: word64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord32: word32 -> word64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord32: word64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord32: word32 -> word64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord32: word64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord32: word32 -> word64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord32: word64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord32: word32 -> word64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord32: word64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord32: word32 -> word64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord32: word64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
exception Chr
exception Fail of string
exception Span
val 'a_1659 !: 'a_1659 ref -> 'a_1659 = deref ('a_1659)
val 'a_1660 :=: 'a_1660 ref * 'a_1660 -> unit = assign ('a_1660)
val rec ('a_1663, 'a_1662, 'a_1661)
   o: ('a_1663 -> 'a_1662) * ('a_1661 -> 'a_1663) -> 'a_1661 -> 'a_1662 = 
      (fn x_1036: ('a_1663 -> 'a_1662) * ('a_1661 -> 'a_1663) =>
       (fn x_1037: 'a_1661 =>
	case (x_1036, x_1037) of
	  ((f: 'a_1663 -> 'a_1662, g: 'a_1661 -> 'a_1663), x: 'a_1661) =>
	  (f (g x))))
val rec 'a_1665
   ignore: 'a_1665 -> unit = 
      (fn x_1038: 'a_1665 =>
       case x_1038 of
	 (_) => ())
val exnName: exn -> string = name
val messagers: (exn -> string Primitive.Option.t) list ref =
   (ref[(exn -> string Primitive.Option.t) list] [])
val addExnMessager: (exn -> string Primitive.Option.t) -> unit =
   (fn x_1039: exn -> string Primitive.Option.t =>
    case x_1039 of
      f: exn -> string Primitive.Option.t =>
      (:= ((exn -> string Primitive.Option.t) list) (messagers,
						     (::[exn
							 -> string Primitive.Option.t] (f,
											(! ((exn
											     -> string Primitive.Option.t) list) messagers))))))
val rec
   exnMessage: exn -> string = 
      (fn x_1040: exn =>
       case x_1040 of
	 e: exn =>
	 let val rec
		find: (exn -> string Primitive.Option.t) list -> string = 
		   (fn x_1041: (exn -> string Primitive.Option.t) list =>
		    case x_1041 of
		      [] => (exnName e)
		    | ::[exn -> string Primitive.Option.t] (m: exn
							       -> string Primitive.Option.t,
							    ms: (exn
								 -> string Primitive.Option.t) list) =>
		      case (m e) of
			NONE[string] => (find ms) | SOME[string] s: string => s)
	 in
	    (find (! ((exn -> string Primitive.Option.t) list) messagers))
	 end)
val ('a, 'c, 'b) o_0: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = o ('b, 'c, 'a)
val 'a ignore_0: 'a -> unit = ignore ('a)
val 'a :=_0: 'a ref * 'a -> unit = := ('a)
val 'a !_0: 'a ref -> 'a = ! ('a)
val ('a, 'c, 'b) o_1: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = o_0 ('a, 'c, 'b)
val 'a ignore_1: 'a -> unit = ignore_0 ('a)
val 'a :=_1: 'a ref * 'a -> unit = :=_0 ('a)
val 'a !_1: 'a ref -> 'a = !_0 ('a)
datatype 'a One.t = T of {more: unit -> 'a, static: 'a, staticIsInUse: bool ref}
val rec 'a_1666
   make: (unit -> 'a_1666) -> 'a_1666 One.t = 
      (fn x_1042: unit -> 'a_1666 =>
       case x_1042 of
	 (f: unit -> 'a_1666) =>
	 (T['a_1666] {more = f,
		      static = (f ()),
		      staticIsInUse = (ref[bool] false)}))
val rec ('a_1668, 'a_1667)
   use: 'a_1668 One.t * ('a_1668 -> 'a_1667) -> 'a_1667 = 
      (fn x_1043: 'a_1668 One.t * ('a_1668 -> 'a_1667) =>
       case x_1043 of
	 ((T['a_1668] {more = more: unit -> 'a_1668,
		       static = static: 'a_1668,
		       staticIsInUse = staticIsInUse: bool ref},
	   f: 'a_1668 -> 'a_1667)) =>
	 let val () = (atomicBegin ())
	     val b: bool = (!_1 (bool) staticIsInUse)
	     val d: 'a_1668 =
		case b of
		  true => (atomicEnd ()) ;(more ())
		| false =>
		  (:=_1 (bool) (staticIsInUse, true)) ;(atomicEnd ()) ;static
	 in
	    (wind_0 ('a_1667) ((fn x_1045: unit =>
				case x_1045 of
				  () => (f d)),
			       (fn x_1044: unit =>
				case x_1044 of
				  () =>
				  case b of
				    true => ()
				  | false =>
				    (:=_1 (bool) (staticIsInUse, false)))))
	 end)
val ('b, 'a) use_0: 'a One.t * ('a -> 'b) -> 'b = use ('a, 'b)
val 'a make_0: (unit -> 'a) -> 'a One.t = make ('a)
exception Option
val rec ('a_1673, 'a_1672)
   map: ('a_1673 -> 'a_1672)
	-> 'a_1673 Primitive.Option.t -> 'a_1672 Primitive.Option.t = 
      (fn x_1046: 'a_1673 -> 'a_1672 =>
       case x_1046 of
	 (f: 'a_1673 -> 'a_1672) =>
	 (fn x_1047: 'a_1673 Primitive.Option.t =>
	  case x_1047 of
	    NONE['a_1673] => NONE['a_1672]
	  | SOME['a_1673] a: 'a_1673 => (SOME['a_1672] (f a))))
val 'a_1687 isSome: 'a_1687 Primitive.Option.t -> bool =
   (fn x_1048: 'a_1687 Primitive.Option.t =>
    case x_1048 of
      NONE['a_1687] => false | SOME['a_1687] _ => true)
val 'a_1688 valOf: 'a_1688 Primitive.Option.t -> 'a_1688 =
   (fn x_1049: 'a_1688 Primitive.Option.t =>
    case x_1049 of
      NONE['a_1688] => raise Option | SOME['a_1688] v: 'a_1688 => v)
val 'a valOf_0: 'a Primitive.Option.t -> 'a = valOf ('a)
val ('b, 'a) map_0: ('a -> 'b) -> 'a Primitive.Option.t -> 'b Primitive.Option.t =
   map ('a, 'b)
val 'a isSome_0: 'a Primitive.Option.t -> bool = isSome ('a)
val 'a valOf_1: 'a Primitive.Option.t -> 'a = valOf_0 ('a)
exception Empty
val rec ('a_1699, 'a_1698)
   foldl: ('a_1699 * 'a_1698 -> 'a_1698) -> 'a_1698 -> 'a_1699 list -> 'a_1698 = 
      (fn x_1050: 'a_1699 * 'a_1698 -> 'a_1698 =>
       (fn x_1051: 'a_1698 =>
	(fn x_1052: 'a_1699 list =>
	 case (x_1050, x_1051, x_1052) of
	   (f: 'a_1699 * 'a_1698 -> 'a_1698, b: 'a_1698, l: 'a_1699 list) =>
	   let val rec
		  loop: 'a_1699 list * 'a_1698 -> 'a_1698 = 
		     (fn x_1053: 'a_1699 list * 'a_1698 =>
		      case x_1053 of
			((l: 'a_1699 list, b: 'a_1698)) =>
			case l of
			  [] => b
			| ::['a_1699] (x: 'a_1699, l: 'a_1699 list) =>
			  (loop (l, (f (x, b)))))
	   in
	      (loop (l, b))
	   end)))
val rec 'a_1700
   length: 'a_1700 list -> int32 = 
      (fn x_1054: 'a_1700 list =>
       case x_1054 of
	 (l: 'a_1700 list) =>
	 (((foldl ('a_1700, int32) (fn x_1055: 'a_1700 * int32 =>
				    case x_1055 of
				      (_, n: int32) => (+? (n, 0x1)))) 0x0) l))
val rec 'a_1701
   appendRev: 'a_1701 list * 'a_1701 list -> 'a_1701 list = 
      (fn x_1056: 'a_1701 list * 'a_1701 list =>
       case x_1056 of
	 ((l1: 'a_1701 list, l2: 'a_1701 list)) =>
	 (((foldl ('a_1701, 'a_1701 list) ::['a_1701]) l2) l1))
val rec 'a_1703
   rev: 'a_1703 list -> 'a_1703 list = 
      (fn x_1057: 'a_1703 list =>
       case x_1057 of
	 (l: 'a_1703 list) => (appendRev ('a_1703) (l, [])))
val rec 'a_1708
   app: ('a_1708 -> unit) -> 'a_1708 list -> unit = 
      (fn x_1058: 'a_1708 -> unit =>
       case x_1058 of
	 (f: 'a_1708 -> unit) =>
	 ((foldl ('a_1708, unit) (o_1 ('a_1708 * unit, unit, 'a_1708) (f,
								       (fn x_1059: 'a_1708
										   * unit =>
									case x_1059 of
									  {1 = #: 'a_1708} =>
									  #)))) ()))
val rec ('a_1710, 'a_1709)
   map: ('a_1710 -> 'a_1709) -> 'a_1710 list -> 'a_1709 list = 
      (fn x_1060: 'a_1710 -> 'a_1709 =>
       (fn x_1061: 'a_1710 list =>
	case (x_1060, x_1061) of
	  (f: 'a_1710 -> 'a_1709, l: 'a_1710 list) =>
	  (rev ('a_1709) (((foldl ('a_1710, 'a_1709 list) (fn x_1062: 'a_1710
								      * 'a_1709 list =>
							   case x_1062 of
							     (x: 'a_1710,
							      l: 'a_1709 list) =>
							     (::['a_1709] ((f x),
									   l)))) []) l))))
val rec 'a_1715
   find: ('a_1715 -> bool) -> 'a_1715 list -> 'a_1715 Primitive.Option.t = 
      (fn x_1063: 'a_1715 -> bool =>
       case x_1063 of
	 (pred: 'a_1715 -> bool) =>
	 let val rec
		loop: 'a_1715 list -> 'a_1715 Primitive.Option.t = 
		   (fn x_1064: 'a_1715 list =>
		    case x_1064 of
		      [] => NONE['a_1715]
		    | ::['a_1715] (x: 'a_1715, l: 'a_1715 list) =>
		      case (pred x) of
			true => (SOME['a_1715] x) | false => (loop l))
	 in
	    loop
	 end)
val 'a rev_0: 'a list -> 'a list = rev ('a)
val ('b, 'a) map_1: ('a -> 'b) -> 'a list -> 'b list = map ('a, 'b)
val 'a length_0: 'a list -> int32 = length ('a)
val ('b, 'a) foldl_0: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b = foldl ('a, 'b)
val 'a find_0: ('a -> bool) -> 'a list -> 'a Primitive.Option.t = find ('a)
val 'a app_0: ('a -> unit) -> 'a list -> unit = app ('a)
val 'a rev_1: 'a list -> 'a list = rev_0 ('a)
val ('b, 'a) map_2: ('a -> 'b) -> 'a list -> 'b list = map_1 ('b, 'a)
val 'a app_1: ('a -> unit) -> 'a list -> unit = app_0 ('a)
exception UnequalLengths
val maxLen': int64 = maxInt'
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val fInt64: int64 -> int64 = sextdFromInt64
val fIntInf: intInf -> int64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val fromIntUnsafe: int32 -> int64 = f
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val fIntInf: intInf -> int64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val fromInt: int32 -> int64 = f
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val fInt64: int64 -> int64 = sextdToInt64
val fIntInf: int64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val toIntUnsafe: int64 -> int32 = f
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val toInt: int64 -> int32 = f
val 'a_2004 fromArray: 'a_2004 array -> 'a_2004 vector =
   fromArrayUnsafe ('a_2004)
val isMutable: bool = false
val 'a_2005 length: 'a_2005 vector -> int64 = length ('a_2005)
val 'a_2006 subUnsafe: 'a_2006 vector * int64 -> 'a_2006 = subUnsafe ('a_2006)
val 'a subUnsafe_0: 'a vector * int64 -> 'a = subUnsafe ('a)
val 'a length_1: 'a vector -> int64 = length ('a)
val 'a fromArray_0: 'a array -> 'a vector = fromArray ('a)
val +?: int64 * int64 -> int64 = +?
val +: int64 * int64 -> int64 = +
val -?: int64 * int64 -> int64 = -?
val <: int64 * int64 -> bool = <
val <=: int64 * int64 -> bool = <=
val >: int64 * int64 -> bool = >
val >=: int64 * int64 -> bool = >=
val gtu: int64 * int64 -> bool = gtu
val geu: int64 * int64 -> bool = geu
val rec ('a_2012, 'a_2011)
   wrap2: (int32 * 'a_2012 -> 'a_2011) -> int64 * 'a_2012 -> 'a_2011 = 
      (fn x_1065: int32 * 'a_2012 -> 'a_2011 =>
       case x_1065 of
	 (f: int32 * 'a_2012 -> 'a_2011) =>
	 (fn x_1066: int64 * 'a_2012 =>
	  case x_1066 of
	    (i: int64, x: 'a_2012) => (f ((toIntUnsafe i), x))))
val rec 'a_2019
   doit: int32 * (int64 -> 'a_2019) * ('a_2019 -> int64) * 'a_2019
	 -> int64 * 'a_2019 = 
      (fn x_1067: int32 * (int64 -> 'a_2019) * ('a_2019 -> int64) * 'a_2019 =>
       case x_1067 of
	 ((precision: int32,
	   toInt: int64 -> 'a_2019,
	   fromInt: 'a_2019 -> int64,
	   maxInt': 'a_2019)) =>
	 case (>= ((valOf_1 (int32) precision), precision)) of
	   true => ((fromInt maxInt'), maxInt')
	 | false => (maxLen', (toInt maxLen')))
val fInt8: int64 * int8 =
   (doit (int8) ((valOf_1 (int32) precision),
		 schckToInt8,
		 schckFromInt8,
		 maxInt'))
val fInt16: int64 * int16 =
   (doit (int16) ((valOf_1 (int32) precision),
		  schckToInt16,
		  schckFromInt16,
		  maxInt'))
val fInt32: int64 * int32 =
   (doit (int32) ((valOf_1 (int32) precision),
		  schckToInt32,
		  schckFromInt32,
		  maxInt'))
val fInt64: int64 * int64 =
   (doit (int64) ((valOf_1 (int32) precision),
		  schckToInt64,
		  schckFromInt64,
		  maxInt'))
val fIntInf: int64 * intInf = (maxLen', (schckToIntInf maxLen'))
val _ = fInt8
val _ = fInt16
val f: int64 * int32 = fInt32
val _ = fInt64
val _ = fIntInf
val (maxLen': int64, maxLen: int32) = f
val rec
   fromIntForLength: int32 -> int64 = 
      (fn x_1068: int32 =>
       case x_1068 of
	 (n: int32) =>
	 case safe of
	   true =>
	   (fromInt n)
	   handle x_1069 => case x_1069 of
			      Overflow => raise Size
	 | false => (fromIntUnsafe n))
val rec 'a_2022
   length': 'a_2022 vector -> int64 = 
      (fn x_1070: 'a_2022 vector =>
       case x_1070 of
	 (s: 'a_2022 vector) => (length_1 ('a_2022) s))
val rec 'a_2023
   length: 'a_2023 vector -> int32 = 
      (fn x_1071: 'a_2023 vector =>
       case x_1071 of
	 (s: 'a_2023 vector) =>
	 case safe of
	   true =>
	   (toInt (length' ('a_2023) s))
	   handle x_1072 => case x_1072 of
			      Overflow => raise (Fail "Sequence.length")
	 | false => (toIntUnsafe (length' ('a_2023) s)))
val rec 'a_2024
   arrayUninit': int64 -> 'a_2024 array = 
      (fn x_1073: int64 =>
       case x_1073 of
	 (n: int64) =>
	 case case (not isMutable) of
		true => (= (int64) (n, 0x0)) | false => false of
	   true => (array0Const ('a_2024) ())
	 | false =>
	   case case safe of
		  true => (gtu (n, maxLen')) | false => false of
	     true => raise Size | false => (arrayUnsafe ('a_2024) n))
val rec ('a_2031, 'a_2030)
   unfoldi': int64 * 'a_2031 * (int64 * 'a_2031 -> 'a_2030 * 'a_2031)
	     -> 'a_2030 vector * 'a_2031 = 
      (fn x_1074: int64 * 'a_2031 * (int64 * 'a_2031 -> 'a_2030 * 'a_2031) =>
       case x_1074 of
	 ((n: int64, b: 'a_2031, f: int64 * 'a_2031 -> 'a_2030 * 'a_2031)) =>
	 let val a: 'a_2030 array = (arrayUninit' ('a_2030) n)
	     val rec
		loop: int64 * 'a_2031 -> 'a_2031 = 
		   (fn x_1075: int64 * 'a_2031 =>
		    case x_1075 of
		      ((i: int64, b: 'a_2031)) =>
		      case (>= (i, n)) of
			true => b
		      | false =>
			let val (x: 'a_2030, b': 'a_2031) = (f (i, b))
			    val () = (updateUnsafe ('a_2030) (a, i, x))
			in
			   (loop ((+? (i, 0x1)), b'))
			end)
	     val b: 'a_2031 = (loop (0x0, b))
	 in
	    ((fromArray_0 ('a_2030) a), b)
	 end)
val rec ('a_2033, 'a_2032)
   unfoldi: int32 * 'a_2032 * (int32 * 'a_2032 -> 'a_2033 * 'a_2032)
	    -> 'a_2033 vector * 'a_2032 = 
      (fn x_1076: int32 * 'a_2032 * (int32 * 'a_2032 -> 'a_2033 * 'a_2032) =>
       case x_1076 of
	 ((n: int32, b: 'a_2032, f: int32 * 'a_2032 -> 'a_2033 * 'a_2032)) =>
	 (unfoldi' ('a_2032, 'a_2033) ((fromIntForLength n),
				       b,
				       (wrap2 ('a_2032, 'a_2033 * 'a_2032) f))))
val rec ('a_2035, 'a_2034)
   unfold: int32 * 'a_2034 * ('a_2034 -> 'a_2035 * 'a_2034)
	   -> 'a_2035 vector * 'a_2034 = 
      (fn x_1077: int32 * 'a_2034 * ('a_2034 -> 'a_2035 * 'a_2034) =>
       case x_1077 of
	 ((n: int32, b: 'a_2034, f: 'a_2034 -> 'a_2035 * 'a_2034)) =>
	 (unfoldi ('a_2035, 'a_2034) (n,
				      b,
				      (o_1 (int32 * 'a_2034,
					    'a_2035 * 'a_2034,
					    'a_2034) (f,
						      (fn x_1078: int32
								  * 'a_2034 =>
						       case x_1078 of
							 {2 = #: 'a_2034} => #))))))
val rec 'a_2036
   seq0: unit -> 'a_2036 vector = 
      (fn x_1079: unit =>
       case x_1079 of
	 (()) =>
	 ((fn x_1080: 'a_2036 vector * unit =>
	   case x_1080 of
	     {1 = #: 'a_2036 vector} => #) (unfold ('a_2036, unit) (0x0,
						       (),
						       (fn x_1081: unit =>
							case x_1081 of
							  _ =>
							  raise (Fail "Sequence.seq0"))))))
val rec 'a_2037
   tabulate': int64 * (int64 -> 'a_2037) -> 'a_2037 vector = 
      (fn x_1082: int64 * (int64 -> 'a_2037) =>
       case x_1082 of
	 ((n: int64, f: int64 -> 'a_2037)) =>
	 ((fn x_1083: 'a_2037 vector * unit =>
	   case x_1083 of
	     {1 = #: 'a_2037 vector} => #) (unfoldi' (unit, 'a_2037) (n,
							 (),
							 (fn x_1084: int64
								     * unit =>
							  case x_1084 of
							    (i: int64, ()) =>
							    ((f i), ()))))))
val rec 'a_2038
   tabulate: int32 * (int32 -> 'a_2038) -> 'a_2038 vector = 
      (fn x_1085: int32 * (int32 -> 'a_2038) =>
       case x_1085 of
	 ((n: int32, f: int32 -> 'a_2038)) =>
	 ((fn x_1086: 'a_2038 vector * unit =>
	   case x_1086 of
	     {1 = #: 'a_2038 vector} => #) (unfoldi ('a_2038, unit) (n,
							(),
							(fn x_1087: int32 * unit =>
							 case x_1087 of
							   (i: int32, ()) =>
							   ((f i), ()))))))
val rec 'a_2040
   new: int32 * 'a_2040 -> 'a_2040 vector = 
      (fn x_1088: int32 * 'a_2040 =>
       case x_1088 of
	 ((n: int32, x: 'a_2040)) =>
	 (tabulate ('a_2040) (n, (fn x_1089: int32 => case x_1089 of _ => x))))
val rec 'a_2041
   fromList: 'a_2041 list -> 'a_2041 vector = 
      (fn x_1090: 'a_2041 list =>
       case x_1090 of
	 (l: 'a_2041 list) =>
	 ((fn x_1091: 'a_2041 vector * 'a_2041 list =>
	   case x_1091 of
	     {1 = #: 'a_2041 vector} => #) (unfold ('a_2041, 'a_2041 list) ((length_0 ('a_2041) l),
							       l,
							       (fn x_1092: 'a_2041 list =>
								case x_1092 of
								  l: 'a_2041 list =>
								  case l of
								    nil['a_2041] =>
								    raise (Fail "Sequence.fromList")
								  | ::['a_2041] (h: 'a_2041,
										 t: 'a_2041 list) =>
								    (h, t))))))
datatype 'a Sequence.Slice.t = T of {len: int64, seq: 'a vector, start: int64}
val rec 'a_2042
   length': 'a_2042 Sequence.Slice.t -> int64 = 
      (fn x_1093: 'a_2042 Sequence.Slice.t =>
       case x_1093 of
	 (T['a_2042] {len = len: int64}) => len)
val rec 'a_2043
   length: 'a_2043 Sequence.Slice.t -> int32 = 
      (fn x_1094: 'a_2043 Sequence.Slice.t =>
       case x_1094 of
	 (sl: 'a_2043 Sequence.Slice.t) =>
	 case safe of
	   true =>
	   (toInt (length' ('a_2043) sl))
	   handle x_1095 => case x_1095 of
			      Overflow => raise (Fail "Sequence.Slice.length")
	 | false => (toIntUnsafe (length' ('a_2043) sl)))
val rec 'a_2044
   unsafeSub': 'a_2044 Sequence.Slice.t * int64 -> 'a_2044 = 
      (fn x_1096: 'a_2044 Sequence.Slice.t * int64 =>
       case x_1096 of
	 ((T['a_2044] {seq = seq: 'a_2044 vector, start = start: int64},
	   i: int64)) =>
	 (subUnsafe_0 ('a_2044) (seq, (+? (start, i)))))
val rec 'a_2045
   unsafeSub: 'a_2045 Sequence.Slice.t * int32 -> 'a_2045 = 
      (fn x_1097: 'a_2045 Sequence.Slice.t * int32 =>
       case x_1097 of
	 ((sl: 'a_2045 Sequence.Slice.t, i: int32)) =>
	 (unsafeSub' ('a_2045) (sl, (fromIntUnsafe i))))
val rec 'a_2046
   sub': 'a_2046 Sequence.Slice.t * int64 -> 'a_2046 = 
      (fn x_1098: 'a_2046 Sequence.Slice.t * int64 =>
       case x_1098 of
	 ((sl: 'a_2046 Sequence.Slice.t as T['a_2046] {len = len: int64},
	   i: int64)) =>
	 case case safe of
		true => (geu (i, len)) | false => false of
	   true => raise Subscript | false => (unsafeSub' ('a_2046) (sl, i)))
val rec 'a_2047
   sub: 'a_2047 Sequence.Slice.t * int32 -> 'a_2047 = 
      (fn x_1099: 'a_2047 Sequence.Slice.t * int32 =>
       case x_1099 of
	 ((sl: 'a_2047 Sequence.Slice.t, i: int32)) =>
	 case safe of
	   true =>
	   let val i: int64 =
		  (fromInt i)
		  handle x_1100 => case x_1100 of
				     Overflow => raise Subscript
	   in
	      (sub' ('a_2047) (sl, i))
	   end
	 | false => (unsafeSub ('a_2047) (sl, i)))
val rec 'a
   full: 'a vector -> 'a Sequence.Slice.t = 
      (fn x_1101: 'a vector =>
       case x_1101 of
	 (seq: 'a vector) =>
	 (T['a] {seq = seq, start = 0x0, len = (length_1 ('a) seq)}))
val rec 'a_2060
   unsafeSubslice': 'a_2060 Sequence.Slice.t * int64 * int64 Primitive.Option.t
		    -> 'a_2060 Sequence.Slice.t = 
      (fn x_1102: 'a_2060 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1102 of
	 ((T['a_2060] {seq = seq: 'a_2060 vector,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 (T['a_2060] {seq = seq,
		      start = (+? (start, start')),
		      len = case len' of
			      NONE[int64] => (-? (len, start'))
			    | SOME[int64] len': int64 => len'}))
val rec 'a_2061
   unsafeSubslice: 'a_2061 Sequence.Slice.t * int32 * int32 Primitive.Option.t
		   -> 'a_2061 Sequence.Slice.t = 
      (fn x_1103: 'a_2061 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1103 of
	 ((sl: 'a_2061 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 (unsafeSubslice' ('a_2061) (sl,
				     (fromIntUnsafe start),
				     ((map_0 (int64, int32) fromIntUnsafe) len))))
val rec 'a_2062
   unsafeSlice': 'a_2062 vector * int64 * int64 Primitive.Option.t
		 -> 'a_2062 Sequence.Slice.t = 
      (fn x_1104: 'a_2062 vector * int64 * int64 Primitive.Option.t =>
       case x_1104 of
	 ((seq: 'a_2062 vector, start: int64, len: int64 Primitive.Option.t)) =>
	 (unsafeSubslice' ('a_2062) ((full ('a_2062) seq), start, len)))
val rec 'a_2064
   subslice': 'a_2064 Sequence.Slice.t * int64 * int64 Primitive.Option.t
	      -> 'a_2064 Sequence.Slice.t = 
      (fn x_1105: 'a_2064 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1105 of
	 ((T['a_2064] {seq = seq: 'a_2064 vector,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 case len' of
	   NONE[int64] =>
	   case case safe of
		  true => (gtu (start', len)) | false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2064] {seq = seq,
			  start = (+? (start, start')),
			  len = (-? (len, start'))})
	 | SOME[int64] len': int64 =>
	   case case safe of
		  true =>
		  case (gtu (start', len)) of
		    true => true | false => (gtu (len', (-? (len, start'))))
		| false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2064] {seq = seq, start = (+? (start, start')), len = len'}))
val rec 'a_2065
   subslice: 'a_2065 Sequence.Slice.t * int32 * int32 Primitive.Option.t
	     -> 'a_2065 Sequence.Slice.t = 
      (fn x_1106: 'a_2065 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1106 of
	 ((sl: 'a_2065 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 case safe of
	   true =>
	   (subslice' ('a_2065) (sl,
				 (fromInt start),
				 ((map_0 (int64, int32) fromInt) len)))
	   handle x_1107 => case x_1107 of
			      Overflow => raise Subscript
	 | false => (unsafeSubslice ('a_2065) (sl, start, len)))
val rec 'a
   slice: 'a vector * int32 * int32 Primitive.Option.t -> 'a Sequence.Slice.t = 
      (fn x_1108: 'a vector * int32 * int32 Primitive.Option.t =>
       case x_1108 of
	 ((seq: 'a vector, start: int32, len: int32 Primitive.Option.t)) =>
	 (subslice ('a) ((full ('a) seq), start, len)))
val rec 'a_2067
   base: 'a_2067 Sequence.Slice.t -> 'a_2067 vector * int32 * int32 = 
      (fn x_1109: 'a_2067 Sequence.Slice.t =>
       case x_1109 of
	 (T['a_2067] {seq = seq: 'a_2067 vector,
		      start = start: int64,
		      len = len: int64}) =>
	 (seq, (toIntUnsafe start), (toIntUnsafe len)))
val rec ('a_2071, 'a_2070)
   foldli': (int64 * 'a_2071 * 'a_2070 -> 'a_2070)
	    -> 'a_2070 -> 'a_2071 Sequence.Slice.t -> 'a_2070 = 
      (fn x_1110: int64 * 'a_2071 * 'a_2070 -> 'a_2070 =>
       (fn x_1111: 'a_2070 =>
	(fn x_1112: 'a_2071 Sequence.Slice.t =>
	 case (x_1110, x_1111, x_1112) of
	   (f: int64 * 'a_2071 * 'a_2070 -> 'a_2070,
	    b: 'a_2070,
	    T['a_2071] {seq = seq: 'a_2071 vector,
			start = start: int64,
			len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_2070 -> 'a_2070 = 
		     (fn x_1113: int64 * 'a_2070 =>
		      case x_1113 of
			((i: int64, b: 'a_2070)) =>
			case (> (i, max)) of
			  true => b
			| false =>
			  (loop ((+? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_0 ('a_2071) (seq, i)),
				     b)))))
	   in
	      (loop (min, b))
	   end)))
val rec ('a_2084, 'a_2083, 'a_2082, 'a_2081, 'a_2080, 'a_2079, 'a_2078)
   make: (('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
	  -> 'a_2079 -> 'a_2078 -> 'a_2080)
	 -> ('a_2083 * 'a_2082 -> 'a_2081) -> 'a_2079 -> 'a_2078 -> 'a_2080 = 
      (fn x_1114: ('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
		  -> 'a_2079 -> 'a_2078 -> 'a_2080 =>
       (fn x_1115: 'a_2083 * 'a_2082 -> 'a_2081 =>
	(fn x_1116: 'a_2079 =>
	 (fn x_1117: 'a_2078 =>
	  case (x_1114, x_1115, x_1116, x_1117) of
	    (foldi: ('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
		    -> 'a_2079 -> 'a_2078 -> 'a_2080,
	     f: 'a_2083 * 'a_2082 -> 'a_2081,
	     b: 'a_2079,
	     sl: 'a_2078) =>
	    (((foldi (fn x_1118: 'a_2084 * 'a_2083 * 'a_2082 =>
		      case x_1118 of
			(_, x: 'a_2083, b: 'a_2082) => (f (x, b)))) b) sl)))))
val rec ('a_2086, 'a_2085)
   foldl: ('a_2086 * 'a_2085 -> 'a_2085)
	  -> 'a_2085 -> 'a_2086 Sequence.Slice.t -> 'a_2085 = 
      (fn x_1119: 'a_2086 * 'a_2085 -> 'a_2085 =>
       case x_1119 of
	 (f: 'a_2086 * 'a_2085 -> 'a_2085) =>
	 ((make (int64,
		 'a_2086,
		 'a_2085,
		 'a_2085,
		 'a_2085,
		 'a_2085,
		 'a_2086 Sequence.Slice.t) foldli' ('a_2086, 'a_2085)) f))
val rec ('a_2094, 'a_2093, 'a_2092)
   createi': (int64 * (int64 -> 'a_2093) -> 'a_2092)
	     -> (int64 * 'a_2094 -> 'a_2093)
		-> 'a_2094 Sequence.Slice.t -> 'a_2092 = 
      (fn x_1120: int64 * (int64 -> 'a_2093) -> 'a_2092 =>
       (fn x_1121: int64 * 'a_2094 -> 'a_2093 =>
	(fn x_1122: 'a_2094 Sequence.Slice.t =>
	 case (x_1120, x_1121, x_1122) of
	   (tabulate': int64 * (int64 -> 'a_2093) -> 'a_2092,
	    f: int64 * 'a_2094 -> 'a_2093,
	    T['a_2094] {seq = seq: 'a_2094 vector,
			start = start: int64,
			len = len: int64}) =>
	   (tabulate' (len,
		       (fn x_1123: int64 =>
			case x_1123 of
			  i: int64 =>
			  (f (i, (subUnsafe_0 ('a_2094) (seq, (+? (start, i))))))))))))
val rec ('a_2102, 'a_2101)
   mapi': (int64 * 'a_2102 -> 'a_2101)
	  -> 'a_2102 Sequence.Slice.t -> 'a_2101 vector = 
      (fn x_1124: int64 * 'a_2102 -> 'a_2101 =>
       (fn x_1125: 'a_2102 Sequence.Slice.t =>
	case (x_1124, x_1125) of
	  (f: int64 * 'a_2102 -> 'a_2101, sl: 'a_2102 Sequence.Slice.t) =>
	  (((createi' ('a_2102, 'a_2101, 'a_2101 vector) tabulate' ('a_2101)) f) sl)))
val rec ('a_2104, 'a_2103)
   mapi: (int32 * 'a_2104 -> 'a_2103)
	 -> 'a_2104 Sequence.Slice.t -> 'a_2103 vector = 
      (fn x_1126: int32 * 'a_2104 -> 'a_2103 =>
       (fn x_1127: 'a_2104 Sequence.Slice.t =>
	case (x_1126, x_1127) of
	  (f: int32 * 'a_2104 -> 'a_2103, sl: 'a_2104 Sequence.Slice.t) =>
	  ((mapi' ('a_2104, 'a_2103) (wrap2 ('a_2104, 'a_2103) f)) sl)))
val rec ('a_2106, 'a_2105)
   map: ('a_2105 -> 'a_2106) -> 'a_2105 Sequence.Slice.t -> 'a_2106 vector = 
      (fn x_1128: 'a_2105 -> 'a_2106 =>
       (fn x_1129: 'a_2105 Sequence.Slice.t =>
	case (x_1128, x_1129) of
	  (f: 'a_2105 -> 'a_2106, sl: 'a_2105 Sequence.Slice.t) =>
	  ((mapi ('a_2105, 'a_2106) (o_1 (int32 * 'a_2105, 'a_2106, 'a_2105) (f,
									      (fn x_1130: int32
											  * 'a_2105 =>
									       case x_1130 of
										 {2 = #: 'a_2105} =>
										 #)))) sl)))
val rec 'a_2107
   findi': (int64 * 'a_2107 -> bool)
	   -> 'a_2107 Sequence.Slice.t -> (int64 * 'a_2107) Primitive.Option.t = 
      (fn x_1131: int64 * 'a_2107 -> bool =>
       (fn x_1132: 'a_2107 Sequence.Slice.t =>
	case (x_1131, x_1132) of
	  (p: int64 * 'a_2107 -> bool,
	   T['a_2107] {seq = seq: 'a_2107 vector,
		       start = start: int64,
		       len = len: int64}) =>
	  let val min: int64 = start
	      val len: int64 = (-? (len, 0x1))
	      val max: int64 = (+? (start, len))
	      val rec
		 loop: int64 -> (int64 * 'a_2107) Primitive.Option.t = 
		    (fn x_1133: int64 =>
		     case x_1133 of
		       (i: int64) =>
		       case (> (i, max)) of
			 true => NONE[int64 * 'a_2107]
		       | false =>
			 let val z: int64 * 'a_2107 =
				((-? (i, min)), (subUnsafe_0 ('a_2107) (seq, i)))
			 in
			    case (p z) of
			      true => (SOME[int64 * 'a_2107] z)
			    | false => (loop (+? (i, 0x1)))
			 end)
	  in
	     (loop min)
	  end))
val rec 'a_2110
   existsi': (int64 * 'a_2110 -> bool) -> 'a_2110 Sequence.Slice.t -> bool = 
      (fn x_1134: int64 * 'a_2110 -> bool =>
       (fn x_1135: 'a_2110 Sequence.Slice.t =>
	case (x_1134, x_1135) of
	  (p: int64 * 'a_2110 -> bool, sl: 'a_2110 Sequence.Slice.t) =>
	  (isSome_0 (int64 * 'a_2110) ((findi' ('a_2110) p) sl))))
val rec 'a_2111
   existsi: (int32 * 'a_2111 -> bool) -> 'a_2111 Sequence.Slice.t -> bool = 
      (fn x_1136: int32 * 'a_2111 -> bool =>
       (fn x_1137: 'a_2111 Sequence.Slice.t =>
	case (x_1136, x_1137) of
	  (p: int32 * 'a_2111 -> bool, sl: 'a_2111 Sequence.Slice.t) =>
	  ((existsi' ('a_2111) (wrap2 ('a_2111, bool) p)) sl)))
val rec 'a_2112
   exists: ('a_2112 -> bool) -> 'a_2112 Sequence.Slice.t -> bool = 
      (fn x_1138: 'a_2112 -> bool =>
       (fn x_1139: 'a_2112 Sequence.Slice.t =>
	case (x_1138, x_1139) of
	  (p: 'a_2112 -> bool, sl: 'a_2112 Sequence.Slice.t) =>
	  ((existsi ('a_2112) (o_1 (int32 * 'a_2112, bool, 'a_2112) (p,
								     (fn x_1140: int32
										 * 'a_2112 =>
								      case x_1140 of
									{2 = #: 'a_2112} =>
									#)))) sl)))
val rec 'a
   sequence: 'a Sequence.Slice.t -> 'a vector = 
      (fn x_1141: 'a Sequence.Slice.t =>
       case x_1141 of
	 (sl: 'a Sequence.Slice.t as T['a] {seq = seq: 'a vector,
					    start = start: int64,
					    len = len: int64}) =>
	 case case isMutable of
		true => true
	      | false =>
		case (<> (int64) (start, 0x0)) of
		  true => true
		| false => (<> (int64) (len, (length_1 ('a) seq))) of
	   true =>
	   ((map ('a, 'a) (fn x_1142: 'a =>
			   case x_1142 of
			     x: 'a => x)) sl)
	 | false => seq)
val rec 'a
   append: 'a Sequence.Slice.t * 'a Sequence.Slice.t -> 'a vector = 
      (fn x_1143: 'a Sequence.Slice.t * 'a Sequence.Slice.t =>
       case x_1143 of
	 ((sl1: 'a Sequence.Slice.t, sl2: 'a Sequence.Slice.t)) =>
	 case (= (int64) ((length' ('a) sl1), 0x0)) of
	   true => (sequence ('a) sl2)
	 | false =>
	   case (= (int64) ((length' ('a) sl2), 0x0)) of
	     true => (sequence ('a) sl1)
	   | false =>
	     let val l1: int64 = (length' ('a) sl1)
		 val l2: int64 = (length' ('a) sl2)
		 val n: int64 =
		    (+ (l1, l2))
		    handle x_1144 => case x_1144 of
				       Overflow => raise Size
	     in
		((fn x_1145: 'a vector * (int64 * 'a Sequence.Slice.t) =>
		  case x_1145 of
		    {1 = #: 'a vector} => #) (unfoldi' (int64 * 'a Sequence.Slice.t, 'a) (n,
								      (0x0, sl1),
								      (fn x_1146: int64
										  * (int64
										     * 'a Sequence.Slice.t) =>
								       case x_1146 of
									 (_,
									  (i: int64,
									   sl: 'a Sequence.Slice.t)) =>
									 case (< (i,
										  (length' ('a) sl))) of
									   true =>
									   ((unsafeSub' ('a) (sl,
											      i)),
									    ((+? (i,
										  0x1)),
									     sl))
									 | false =>
									   ((unsafeSub' ('a) (sl2,
											      0x0)),
									    (0x1,
									     sl2))))))
	     end)
val rec 'a
   concat: 'a Sequence.Slice.t list -> 'a vector = 
      (fn x_1147: 'a Sequence.Slice.t list =>
       case x_1147 of
	 (sls: 'a Sequence.Slice.t list) =>
	 case sls of
	   [] => (seq0 ('a) ())
	 | [sl: 'a Sequence.Slice.t] => (sequence ('a) sl)
	 | sls': 'a Sequence.Slice.t list as ::['a Sequence.Slice.t] (sl: 'a Sequence.Slice.t,
								      sls: 'a Sequence.Slice.t list) =>
	   let val n: int64 =
		  (((foldl_0 (int64, 'a Sequence.Slice.t) (fn x_1149: 'a Sequence.Slice.t
								      * int64 =>
							   case x_1149 of
							     (sl: 'a Sequence.Slice.t,
							      s: int64) =>
							     (+? (s,
								  (length' ('a) sl))))) 0x0) sls')
		  handle x_1148 => case x_1148 of
				     Overflow => raise Size
	   in
	      ((fn x_1150: 'a vector
			   * (int64
			      * 'a Sequence.Slice.t
			      * 'a Sequence.Slice.t list) =>
		case x_1150 of
		  {1 = #: 'a vector} => #) (unfoldi' (int64
				    * 'a Sequence.Slice.t
				    * 'a Sequence.Slice.t list,
				    'a) (n,
					 (0x0, sl, sls),
					 (fn x_1151: int64
						     * (int64
							* 'a Sequence.Slice.t
							* 'a Sequence.Slice.t list) =>
					  case x_1151 of
					    (_,
					     ac: int64
						 * 'a Sequence.Slice.t
						 * 'a Sequence.Slice.t list) =>
					    let val rec 'a_2118
						   loop: int64
							 * 'a_2118 Sequence.Slice.t
							 * 'a_2118 Sequence.Slice.t list
							 -> 'a_2118
							    * (int64
							       * 'a_2118 Sequence.Slice.t
							       * 'a_2118 Sequence.Slice.t list) = 
						      (fn x_1152: int64
								  * 'a_2118 Sequence.Slice.t
								  * 'a_2118 Sequence.Slice.t list =>
						       case x_1152 of
							 ((i: int64,
							   sl: 'a_2118 Sequence.Slice.t,
							   sls: 'a_2118 Sequence.Slice.t list)) =>
							 case (< (i,
								  (length' ('a_2118) sl))) of
							   true =>
							   ((unsafeSub' ('a_2118) (sl,
										   i)),
							    ((+? (i, 0x1)),
							     sl,
							     sls))
							 | false =>
							   case sls of
							     [] =>
							     raise (Fail "Sequence.Slice.concat")
							   | ::['a_2118 Sequence.Slice.t] (sl: 'a_2118 Sequence.Slice.t,
											   sls: 'a_2118 Sequence.Slice.t list) =>
							     (loop ('a_2118) (0x0,
									      sl,
									      sls)))
					    in
					       (loop ('a) ac)
					    end))))
	   end)
val rec 'a
   isPrefix: ('a * 'a -> bool) -> 'a vector -> 'a Sequence.Slice.t -> bool = 
      (fn x_1153: 'a * 'a -> bool =>
       (fn x_1154: 'a vector =>
	(fn x_1155: 'a Sequence.Slice.t =>
	 case (x_1153, x_1154, x_1155) of
	   (eq: 'a * 'a -> bool, seq: 'a vector, sl: 'a Sequence.Slice.t) =>
	   let val n: int64 = (length_1 ('a) seq)
	       val n': int64 = (length' ('a) sl)
	   in
	      case (<= (n, n')) of
		true =>
		let val rec
		       loop: int64 -> bool = 
			  (fn x_1156: int64 =>
			   case x_1156 of
			     (j: int64) =>
			     case (>= (j, n)) of
			       true => true
			     | false =>
			       case (eq ((subUnsafe_0 ('a) (seq, j)),
					 (unsafeSub' ('a) (sl, j)))) of
				 true => (loop (+? (j, 0x1))) | false => false)
		in
		   (loop 0x0)
		end
	      | false => false
	   end)))
val rec 'a_2121
   split': 'a_2121 Sequence.Slice.t * int64
	   -> 'a_2121 Sequence.Slice.t * 'a_2121 Sequence.Slice.t = 
      (fn x_1157: 'a_2121 Sequence.Slice.t * int64 =>
       case x_1157 of
	 ((T['a_2121] {seq = seq: 'a_2121 vector,
		       start = start: int64,
		       len = len: int64},
	   i: int64)) =>
	 ((unsafeSlice' ('a_2121) (seq, start, (SOME[int64] (-? (i, start))))),
	  (unsafeSlice' ('a_2121) (seq,
				   i,
				   (SOME[int64] (-? (len, (-? (i, start)))))))))
val rec 'a_2122
   splitl: ('a_2122 -> bool)
	   -> 'a_2122 Sequence.Slice.t
	      -> 'a_2122 Sequence.Slice.t * 'a_2122 Sequence.Slice.t = 
      (fn x_1158: 'a_2122 -> bool =>
       (fn x_1159: 'a_2122 Sequence.Slice.t =>
	case (x_1158, x_1159) of
	  (f: 'a_2122 -> bool,
	   sl: 'a_2122 Sequence.Slice.t as T['a_2122] {seq = seq: 'a_2122 vector,
						       start = start: int64,
						       len = len: int64}) =>
	  let val stop: int64 = (+? (start, len))
	      val rec
		 loop: int64 -> int64 = 
		    (fn x_1160: int64 =>
		     case x_1160 of
		       (i: int64) =>
		       case (>= (i, stop)) of
			 true => i
		       | false =>
			 case (f (subUnsafe_0 ('a_2122) (seq, i))) of
			   true => (loop (+? (i, 0x1))) | false => i)
	  in
	     (split' ('a_2122) (sl, (loop start)))
	  end))
val rec 'a_2123
   splitr: ('a_2123 -> bool)
	   -> 'a_2123 Sequence.Slice.t
	      -> 'a_2123 Sequence.Slice.t * 'a_2123 Sequence.Slice.t = 
      (fn x_1161: 'a_2123 -> bool =>
       (fn x_1162: 'a_2123 Sequence.Slice.t =>
	case (x_1161, x_1162) of
	  (f: 'a_2123 -> bool,
	   sl: 'a_2123 Sequence.Slice.t as T['a_2123] {seq = seq: 'a_2123 vector,
						       start = start: int64,
						       len = len: int64}) =>
	  let val rec
		 loop: int64 -> int64 = 
		    (fn x_1163: int64 =>
		     case x_1163 of
		       (i: int64) =>
		       case (< (i, start)) of
			 true => start
		       | false =>
			 case (f (subUnsafe_0 ('a_2123) (seq, i))) of
			   true => (loop (-? (i, 0x1))) | false => (+? (i, 0x1)))
	  in
	     (split' ('a_2123) (sl, (loop (-? ((+? (start, len)), 0x1)))))
	  end))
val rec 'a_2127
   dropr: ('a_2127 -> bool)
	  -> 'a_2127 Sequence.Slice.t -> 'a_2127 Sequence.Slice.t = 
      (fn x_1164: 'a_2127 -> bool =>
       (fn x_1165: 'a_2127 Sequence.Slice.t =>
	case (x_1164, x_1165) of
	  (p: 'a_2127 -> bool, s: 'a_2127 Sequence.Slice.t) =>
	  ((fn x_1166: 'a_2127 Sequence.Slice.t * 'a_2127 Sequence.Slice.t =>
	    case x_1166 of
	      {1 = #: 'a_2127 Sequence.Slice.t} => #) ((splitr ('a_2127) p) s))))
val rec 'a_2128
   takel: ('a_2128 -> bool)
	  -> 'a_2128 Sequence.Slice.t -> 'a_2128 Sequence.Slice.t = 
      (fn x_1167: 'a_2128 -> bool =>
       (fn x_1168: 'a_2128 Sequence.Slice.t =>
	case (x_1167, x_1168) of
	  (p: 'a_2128 -> bool, s: 'a_2128 Sequence.Slice.t) =>
	  ((fn x_1169: 'a_2128 Sequence.Slice.t * 'a_2128 Sequence.Slice.t =>
	    case x_1169 of
	      {1 = #: 'a_2128 Sequence.Slice.t} => #) ((splitl ('a_2128) p) s))))
val rec 'a_2129
   taker: ('a_2129 -> bool)
	  -> 'a_2129 Sequence.Slice.t -> 'a_2129 Sequence.Slice.t = 
      (fn x_1170: 'a_2129 -> bool =>
       (fn x_1171: 'a_2129 Sequence.Slice.t =>
	case (x_1170, x_1171) of
	  (p: 'a_2129 -> bool, s: 'a_2129 Sequence.Slice.t) =>
	  ((fn x_1172: 'a_2129 Sequence.Slice.t * 'a_2129 Sequence.Slice.t =>
	    case x_1172 of
	      {2 = #: 'a_2129 Sequence.Slice.t} => #) ((splitr ('a_2129) p) s))))
val rec ('a_2130, 'a)
   translate: ('a -> 'a_2130 vector) -> 'a Sequence.Slice.t -> 'a_2130 vector = 
      (fn x_1173: 'a -> 'a_2130 vector =>
       (fn x_1174: 'a Sequence.Slice.t =>
	case (x_1173, x_1174) of
	  (f: 'a -> 'a_2130 vector, sl: 'a Sequence.Slice.t) =>
	  (concat ('a_2130) (rev_0 ('a_2130 Sequence.Slice.t) (((foldl ('a,
									'a_2130 Sequence.Slice.t list) (fn x_1175: 'a
														   * 'a_2130 Sequence.Slice.t list =>
													case x_1175 of
													  (c: 'a,
													   l: 'a_2130 Sequence.Slice.t list) =>
													  (::['a_2130 Sequence.Slice.t] ((full ('a_2130) (f c)),
																	 l)))) []) sl)))))
val rec ('a_2136, 'a_2135)
   make: ('a_2136 Sequence.Slice.t -> 'a_2135) -> 'a_2136 vector -> 'a_2135 = 
      (fn x_1176: 'a_2136 Sequence.Slice.t -> 'a_2135 =>
       (fn x_1177: 'a_2136 vector =>
	case (x_1176, x_1177) of
	  (f: 'a_2136 Sequence.Slice.t -> 'a_2135, seq: 'a_2136 vector) =>
	  (f (full ('a_2136) seq))))
val rec ('a_2139, 'a_2138, 'a_2137)
   make2: ('a_2139 Sequence.Slice.t * 'a_2138 Sequence.Slice.t -> 'a_2137)
	  -> 'a_2139 vector * 'a_2138 vector -> 'a_2137 = 
      (fn x_1178: 'a_2139 Sequence.Slice.t * 'a_2138 Sequence.Slice.t -> 'a_2137 =>
       (fn x_1179: 'a_2139 vector * 'a_2138 vector =>
	case (x_1178, x_1179) of
	  (f: 'a_2139 Sequence.Slice.t * 'a_2138 Sequence.Slice.t -> 'a_2137,
	   (seq1: 'a_2139 vector, seq2: 'a_2138 vector)) =>
	  (f ((full ('a_2139) seq1), (full ('a_2138) seq2)))))
val rec 'a_2140
   sub: 'a_2140 vector * int32 -> 'a_2140 = 
      (fn x_1180: 'a_2140 vector * int32 =>
       case x_1180 of
	 ((seq: 'a_2140 vector, i: int32)) =>
	 (sub ('a_2140) ((full ('a_2140) seq), i)))
val rec 'a_2156
   append: 'a_2156 vector * 'a_2156 vector -> 'a_2156 vector = 
      (fn x_1181: 'a_2156 vector * 'a_2156 vector =>
       case x_1181 of
	 (seqs: 'a_2156 vector * 'a_2156 vector) =>
	 ((make2 ('a_2156, 'a_2156, 'a_2156 vector) append ('a_2156)) seqs))
val rec 'a_2157
   concat: 'a_2157 vector list -> 'a_2157 vector = 
      (fn x_1182: 'a_2157 vector list =>
       case x_1182 of
	 (seqs: 'a_2157 vector list) =>
	 (concat ('a_2157) ((map_1 ('a_2157 Sequence.Slice.t, 'a_2157 vector) full ('a_2157)) seqs)))
val rec 'a_2184
   exists: ('a_2184 -> bool) -> 'a_2184 vector -> bool = 
      (fn x_1183: 'a_2184 -> bool =>
       case x_1183 of
	 (p: 'a_2184 -> bool) => (make ('a_2184, bool) (exists ('a_2184) p)))
val rec 'a_2191
   isPrefix: ('a_2191 * 'a_2191 -> bool)
	     -> 'a_2191 vector -> 'a_2191 vector -> bool = 
      (fn x_1184: 'a_2191 * 'a_2191 -> bool =>
       (fn x_1185: 'a_2191 vector =>
	case (x_1184, x_1185) of
	  (eq: 'a_2191 * 'a_2191 -> bool, seq: 'a_2191 vector) =>
	  (make ('a_2191, bool) ((isPrefix ('a_2191) eq) seq))))
val rec ('a_2195, 'a_2194)
   translate: ('a_2194 -> 'a_2195 vector) -> 'a_2194 vector -> 'a_2195 vector = 
      (fn x_1186: 'a_2194 -> 'a_2195 vector =>
       case x_1186 of
	 (f: 'a_2194 -> 'a_2195 vector) =>
	 (make ('a_2194, 'a_2195 vector) (translate ('a_2195, 'a_2194) f)))
val ('b, 'a) translate_0: ('a -> 'b vector) -> 'a vector -> 'b vector =
   translate ('b, 'a)
val 'a tabulate'_0: int64 * (int64 -> 'a) -> 'a vector = tabulate' ('a)
val 'a tabulate_0: int32 * (int32 -> 'a) -> 'a vector = tabulate ('a)
val 'a sub_0: 'a vector * int32 -> 'a = sub ('a)
val 'a new_0: int32 * 'a -> 'a vector = new ('a)
val 'a length_2: 'a vector -> int32 = length ('a)
val 'a isPrefix_0: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool =
   isPrefix ('a)
val 'a fromList_0: 'a list -> 'a vector = fromList ('a)
val 'a exists_0: ('a -> bool) -> 'a vector -> bool = exists ('a)
val 'a concat_0: 'a vector list -> 'a vector = concat ('a)
val 'a append_0: 'a vector * 'a vector -> 'a vector = append ('a)
val 'a unsafeSub'_0: 'a Sequence.Slice.t * int64 -> 'a = unsafeSub' ('a)
val 'a taker_0: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   taker ('a)
val 'a takel_0: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   takel ('a)
val 'a sub_1: 'a Sequence.Slice.t * int32 -> 'a = sub ('a)
val 'a slice_0: 'a vector * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice ('a)
val 'a sequence_0: 'a Sequence.Slice.t -> 'a vector = sequence ('a)
val 'a length_3: 'a Sequence.Slice.t -> int32 = length ('a)
val 'a full_0: 'a vector -> 'a Sequence.Slice.t = full ('a)
val 'a dropr_0: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   dropr ('a)
val 'a base_0: 'a Sequence.Slice.t -> 'a vector * int32 * int32 = base ('a)
val 'a_2220 vector: 'a_2220 Sequence.Slice.t -> 'a_2220 vector =
   sequence_0 ('a_2220)
val 'a_2224 unsafeFromArray: 'a_2224 array -> 'a_2224 vector =
   fromArrayUnsafe ('a_2224)
val 'a_2225 vector: int32 * 'a_2225 -> 'a_2225 vector = new_0 ('a_2225)
val 'a vector_0: int32 * 'a -> 'a vector = vector ('a)
val 'a unsafeFromArray_0: 'a array -> 'a vector = unsafeFromArray ('a)
val ('b, 'a) translate_1: ('a -> 'b vector) -> 'a vector -> 'b vector =
   translate_0 ('b, 'a)
val 'a tabulate'_1: int64 * (int64 -> 'a) -> 'a vector = tabulate'_0 ('a)
val 'a tabulate_1: int32 * (int32 -> 'a) -> 'a vector = tabulate_0 ('a)
val 'a sub_2: 'a vector * int32 -> 'a = sub_0 ('a)
val 'a length_4: 'a vector -> int32 = length_2 ('a)
val 'a isPrefix_1: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool =
   isPrefix_0 ('a)
val 'a fromList_1: 'a list -> 'a vector = fromList_0 ('a)
val 'a exists_1: ('a -> bool) -> 'a vector -> bool = exists_0 ('a)
val 'a concat_1: 'a vector list -> 'a vector = concat_0 ('a)
val 'a append_1: 'a vector * 'a vector -> 'a vector = append_0 ('a)
val 'a vector_1: 'a Sequence.Slice.t -> 'a vector = vector ('a)
val 'a unsafeSub'_1: 'a Sequence.Slice.t * int64 -> 'a = unsafeSub'_0 ('a)
val 'a taker_1: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   taker_0 ('a)
val 'a takel_1: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   takel_0 ('a)
val 'a sub_3: 'a Sequence.Slice.t * int32 -> 'a = sub_1 ('a)
val 'a slice_1: 'a vector * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice_0 ('a)
val 'a length_5: 'a Sequence.Slice.t -> int32 = length_3 ('a)
val 'a full_1: 'a vector -> 'a Sequence.Slice.t = full_0 ('a)
val 'a dropr_1: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   dropr_0 ('a)
val 'a base_1: 'a Sequence.Slice.t -> 'a vector * int32 * int32 = base_0 ('a)
val 'a full_2: 'a vector -> 'a Sequence.Slice.t = full_1 ('a)
val 'a base_2: 'a Sequence.Slice.t -> 'a vector * int32 * int32 = base_1 ('a)
val 'a_2240 fromArray: 'a_2240 -> 'a_2240 =
   (fn x_1187: 'a_2240 =>
    case x_1187 of
      a: 'a_2240 => a)
val isMutable: bool = true
val 'a_2241 length: 'a_2241 array -> int64 = length ('a_2241)
val 'a_2242 subUnsafe: 'a_2242 array * int64 -> 'a_2242 = subUnsafe ('a_2242)
val 'a subUnsafe_1: 'a array * int64 -> 'a = subUnsafe ('a)
val 'a length_6: 'a array -> int64 = length ('a)
val 'a fromArray_1: 'a array -> 'a array = fromArray ('a array)
val +?: int64 * int64 -> int64 = +?
val -?: int64 * int64 -> int64 = -?
val <: int64 * int64 -> bool = <
val >: int64 * int64 -> bool = >
val >=: int64 * int64 -> bool = >=
val gtu: int64 * int64 -> bool = gtu
val geu: int64 * int64 -> bool = geu
val rec ('a_2248, 'a_2247)
   wrap2: (int32 * 'a_2248 -> 'a_2247) -> int64 * 'a_2248 -> 'a_2247 = 
      (fn x_1188: int32 * 'a_2248 -> 'a_2247 =>
       case x_1188 of
	 (f: int32 * 'a_2248 -> 'a_2247) =>
	 (fn x_1189: int64 * 'a_2248 =>
	  case x_1189 of
	    (i: int64, x: 'a_2248) => (f ((toIntUnsafe i), x))))
val rec ('a_2251, 'a_2250, 'a_2249)
   wrap3: (int32 * 'a_2251 * 'a_2250 -> 'a_2249)
	  -> int64 * 'a_2251 * 'a_2250 -> 'a_2249 = 
      (fn x_1190: int32 * 'a_2251 * 'a_2250 -> 'a_2249 =>
       case x_1190 of
	 (f: int32 * 'a_2251 * 'a_2250 -> 'a_2249) =>
	 (fn x_1191: int64 * 'a_2251 * 'a_2250 =>
	  case x_1191 of
	    (i: int64, x: 'a_2251, y: 'a_2250) => (f ((toIntUnsafe i), x, y))))
val rec 'a_2255
   doit: int32 * (int64 -> 'a_2255) * ('a_2255 -> int64) * 'a_2255
	 -> int64 * 'a_2255 = 
      (fn x_1192: int32 * (int64 -> 'a_2255) * ('a_2255 -> int64) * 'a_2255 =>
       case x_1192 of
	 ((precision: int32,
	   toInt: int64 -> 'a_2255,
	   fromInt: 'a_2255 -> int64,
	   maxInt': 'a_2255)) =>
	 case (>= ((valOf_1 (int32) precision), precision)) of
	   true => ((fromInt maxInt'), maxInt')
	 | false => (maxLen', (toInt maxLen')))
val fInt8: int64 * int8 =
   (doit (int8) ((valOf_1 (int32) precision),
		 schckToInt8,
		 schckFromInt8,
		 maxInt'))
val fInt16: int64 * int16 =
   (doit (int16) ((valOf_1 (int32) precision),
		  schckToInt16,
		  schckFromInt16,
		  maxInt'))
val fInt32: int64 * int32 =
   (doit (int32) ((valOf_1 (int32) precision),
		  schckToInt32,
		  schckFromInt32,
		  maxInt'))
val fInt64: int64 * int64 =
   (doit (int64) ((valOf_1 (int32) precision),
		  schckToInt64,
		  schckFromInt64,
		  maxInt'))
val fIntInf: int64 * intInf = (maxLen', (schckToIntInf maxLen'))
val _ = fInt8
val _ = fInt16
val f: int64 * int32 = fInt32
val _ = fInt64
val _ = fIntInf
val (maxLen': int64, maxLen: int32) = f
val rec
   fromIntForLength: int32 -> int64 = 
      (fn x_1193: int32 =>
       case x_1193 of
	 (n: int32) =>
	 case safe of
	   true =>
	   (fromInt n)
	   handle x_1194 => case x_1194 of
			      Overflow => raise Size
	 | false => (fromIntUnsafe n))
val rec 'a_2258
   length': 'a_2258 array -> int64 = 
      (fn x_1195: 'a_2258 array =>
       case x_1195 of
	 (s: 'a_2258 array) => (length_6 ('a_2258) s))
val rec 'a_2259
   length: 'a_2259 array -> int32 = 
      (fn x_1196: 'a_2259 array =>
       case x_1196 of
	 (s: 'a_2259 array) =>
	 case safe of
	   true =>
	   (toInt (length' ('a_2259) s))
	   handle x_1197 => case x_1197 of
			      Overflow => raise (Fail "Sequence.length")
	 | false => (toIntUnsafe (length' ('a_2259) s)))
val rec 'a_2260
   arrayUninit': int64 -> 'a_2260 array = 
      (fn x_1198: int64 =>
       case x_1198 of
	 (n: int64) =>
	 case case (not isMutable) of
		true => (= (int64) (n, 0x0)) | false => false of
	   true => (array0Const ('a_2260) ())
	 | false =>
	   case case safe of
		  true => (gtu (n, maxLen')) | false => false of
	     true => raise Size | false => (arrayUnsafe ('a_2260) n))
val rec 'a_2261
   arrayUninit: int32 -> 'a_2261 array = 
      (fn x_1199: int32 =>
       case x_1199 of
	 (n: int32) => (arrayUninit' ('a_2261) (fromIntForLength n)))
val rec 'a_2263
   newUninit: int32 -> 'a_2263 array = 
      (fn x_1200: int32 =>
       case x_1200 of
	 (n: int32) => (fromArray_1 ('a_2263) (arrayUninit ('a_2263) n)))
val rec ('a_2267, 'a_2266)
   unfoldi': int64 * 'a_2267 * (int64 * 'a_2267 -> 'a_2266 * 'a_2267)
	     -> 'a_2266 array * 'a_2267 = 
      (fn x_1201: int64 * 'a_2267 * (int64 * 'a_2267 -> 'a_2266 * 'a_2267) =>
       case x_1201 of
	 ((n: int64, b: 'a_2267, f: int64 * 'a_2267 -> 'a_2266 * 'a_2267)) =>
	 let val a: 'a_2266 array = (arrayUninit' ('a_2266) n)
	     val rec
		loop: int64 * 'a_2267 -> 'a_2267 = 
		   (fn x_1202: int64 * 'a_2267 =>
		    case x_1202 of
		      ((i: int64, b: 'a_2267)) =>
		      case (>= (i, n)) of
			true => b
		      | false =>
			let val (x: 'a_2266, b': 'a_2267) = (f (i, b))
			    val () = (updateUnsafe ('a_2266) (a, i, x))
			in
			   (loop ((+? (i, 0x1)), b'))
			end)
	     val b: 'a_2267 = (loop (0x0, b))
	 in
	    ((fromArray_1 ('a_2266) a), b)
	 end)
val rec ('a_2269, 'a_2268)
   unfoldi: int32 * 'a_2268 * (int32 * 'a_2268 -> 'a_2269 * 'a_2268)
	    -> 'a_2269 array * 'a_2268 = 
      (fn x_1203: int32 * 'a_2268 * (int32 * 'a_2268 -> 'a_2269 * 'a_2268) =>
       case x_1203 of
	 ((n: int32, b: 'a_2268, f: int32 * 'a_2268 -> 'a_2269 * 'a_2268)) =>
	 (unfoldi' ('a_2268, 'a_2269) ((fromIntForLength n),
				       b,
				       (wrap2 ('a_2268, 'a_2269 * 'a_2268) f))))
val rec 'a_2274
   tabulate: int32 * (int32 -> 'a_2274) -> 'a_2274 array = 
      (fn x_1204: int32 * (int32 -> 'a_2274) =>
       case x_1204 of
	 ((n: int32, f: int32 -> 'a_2274)) =>
	 ((fn x_1205: 'a_2274 array * unit =>
	   case x_1205 of
	     {1 = #: 'a_2274 array} => #) (unfoldi ('a_2274, unit) (n,
						       (),
						       (fn x_1206: int32 * unit =>
							case x_1206 of
							  (i: int32, ()) =>
							  ((f i), ()))))))
val rec 'a_2276
   new: int32 * 'a_2276 -> 'a_2276 array = 
      (fn x_1207: int32 * 'a_2276 =>
       case x_1207 of
	 ((n: int32, x: 'a_2276)) =>
	 (tabulate ('a_2276) (n, (fn x_1208: int32 => case x_1208 of _ => x))))
datatype 'a Sequence.Slice.t = T of {len: int64, seq: 'a array, start: int64}
val rec 'a_2280
   unsafeSub': 'a_2280 Sequence.Slice.t * int64 -> 'a_2280 = 
      (fn x_1209: 'a_2280 Sequence.Slice.t * int64 =>
       case x_1209 of
	 ((T['a_2280] {seq = seq: 'a_2280 array, start = start: int64}, i: int64)) =>
	 (subUnsafe_1 ('a_2280) (seq, (+? (start, i)))))
val rec 'a_2281
   unsafeSub: 'a_2281 Sequence.Slice.t * int32 -> 'a_2281 = 
      (fn x_1210: 'a_2281 Sequence.Slice.t * int32 =>
       case x_1210 of
	 ((sl: 'a_2281 Sequence.Slice.t, i: int32)) =>
	 (unsafeSub' ('a_2281) (sl, (fromIntUnsafe i))))
val rec 'a_2282
   sub': 'a_2282 Sequence.Slice.t * int64 -> 'a_2282 = 
      (fn x_1211: 'a_2282 Sequence.Slice.t * int64 =>
       case x_1211 of
	 ((sl: 'a_2282 Sequence.Slice.t as T['a_2282] {len = len: int64},
	   i: int64)) =>
	 case case safe of
		true => (geu (i, len)) | false => false of
	   true => raise Subscript | false => (unsafeSub' ('a_2282) (sl, i)))
val rec 'a_2283
   sub: 'a_2283 Sequence.Slice.t * int32 -> 'a_2283 = 
      (fn x_1212: 'a_2283 Sequence.Slice.t * int32 =>
       case x_1212 of
	 ((sl: 'a_2283 Sequence.Slice.t, i: int32)) =>
	 case safe of
	   true =>
	   let val i: int64 =
		  (fromInt i)
		  handle x_1213 => case x_1213 of
				     Overflow => raise Subscript
	   in
	      (sub' ('a_2283) (sl, i))
	   end
	 | false => (unsafeSub ('a_2283) (sl, i)))
val rec ('a_2286, 'a_2285, 'a_2284)
   unsafeUpdate'Mk: ('a_2286 array * int64 * 'a_2285 -> 'a_2284)
		    -> 'a_2286 Sequence.Slice.t * int64 * 'a_2285 -> 'a_2284 = 
      (fn x_1214: 'a_2286 array * int64 * 'a_2285 -> 'a_2284 =>
       (fn x_1215: 'a_2286 Sequence.Slice.t * int64 * 'a_2285 =>
	case (x_1214, x_1215) of
	  (updateUnsafe: 'a_2286 array * int64 * 'a_2285 -> 'a_2284,
	   (T['a_2286] {seq = seq: 'a_2286 array, start = start: int64},
	    i: int64,
	    x: 'a_2285)) =>
	  (updateUnsafe (seq, (+? (start, i)), x))))
val rec ('a_2289, 'a_2288, 'a_2287)
   unsafeUpdateMk: ('a_2289 array * int64 * 'a_2288 -> 'a_2287)
		   -> 'a_2289 Sequence.Slice.t * int32 * 'a_2288 -> 'a_2287 = 
      (fn x_1216: 'a_2289 array * int64 * 'a_2288 -> 'a_2287 =>
       (fn x_1217: 'a_2289 Sequence.Slice.t * int32 * 'a_2288 =>
	case (x_1216, x_1217) of
	  (updateUnsafe: 'a_2289 array * int64 * 'a_2288 -> 'a_2287,
	   (sl: 'a_2289 Sequence.Slice.t, i: int32, x: 'a_2288)) =>
	  ((unsafeUpdate'Mk ('a_2289, 'a_2288, 'a_2287) updateUnsafe) (sl,
								       (fromIntUnsafe i),
								       x))))
val rec ('a_2292, 'a_2291, 'a_2290)
   update'Mk: ('a_2292 array * int64 * 'a_2291 -> 'a_2290)
	      -> 'a_2292 Sequence.Slice.t * int64 * 'a_2291 -> 'a_2290 = 
      (fn x_1218: 'a_2292 array * int64 * 'a_2291 -> 'a_2290 =>
       (fn x_1219: 'a_2292 Sequence.Slice.t * int64 * 'a_2291 =>
	case (x_1218, x_1219) of
	  (updateUnsafe: 'a_2292 array * int64 * 'a_2291 -> 'a_2290,
	   (sl: 'a_2292 Sequence.Slice.t as T['a_2292] {len = len: int64},
	    i: int64,
	    x: 'a_2291)) =>
	  case case safe of
		 true => (geu (i, len)) | false => false of
	    true => raise Subscript
	  | false =>
	    ((unsafeUpdate'Mk ('a_2292, 'a_2291, 'a_2290) updateUnsafe) (sl,
									 i,
									 x))))
val rec ('a_2295, 'a_2294, 'a_2293)
   updateMk: ('a_2295 array * int64 * 'a_2294 -> 'a_2293)
	     -> 'a_2295 Sequence.Slice.t * int32 * 'a_2294 -> 'a_2293 = 
      (fn x_1220: 'a_2295 array * int64 * 'a_2294 -> 'a_2293 =>
       (fn x_1221: 'a_2295 Sequence.Slice.t * int32 * 'a_2294 =>
	case (x_1220, x_1221) of
	  (updateUnsafe: 'a_2295 array * int64 * 'a_2294 -> 'a_2293,
	   (sl: 'a_2295 Sequence.Slice.t, i: int32, x: 'a_2294)) =>
	  case safe of
	    true =>
	    let val i: int64 =
		   (fromInt i)
		   handle x_1222 => case x_1222 of
				      Overflow => raise Subscript
	    in
	       ((update'Mk ('a_2295, 'a_2294, 'a_2293) updateUnsafe) (sl, i, x))
	    end
	  | false =>
	    ((unsafeUpdateMk ('a_2295, 'a_2294, 'a_2293) updateUnsafe) (sl, i, x))))
val rec 'a
   full: 'a array -> 'a Sequence.Slice.t = 
      (fn x_1223: 'a array =>
       case x_1223 of
	 (seq: 'a array) =>
	 (T['a] {seq = seq, start = 0x0, len = (length_6 ('a) seq)}))
val rec 'a_2296
   unsafeSubslice': 'a_2296 Sequence.Slice.t * int64 * int64 Primitive.Option.t
		    -> 'a_2296 Sequence.Slice.t = 
      (fn x_1224: 'a_2296 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1224 of
	 ((T['a_2296] {seq = seq: 'a_2296 array,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 (T['a_2296] {seq = seq,
		      start = (+? (start, start')),
		      len = case len' of
			      NONE[int64] => (-? (len, start'))
			    | SOME[int64] len': int64 => len'}))
val rec 'a_2297
   unsafeSubslice: 'a_2297 Sequence.Slice.t * int32 * int32 Primitive.Option.t
		   -> 'a_2297 Sequence.Slice.t = 
      (fn x_1225: 'a_2297 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1225 of
	 ((sl: 'a_2297 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 (unsafeSubslice' ('a_2297) (sl,
				     (fromIntUnsafe start),
				     ((map_0 (int64, int32) fromIntUnsafe) len))))
val rec 'a_2300
   subslice': 'a_2300 Sequence.Slice.t * int64 * int64 Primitive.Option.t
	      -> 'a_2300 Sequence.Slice.t = 
      (fn x_1226: 'a_2300 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1226 of
	 ((T['a_2300] {seq = seq: 'a_2300 array,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 case len' of
	   NONE[int64] =>
	   case case safe of
		  true => (gtu (start', len)) | false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2300] {seq = seq,
			  start = (+? (start, start')),
			  len = (-? (len, start'))})
	 | SOME[int64] len': int64 =>
	   case case safe of
		  true =>
		  case (gtu (start', len)) of
		    true => true | false => (gtu (len', (-? (len, start'))))
		| false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2300] {seq = seq, start = (+? (start, start')), len = len'}))
val rec 'a_2301
   subslice: 'a_2301 Sequence.Slice.t * int32 * int32 Primitive.Option.t
	     -> 'a_2301 Sequence.Slice.t = 
      (fn x_1227: 'a_2301 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1227 of
	 ((sl: 'a_2301 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 case safe of
	   true =>
	   (subslice' ('a_2301) (sl,
				 (fromInt start),
				 ((map_0 (int64, int32) fromInt) len)))
	   handle x_1228 => case x_1228 of
			      Overflow => raise Subscript
	 | false => (unsafeSubslice ('a_2301) (sl, start, len)))
val rec 'a
   slice: 'a array * int32 * int32 Primitive.Option.t -> 'a Sequence.Slice.t = 
      (fn x_1229: 'a array * int32 * int32 Primitive.Option.t =>
       case x_1229 of
	 ((seq: 'a array, start: int32, len: int32 Primitive.Option.t)) =>
	 (subslice ('a) ((full ('a) seq), start, len)))
val rec 'a_2303
   base: 'a_2303 Sequence.Slice.t -> 'a_2303 array * int32 * int32 = 
      (fn x_1230: 'a_2303 Sequence.Slice.t =>
       case x_1230 of
	 (T['a_2303] {seq = seq: 'a_2303 array,
		      start = start: int64,
		      len = len: int64}) =>
	 (seq, (toIntUnsafe start), (toIntUnsafe len)))
val rec ('a_2307, 'a_2306)
   foldli': (int64 * 'a_2307 * 'a_2306 -> 'a_2306)
	    -> 'a_2306 -> 'a_2307 Sequence.Slice.t -> 'a_2306 = 
      (fn x_1231: int64 * 'a_2307 * 'a_2306 -> 'a_2306 =>
       (fn x_1232: 'a_2306 =>
	(fn x_1233: 'a_2307 Sequence.Slice.t =>
	 case (x_1231, x_1232, x_1233) of
	   (f: int64 * 'a_2307 * 'a_2306 -> 'a_2306,
	    b: 'a_2306,
	    T['a_2307] {seq = seq: 'a_2307 array,
			start = start: int64,
			len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_2306 -> 'a_2306 = 
		     (fn x_1234: int64 * 'a_2306 =>
		      case x_1234 of
			((i: int64, b: 'a_2306)) =>
			case (> (i, max)) of
			  true => b
			| false =>
			  (loop ((+? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_1 ('a_2307) (seq, i)),
				     b)))))
	   in
	      (loop (min, b))
	   end)))
val rec ('a_2311, 'a_2310)
   foldri': (int64 * 'a_2311 * 'a_2310 -> 'a_2310)
	    -> 'a_2310 -> 'a_2311 Sequence.Slice.t -> 'a_2310 = 
      (fn x_1235: int64 * 'a_2311 * 'a_2310 -> 'a_2310 =>
       (fn x_1236: 'a_2310 =>
	(fn x_1237: 'a_2311 Sequence.Slice.t =>
	 case (x_1235, x_1236, x_1237) of
	   (f: int64 * 'a_2311 * 'a_2310 -> 'a_2310,
	    b: 'a_2310,
	    T['a_2311] {seq = seq: 'a_2311 array,
			start = start: int64,
			len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_2310 -> 'a_2310 = 
		     (fn x_1238: int64 * 'a_2310 =>
		      case x_1238 of
			((i: int64, b: 'a_2310)) =>
			case (< (i, min)) of
			  true => b
			| false =>
			  (loop ((-? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_1 ('a_2311) (seq, i)),
				     b)))))
	   in
	      (loop (max, b))
	   end)))
val rec ('a_2313, 'a_2312)
   foldri: (int32 * 'a_2313 * 'a_2312 -> 'a_2312)
	   -> 'a_2312 -> 'a_2313 Sequence.Slice.t -> 'a_2312 = 
      (fn x_1239: int32 * 'a_2313 * 'a_2312 -> 'a_2312 =>
       (fn x_1240: 'a_2312 =>
	(fn x_1241: 'a_2313 Sequence.Slice.t =>
	 case (x_1239, x_1240, x_1241) of
	   (f: int32 * 'a_2313 * 'a_2312 -> 'a_2312,
	    b: 'a_2312,
	    sl: 'a_2313 Sequence.Slice.t) =>
	   (((foldri' ('a_2313, 'a_2312) (wrap3 ('a_2313, 'a_2312, 'a_2312) f)) b) sl))))
val rec 'a_2325
   appi': (int64 * 'a_2325 -> unit) -> 'a_2325 Sequence.Slice.t -> unit = 
      (fn x_1242: int64 * 'a_2325 -> unit =>
       (fn x_1243: 'a_2325 Sequence.Slice.t =>
	case (x_1242, x_1243) of
	  (f: int64 * 'a_2325 -> unit, sl: 'a_2325 Sequence.Slice.t) =>
	  (((foldli' ('a_2325, unit) (fn x_1244: int64 * 'a_2325 * unit =>
				      case x_1244 of
					(i: int64, x: 'a_2325, ()) => (f (i, x)))) ()) sl)))
val rec ('a_2330, 'a_2329, 'a_2328)
   createi': (int64 * (int64 -> 'a_2329) -> 'a_2328)
	     -> (int64 * 'a_2330 -> 'a_2329)
		-> 'a_2330 Sequence.Slice.t -> 'a_2328 = 
      (fn x_1245: int64 * (int64 -> 'a_2329) -> 'a_2328 =>
       (fn x_1246: int64 * 'a_2330 -> 'a_2329 =>
	(fn x_1247: 'a_2330 Sequence.Slice.t =>
	 case (x_1245, x_1246, x_1247) of
	   (tabulate': int64 * (int64 -> 'a_2329) -> 'a_2328,
	    f: int64 * 'a_2330 -> 'a_2329,
	    T['a_2330] {seq = seq: 'a_2330 array,
			start = start: int64,
			len = len: int64}) =>
	   (tabulate' (len,
		       (fn x_1248: int64 =>
			case x_1248 of
			  i: int64 =>
			  (f (i, (subUnsafe_1 ('a_2330) (seq, (+? (start, i))))))))))))
val rec ('a_2333, 'a_2332, 'a_2331)
   createi: (int64 * (int64 -> 'a_2331) -> 'a_2333)
	    -> (int32 * 'a_2332 -> 'a_2331)
	       -> 'a_2332 Sequence.Slice.t -> 'a_2333 = 
      (fn x_1249: int64 * (int64 -> 'a_2331) -> 'a_2333 =>
       (fn x_1250: int32 * 'a_2332 -> 'a_2331 =>
	(fn x_1251: 'a_2332 Sequence.Slice.t =>
	 case (x_1249, x_1250, x_1251) of
	   (tabulate': int64 * (int64 -> 'a_2331) -> 'a_2333,
	    f: int32 * 'a_2332 -> 'a_2331,
	    sl: 'a_2332 Sequence.Slice.t) =>
	   (((createi' ('a_2332, 'a_2331, 'a_2333) tabulate') (wrap2 ('a_2332,
								      'a_2331) f)) sl))))
val rec ('a_2336, 'a_2335, 'a_2334)
   create: (int64 * (int64 -> 'a_2335) -> 'a_2336)
	   -> ('a_2334 -> 'a_2335) -> 'a_2334 Sequence.Slice.t -> 'a_2336 = 
      (fn x_1252: int64 * (int64 -> 'a_2335) -> 'a_2336 =>
       (fn x_1253: 'a_2334 -> 'a_2335 =>
	(fn x_1254: 'a_2334 Sequence.Slice.t =>
	 case (x_1252, x_1253, x_1254) of
	   (tabulate': int64 * (int64 -> 'a_2335) -> 'a_2336,
	    f: 'a_2334 -> 'a_2335,
	    sl: 'a_2334 Sequence.Slice.t) =>
	   (((createi ('a_2336, 'a_2334, 'a_2335) tabulate') (o_1 (int32
								   * 'a_2334,
								   'a_2335,
								   'a_2334) (f,
									     (fn x_1255: int32
											 * 'a_2334 =>
									      case x_1255 of
										{2 = #: 'a_2334} =>
										#)))) sl))))
val rec ('a_2372, 'a_2371)
   make: ('a_2372 Sequence.Slice.t -> 'a_2371) -> 'a_2372 array -> 'a_2371 = 
      (fn x_1256: 'a_2372 Sequence.Slice.t -> 'a_2371 =>
       (fn x_1257: 'a_2372 array =>
	case (x_1256, x_1257) of
	  (f: 'a_2372 Sequence.Slice.t -> 'a_2371, seq: 'a_2372 array) =>
	  (f (full ('a_2372) seq))))
val rec 'a_2376
   sub: 'a_2376 array * int32 -> 'a_2376 = 
      (fn x_1258: 'a_2376 array * int32 =>
       case x_1258 of
	 ((seq: 'a_2376 array, i: int32)) =>
	 (sub ('a_2376) ((full ('a_2376) seq), i)))
val rec ('a_2382, 'a_2381, 'a_2380)
   updateMk: ('a_2380 array * int64 * 'a_2382 -> 'a_2381)
	     -> 'a_2380 array * int32 * 'a_2382 -> 'a_2381 = 
      (fn x_1259: 'a_2380 array * int64 * 'a_2382 -> 'a_2381 =>
       (fn x_1260: 'a_2380 array * int32 * 'a_2382 =>
	case (x_1259, x_1260) of
	  (updateUnsafe: 'a_2380 array * int64 * 'a_2382 -> 'a_2381,
	   (seq: 'a_2380 array, i: int32, x: 'a_2382)) =>
	  ((updateMk ('a_2380, 'a_2382, 'a_2381) updateUnsafe) ((full ('a_2380) seq),
								i,
								x))))
val rec ('a_2412, 'a_2411)
   foldri: (int32 * 'a_2412 * 'a_2411 -> 'a_2411)
	   -> 'a_2411 -> 'a_2412 array -> 'a_2411 = 
      (fn x_1261: int32 * 'a_2412 * 'a_2411 -> 'a_2411 =>
       (fn x_1262: 'a_2411 =>
	case (x_1261, x_1262) of
	  (f: int32 * 'a_2412 * 'a_2411 -> 'a_2411, b: 'a_2411) =>
	  (make ('a_2412, 'a_2411) ((foldri ('a_2412, 'a_2411) f) b))))
val 'a updateMk_0: ('a array * int64 * 'a -> unit)
		   -> 'a array * int32 * 'a -> unit =
   updateMk ('a, unit, 'a)
val ('a, 'b) unfoldi_0: int32 * 'b * (int32 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi ('a, 'b)
val 'a tabulate_2: int32 * (int32 -> 'a) -> 'a array = tabulate ('a)
val 'a sub_4: 'a array * int32 -> 'a = sub ('a)
val 'a newUninit_0: int32 -> 'a array = newUninit ('a)
val 'a new_1: int32 * 'a -> 'a array = new ('a)
val 'a length_7: 'a array -> int32 = length ('a)
val ('b, 'a) foldri_0: (int32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b =
   foldri ('a, 'b)
val 'a unsafeUpdate'Mk_0: ('a array * int64 * 'a -> unit)
			  -> 'a Sequence.Slice.t * int64 * 'a -> unit =
   unsafeUpdate'Mk ('a, 'a, unit)
val 'a slice_2: 'a array * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice ('a)
val 'a full_3: 'a array -> 'a Sequence.Slice.t = full ('a)
val ('a, 'c, 'b) create_0: (int64 * (int64 -> 'b) -> 'c)
			   -> ('a -> 'b) -> 'a Sequence.Slice.t -> 'c =
   create ('c, 'b, 'a)
val 'a base_3: 'a Sequence.Slice.t -> 'a array * int32 * int32 = base ('a)
val 'a appi'_0: (int64 * 'a -> unit) -> 'a Sequence.Slice.t -> unit = appi' ('a)
val rec 'a_2460
   unsafeUpdate': 'a_2460 Sequence.Slice.t * int64 * 'a_2460 -> unit = 
      (fn x_1263: 'a_2460 Sequence.Slice.t * int64 * 'a_2460 =>
       case x_1263 of
	 ((arr: 'a_2460 Sequence.Slice.t, i: int64, x: 'a_2460)) =>
	 ((unsafeUpdate'Mk_0 ('a_2460) updateUnsafe ('a_2460)) (arr, i, x)))
val rec 'a_2462
   vector: 'a_2462 Sequence.Slice.t -> 'a_2462 vector = 
      (fn x_1264: 'a_2462 Sequence.Slice.t =>
       case x_1264 of
	 (sl: 'a_2462 Sequence.Slice.t) =>
	 (((create_0 ('a_2462, 'a_2462 vector, 'a_2462) tabulate'_1 ('a_2462)) (fn x_1265: 'a_2462 =>
										case x_1265 of
										  x: 'a_2462 =>
										  x)) sl))
val rec 'a_2463
   modifyi': (int64 * 'a_2463 -> 'a_2463) -> 'a_2463 Sequence.Slice.t -> unit = 
      (fn x_1266: int64 * 'a_2463 -> 'a_2463 =>
       (fn x_1267: 'a_2463 Sequence.Slice.t =>
	case (x_1266, x_1267) of
	  (f: int64 * 'a_2463 -> 'a_2463, sl: 'a_2463 Sequence.Slice.t) =>
	  ((appi'_0 ('a_2463) (fn x_1268: int64 * 'a_2463 =>
			       case x_1268 of
				 (i: int64, x: 'a_2463) =>
				 (unsafeUpdate' ('a_2463) (sl, i, (f (i, x)))))) sl)))
val rec ('a_2467, 'a_2466)
   make: ('a_2466 -> int32) * ('a_2466 * int64 -> 'a_2467)
	 -> {di: int32, dst: 'a_2467 array, src: 'a_2466} -> unit = 
      (fn x_1269: ('a_2466 -> int32) * ('a_2466 * int64 -> 'a_2467) =>
       (fn x_1270: {di: int32, dst: 'a_2467 array, src: 'a_2466} =>
	case (x_1269, x_1270) of
	  ((length: 'a_2466 -> int32, sub': 'a_2466 * int64 -> 'a_2467),
	   {src = src: 'a_2466, dst = dst: 'a_2467 array, di = di: int32}) =>
	  ((modifyi' ('a_2467) (fn x_1271: int64 * 'a_2467 =>
				case x_1271 of
				  (i: int64, _) => (sub' (src, i)))) (slice_2 ('a_2467) (dst,
						       di,
						       (SOME[int32] (length src)))))))
val rec 'a_2469
   copyVec: {di: int32, dst: 'a_2469 array, src: 'a_2469 Sequence.Slice.t}
	    -> unit = 
      (fn x_1272: {di: int32, dst: 'a_2469 array, src: 'a_2469 Sequence.Slice.t} =>
       case x_1272 of
	 (arg: {di: int32, dst: 'a_2469 array, src: 'a_2469 Sequence.Slice.t}) =>
	 ((make ('a_2469, 'a_2469 Sequence.Slice.t) (length_5 ('a_2469),
						     unsafeSub'_1 ('a_2469))) arg))
val rec 'a_2476
   copyVec: {di: int32, dst: 'a_2476 array, src: 'a_2476 vector} -> unit = 
      (fn x_1273: {di: int32, dst: 'a_2476 array, src: 'a_2476 vector} =>
       case x_1273 of
	 ({src = src: 'a_2476 vector, dst = dst: 'a_2476 array, di = di: int32}) =>
	 (copyVec ('a_2476) {src = (full_2 ('a_2476) src), dst = dst, di = di}))
val 'a_2478 arrayUninit: int32 -> 'a_2478 array = newUninit_0 ('a_2478)
val 'a_2480 array: int32 * 'a_2480 -> 'a_2480 array = new_1 ('a_2480)
val rec 'a_2481
   update: 'a_2481 array * int32 * 'a_2481 -> unit = 
      (fn x_1274: 'a_2481 array * int32 * 'a_2481 =>
       case x_1274 of
	 ((arr: 'a_2481 array, i: int32, x: 'a_2481)) =>
	 ((updateMk_0 ('a_2481) updateUnsafe ('a_2481)) (arr, i, x)))
val 'a update_0: 'a array * int32 * 'a -> unit = update ('a)
val ('a, 'b) unfoldi_1: int32 * 'b * (int32 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi_0 ('a, 'b)
val 'a tabulate_3: int32 * (int32 -> 'a) -> 'a array = tabulate_2 ('a)
val 'a sub_5: 'a array * int32 -> 'a = sub_4 ('a)
val 'a length_8: 'a array -> int32 = length_7 ('a)
val ('b, 'a) foldri_1: (int32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b =
   foldri_0 ('b, 'a)
val 'a copyVec_0: {di: int32, dst: 'a array, src: 'a vector} -> unit =
   copyVec ('a)
val 'a arrayUninit_0: int32 -> 'a array = arrayUninit ('a)
val 'a array_0: int32 * 'a -> 'a array = array ('a)
val 'a vector_2: 'a Sequence.Slice.t -> 'a vector = vector ('a)
val 'a slice_3: 'a array * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice_2 ('a)
val 'a full_4: 'a array -> 'a Sequence.Slice.t = full_3 ('a)
val 'a base_4: 'a Sequence.Slice.t -> 'a array * int32 * int32 = base_3 ('a)
val 'a vector_3: 'a Sequence.Slice.t -> 'a vector = vector_2 ('a)
val 'a slice_4: 'a array * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice_3 ('a)
val 'a base_5: 'a Sequence.Slice.t -> 'a array * int32 * int32 = base_4 ('a)
datatype Array2.traversal = RowMajor
			    | ColMajor
val 'a_2612 toPoly: 'a_2612 -> 'a_2612 =
   (fn x_1275: 'a_2612 =>
    case x_1275 of
      s: 'a_2612 => s)
val vector_4: int32 * char8 -> string = vector_0 (char8)
val unsafeFromArray_1: char8 array -> string = unsafeFromArray_0 (char8)
val translate_2: (char8 -> string) -> string -> string =
   translate_1 (char8, char8)
val tabulate_4: int32 * (int32 -> char8) -> string = tabulate_1 (char8)
val sub_6: string * int32 -> char8 = sub_2 (char8)
val length_9: string -> int32 = length_4 (char8)
val isPrefix_2: (char8 * char8 -> bool) -> string -> string -> bool =
   isPrefix_1 (char8)
val fromList_2: char8 list -> string = fromList_1 (char8)
val exists_2: (char8 -> bool) -> string -> bool = exists_1 (char8)
val concat_2: string list -> string = concat_1 (char8)
val append_2: string * string -> string = append_1 (char8)
val vector_5: char8 Sequence.Slice.t -> string = vector_1 (char8)
val toPoly_0: char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   toPoly (char8 Sequence.Slice.t)
val taker_2: (char8 -> bool) -> char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   taker_1 (char8)
val takel_2: (char8 -> bool) -> char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   takel_1 (char8)
val sub_7: char8 Sequence.Slice.t * int32 -> char8 = sub_3 (char8)
val slice_5: string * int32 * int32 Primitive.Option.t -> char8 Sequence.Slice.t =
   slice_1 (char8)
val length_10: char8 Sequence.Slice.t -> int32 = length_5 (char8)
val full_5: string -> char8 Sequence.Slice.t = full_1 (char8)
val dropr_2: (char8 -> bool) -> char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   dropr_1 (char8)
val base_6: char8 Sequence.Slice.t -> string * int32 * int32 = base_1 (char8)
val 'a_2613 fromPoly: 'a_2613 -> 'a_2613 =
   (fn x_1276: 'a_2613 =>
    case x_1276 of
      a: 'a_2613 => a)
val 'a_2615 toPoly: 'a_2615 -> 'a_2615 =
   (fn x_1277: 'a_2615 =>
    case x_1277 of
      s: 'a_2615 => s)
val update_1: char8 array * int32 * char8 -> unit = update_0 (char8)
val tabulate_5: int32 * (int32 -> char8) -> char8 array = tabulate_3 (char8)
val length_11: char8 array -> int32 = length_8 (char8)
val fromPoly_0: char8 array -> char8 array = fromPoly (char8 array)
val copyVec_1: {di: int32, dst: char8 array, src: string} -> unit =
   copyVec_0 (char8)
val array_1: int32 * char8 -> char8 array = array_0 (char8)
val vector_6: char8 Sequence.Slice.t -> string = vector_2 (char8)
val toPoly_1: char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   toPoly (char8 Sequence.Slice.t)
val slice_6: char8 array * int32 * int32 Primitive.Option.t
	     -> char8 Sequence.Slice.t =
   slice_3 (char8)
val full_6: char8 array -> char8 Sequence.Slice.t = full_4 (char8)
val base_7: char8 Sequence.Slice.t -> char8 array * int32 * int32 =
   base_4 (char8)
val size: string -> int32 = length_9
val implode: char8 list -> string = fromList_2
val fChar8: {chrUnsafe: int32 -> char8,
	     maxChar: char8,
	     minChar: char8,
	     numChars: int32,
	     ord: char8 -> int32} =
   {chrUnsafe = (o_1 (int32, char8, word8) (idFromWord8, sextdToWord8)),
    ord = (o_1 (char8, int32, word8) (zextdFromWord8, idToWord8)),
    minChar = 0x0,
    maxChar = 0xFF,
    numChars = 0x100}
val fChar16: {chrUnsafe: int32 -> char16,
	      maxChar: char16,
	      minChar: char16,
	      numChars: int32,
	      ord: char16 -> int32} =
   {chrUnsafe = (o_1 (int32, char16, word16) (idFromWord16, sextdToWord16)),
    ord = (o_1 (char16, int32, word16) (zextdFromWord16, idToWord16)),
    minChar = 0x0,
    maxChar = 0xFFFF,
    numChars = 0x10000}
val fChar32: {chrUnsafe: int32 -> char32,
	      maxChar: char32,
	      minChar: char32,
	      numChars: int32,
	      ord: char32 -> int32} =
   {chrUnsafe = (o_1 (int32, char32, word32) (idFromWord32, sextdToWord32)),
    ord = (o_1 (char32, int32, word32) (zextdFromWord32, idToWord32)),
    minChar = 0x0,
    maxChar = 0x10FFFF,
    numChars = 0x110000}
val f: {chrUnsafe: int32 -> char8,
	maxChar: char8,
	minChar: char8,
	numChars: int32,
	ord: char8 -> int32} =
   fChar8
val _ = fChar16
val _ = fChar32
val {chrUnsafe = chrUnsafe: int32 -> char8,
     ord = ord: char8 -> int32,
     minChar = minChar: char8,
     maxChar = maxChar: char8,
     numChars = numChars: int32} =
   f
val _ = fChar8
val _ = fChar16
val rec ('b, 'a)
   readerN: ('b -> ('a * 'b) Primitive.Option.t) * int32
	    -> 'b -> ('a list * 'b) Primitive.Option.t = 
      (fn x_1278: ('b -> ('a * 'b) Primitive.Option.t) * int32 =>
       case x_1278 of
	 ((reader: 'b -> ('a * 'b) Primitive.Option.t, n: int32)) =>
	 (fn x_1279: 'b =>
	  case x_1279 of
	    state: 'b =>
	    let val rec
		   loop: int32 * 'b * 'a list
			 -> ('a list * 'b) Primitive.Option.t = 
		      (fn x_1280: int32 * 'b * 'a list =>
		       case x_1280 of
			 ((n: int32, state: 'b, accum: 'a list)) =>
			 case (<= (n, 0x0)) of
			   true =>
			   (SOME['a list * 'b] ((rev_1 ('a) accum), state))
			 | false =>
			   case (reader state) of
			     NONE['a * 'b] => NONE['a list * 'b]
			   | SOME['a * 'b] (x: 'a, state: 'b) =>
			     (loop ((- (n, 0x1)), state, (::['a] (x, accum)))))
	    in
	       (loop (n, state, []))
	    end))
val rec ('a_2663, 'a_2662)
   ignore: ('a_2663 -> bool)
	   -> ('a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t)
	      -> 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t = 
      (fn x_1281: 'a_2663 -> bool =>
       (fn x_1282: 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t =>
	case (x_1281, x_1282) of
	  (f: 'a_2663 -> bool,
	   reader: 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t) =>
	  let val rec
		 loop: 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t = 
		    (fn x_1283: 'a_2662 =>
		     case x_1283 of
		       (state: 'a_2662) =>
		       case (reader state) of
			 NONE['a_2663 * 'a_2662] => NONE['a_2663 * 'a_2662]
		       | SOME['a_2663 * 'a_2662] (x: 'a_2663, state: 'a_2662) =>
			 case (f x) of
			   true => (loop state)
			 | false => (SOME['a_2663 * 'a_2662] (x, state)))
	  in
	     loop
	  end))
val ('a_2665, 'a_2664) _ = ignore ('a_2665, 'a_2664)
val rec ('b, 'c, 'a)
   map: ('a -> 'c)
	-> ('b -> ('a * 'b) Primitive.Option.t)
	   -> 'b -> ('c * 'b) Primitive.Option.t = 
      (fn x_1284: 'a -> 'c =>
       (fn x_1285: 'b -> ('a * 'b) Primitive.Option.t =>
	case (x_1284, x_1285) of
	  (f: 'a -> 'c, reader: 'b -> ('a * 'b) Primitive.Option.t) =>
	  (fn x_1286: 'b =>
	   case x_1286 of
	     b: 'b =>
	     case (reader b) of
	       NONE['a * 'b] => NONE['c * 'b]
	     | SOME['a * 'b] (a: 'a, b: 'b) => (SOME['c * 'b] ((f a), b)))))
val rec ('a_2667, 'a_2666)
   reader2: ('a_2667 -> ('a_2666 * 'a_2667) Primitive.Option.t)
	    -> 'a_2667 -> (('a_2666 * 'a_2666) * 'a_2667) Primitive.Option.t = 
      (fn x_1287: 'a_2667 -> ('a_2666 * 'a_2667) Primitive.Option.t =>
       case x_1287 of
	 (reader: 'a_2667 -> ('a_2666 * 'a_2667) Primitive.Option.t) =>
	 ((map ('a_2667, 'a_2666 * 'a_2666, 'a_2666 list) (fn x_1288: 'a_2666 list =>
							   case x_1288 of
							     [y: 'a_2666,
							      z: 'a_2666] =>
							     (y, z)
							   | _ =>
							     raise (Fail "Reader.reader2"))) (readerN ('a_2667,
												       'a_2666) (reader,
														 0x2))))
val ('a_2669, 'a_2668) _ = reader2 ('a_2669, 'a_2668)
datatype StringCvt.radix = BIN
			   | OCT
			   | DEC
			   | HEX
val radixToInt: StringCvt.radix -> int32 =
   (fn x_1289: StringCvt.radix =>
    case x_1289 of
      BIN => 0x2 | OCT => 0x8 | DEC => 0xA | HEX => 0x10)
datatype StringCvt.realfmt = SCI of int32 Primitive.Option.t
			     | FIX of int32 Primitive.Option.t
			     | GEN of int32 Primitive.Option.t
			     | EXACT
val rec 'a_2676
   splitl: (char8 -> bool)
	   -> ('a_2676 -> (char8 * 'a_2676) Primitive.Option.t)
	      -> 'a_2676 -> string * 'a_2676 = 
      (fn x_1290: char8 -> bool =>
       (fn x_1291: 'a_2676 -> (char8 * 'a_2676) Primitive.Option.t =>
	(fn x_1292: 'a_2676 =>
	 case (x_1290, x_1291, x_1292) of
	   (p: char8 -> bool,
	    f: 'a_2676 -> (char8 * 'a_2676) Primitive.Option.t,
	    src: 'a_2676) =>
	   let val rec
		  done: char8 list -> string = 
		     (fn x_1294: char8 list =>
		      case x_1294 of
			(chars: char8 list) => (implode (rev_1 (char8) chars)))
	       val rec
		  loop: 'a_2676 * char8 list -> string * 'a_2676 = 
		     (fn x_1293: 'a_2676 * char8 list =>
		      case x_1293 of
			((src: 'a_2676, chars: char8 list)) =>
			case (f src) of
			  NONE[char8 * 'a_2676] => ((done chars), src)
			| SOME[char8 * 'a_2676] (c: char8, src': 'a_2676) =>
			  case (p c) of
			    true => (loop (src', (::[char8] (c, chars))))
			  | false => ((done chars), src))
	   in
	      (loop (src, []))
	   end)))
val rec 'a_2678
   dropl: (char8 -> bool)
	  -> ('a_2678 -> (char8 * 'a_2678) Primitive.Option.t)
	     -> 'a_2678 -> 'a_2678 = 
      (fn x_1295: char8 -> bool =>
       (fn x_1296: 'a_2678 -> (char8 * 'a_2678) Primitive.Option.t =>
	(fn x_1297: 'a_2678 =>
	 case (x_1295, x_1296, x_1297) of
	   (p: char8 -> bool,
	    f: 'a_2678 -> (char8 * 'a_2678) Primitive.Option.t,
	    s: 'a_2678) =>
	   ((fn x_1298: string * 'a_2678 =>
	     case x_1298 of
	       {2 = #: 'a_2678} => #) (((splitl ('a_2678) p) f) s)))))
val rec
   stringReader: string -> int32 -> (char8 * int32) Primitive.Option.t = 
      (fn x_1299: string =>
       case x_1299 of
	 (s: string) =>
	 (fn x_1300: int32 =>
	  case x_1300 of
	    i: int32 =>
	    case (>= (i, (size s))) of
	      true => NONE[char8 * int32]
	    | false => (SOME[char8 * int32] ((sub_6 (s, i)), (+ (i, 0x1))))))
val rec 'a
   scanString: ((int32 -> (char8 * int32) Primitive.Option.t)
		-> int32 -> ('a * int32) Primitive.Option.t)
	       -> string -> 'a Primitive.Option.t = 
      (fn x_1301: (int32 -> (char8 * int32) Primitive.Option.t)
		  -> int32 -> ('a * int32) Primitive.Option.t =>
       (fn x_1302: string =>
	case (x_1301, x_1302) of
	  (f: (int32 -> (char8 * int32) Primitive.Option.t)
	      -> int32 -> ('a * int32) Primitive.Option.t,
	   s: string) =>
	  case ((f (stringReader s)) 0x0) of
	    NONE['a * int32] => NONE['a]
	  | SOME['a * int32] (a: 'a, _) => (SOME['a] a)))
val rec 'a
   memoize: (char8 -> 'a) -> char8 -> 'a = 
      (fn x_1303: char8 -> 'a =>
       case x_1303 of
	 (f: char8 -> 'a) =>
	 let val a: 'a array =
		(tabulate_3 ('a) (numChars,
				  (o_1 (int32, 'a, char8) (f, chrUnsafe))))
	 in
	    (fn x_1304: char8 =>
	     case x_1304 of
	       c: char8 => (sub_5 ('a) (a, (ord c))))
	 end)
val rec
   range: int32 * char8 * char8 -> char8 -> int32 Primitive.Option.t = 
      (fn x_1305: int32 * char8 * char8 =>
       case x_1305 of
	 ((add: int32, cmin: char8, cmax: char8)) =>
	 let val min: int32 = (ord cmin)
	 in
	    (fn x_1306: char8 =>
	     case x_1306 of
	       c: char8 =>
	       case case (<= (cmin, c)) of
		      true => (<= (c, cmax)) | false => false of
		 true => (SOME[int32] (-? ((+? (add, (ord c))), min)))
	       | false => NONE[int32])
	 end)
val rec 'a
   combine: (char8 -> 'a Primitive.Option.t) list
	    -> char8 -> 'a Primitive.Option.t = 
      (fn x_1307: (char8 -> 'a Primitive.Option.t) list =>
       case x_1307 of
	 (ds: (char8 -> 'a Primitive.Option.t) list) =>
	 (memoize ('a Primitive.Option.t) (fn x_1308: char8 =>
					   case x_1308 of
					     c: char8 =>
					     let val rec 'a_2679
						    loop: (char8
							   -> 'a_2679 Primitive.Option.t) list
							  -> 'a_2679 Primitive.Option.t = 
						       (fn x_1309: (char8
								    -> 'a_2679 Primitive.Option.t) list =>
							case x_1309 of
							  [] => NONE['a_2679]
							| ::[char8
							     -> 'a_2679 Primitive.Option.t] (d: char8
												-> 'a_2679 Primitive.Option.t,
											     ds: (char8
												  -> 'a_2679 Primitive.Option.t) list) =>
							  case (d c) of
							    NONE['a_2679] =>
							    (loop ('a_2679) ds)
							  | z: 'a_2679 Primitive.Option.t =>
							    z)
					     in
						(loop ('a) ds)
					     end)))
val bin: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x31)))
val oct: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x37)))
val dec: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x39)))
val hex: char8 -> int32 Primitive.Option.t =
   (combine (int32) [(range (0x0, 0x30, 0x39)),
		     (range (0xA, 0x61, 0x66)),
		     (range (0xA, 0x41, 0x46))])
val rec
   isSpace: char8 -> bool = 
      (fn x_1310: char8 =>
       case x_1310 of
	 (c: char8) =>
	 case case case case case (= (char8) (c, 0x20)) of
			       true => true | false => (= (char8) (c, 0x9)) of
			  true => true | false => (= (char8) (c, 0xD)) of
		     true => true | false => (= (char8) (c, 0xA)) of
		true => true | false => (= (char8) (c, 0xB)) of
	   true => true | false => (= (char8) (c, 0xC)))
val isSpace: char8 -> bool = (memoize (bool) isSpace)
val rec 'a_2680
   skipWS: ('a_2680 -> (char8 * 'a_2680) Primitive.Option.t)
	   -> 'a_2680 -> 'a_2680 = 
      (fn x_1311: 'a_2680 -> (char8 * 'a_2680) Primitive.Option.t =>
       case x_1311 of
	 (x: 'a_2680 -> (char8 * 'a_2680) Primitive.Option.t) =>
	 ((dropl ('a_2680) isSpace) x))
val rec
   charToDigit: StringCvt.radix -> char8 -> int32 Primitive.Option.t = 
      (fn x_1312: StringCvt.radix =>
       case x_1312 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => bin | OCT => oct | DEC => dec | HEX => hex)
val rec
   digitToChar: int32 -> char8 = 
      (fn x_1313: int32 =>
       case x_1313 of
	 (n: int32) => (sub_6 ("0123456789ABCDEF", n)))
val 'a skipWS_0: ('a -> (char8 * 'a) Primitive.Option.t) -> 'a -> 'a =
   skipWS ('a)
val 'a scanString_0: ((int32 -> (char8 * int32) Primitive.Option.t)
		      -> int32 -> ('a * int32) Primitive.Option.t)
		     -> string -> 'a Primitive.Option.t =
   scanString ('a)
val not: bool -> bool = not
val precision': int32 = (zextdToInt sizeInBits)
val precision': int32 = (zextdToInt sizeInBits)
val precision': int32 = (zextdToInt sizeInBits)
val fromInt: int32 -> int32 = schckFromInt
val toInt: int32 -> int32 = schckToInt
val maxNumDigits: int32 = (+ (precision', 0x1))
val oneBuf: char8 array One.t =
   (make_0 (char8 array) (fn x_1314: unit =>
			  case x_1314 of
			    () => (array_1 (maxNumDigits, 0x0))))
val rec
   fmt: StringCvt.radix -> int32 -> string = 
      (fn x_1315: StringCvt.radix =>
       (fn x_1316: int32 =>
	case (x_1315, x_1316) of
	  (radix: StringCvt.radix, n: int32) =>
	  (use_0 (string, char8 array) (oneBuf,
					(fn x_1317: char8 array =>
					 case x_1317 of
					   buf: char8 array =>
					   let val radix: int32 =
						  (fromInt (radixToInt radix))
					       val rec
						  loop: int32 * int32 -> string = 
						     (fn x_1318: int32 * int32 =>
						      case x_1318 of
							((q: int32, i: int32)) =>
							let val _ =
							       (update_1 (buf,
									  i,
									  (digitToChar (toInt (~? (rem (q,
													radix)))))))
							    val q: int32 =
							       (quot (q, radix))
							in
							   case (= (int32) (q,
									    zero)) of
							     true =>
							     let val start: int32 =
								    case (< (n,
									     zero)) of
								      true =>
								      let val i: int32 =
									     (- (i,
										 0x1))
									  val () =
									     (update_1 (buf,
											i,
											0x7E))
								      in
									 i
								      end
								    | false => i
							     in
								(vector_6 (slice_6 (buf,
										    start,
										    NONE[int32])))
							     end
							   | false =>
							     (loop (q,
								    (- (i, 0x1))))
							end)
					   in
					      (loop (case (< (n, zero)) of
						       true => n
						     | false => (~? n),
						     (- (maxNumDigits, 0x1))))
					   end)))))
val toString: int32 -> string = (fmt DEC)
val rec 'a_2692
   scan: StringCvt.radix
	 -> ('a_2692 -> (char8 * 'a_2692) Primitive.Option.t)
	    -> 'a_2692 -> (int32 * 'a_2692) Primitive.Option.t = 
      (fn x_1319: StringCvt.radix =>
       (fn x_1320: 'a_2692 -> (char8 * 'a_2692) Primitive.Option.t =>
	(fn x_1321: 'a_2692 =>
	 case (x_1319, x_1320, x_1321) of
	   (radix: StringCvt.radix,
	    reader: 'a_2692 -> (char8 * 'a_2692) Primitive.Option.t,
	    s: 'a_2692) =>
	   let val s: 'a_2692 = ((skipWS_0 ('a_2692) reader) s)
	       val rec
		  charToDigit: char8 -> int32 Primitive.Option.t = 
		     (fn x_1325: char8 =>
		      case x_1325 of
			(c: char8) =>
			case ((charToDigit radix) c) of
			  NONE[int32] => NONE[int32]
			| SOME[int32] n: int32 => (SOME[int32] (fromInt n)))
	       val radixInt: int32 = (fromInt (radixToInt radix))
	       val rec
		  finishNum: 'a_2692 * int32
			     -> (int32 * 'a_2692) Primitive.Option.t = 
		     (fn x_1324: 'a_2692 * int32 =>
		      case x_1324 of
			((s: 'a_2692, n: int32)) =>
			case (reader s) of
			  NONE[char8 * 'a_2692] =>
			  (SOME[int32 * 'a_2692] (n, s))
			| SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
			  case (charToDigit c) of
			    NONE[int32] => (SOME[int32 * 'a_2692] (n, s))
			  | SOME[int32] n': int32 =>
			    (finishNum (s', (- ((* (n, radixInt)), n')))))
	       val rec
		  num: 'a_2692 -> (int32 * 'a_2692) Primitive.Option.t = 
		     (fn x_1323: 'a_2692 =>
		      case x_1323 of
			(s: 'a_2692) =>
			case ((reader s), radix) of
			  (NONE[char8 * 'a_2692], _) => NONE[int32 * 'a_2692]
			| (SOME[char8 * 'a_2692] (0x30, s: 'a_2692), HEX) =>
			  case (reader s) of
			    NONE[char8 * 'a_2692] =>
			    (SOME[int32 * 'a_2692] (zero, s))
			  | SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
			    case case (= (char8) (c, 0x78)) of
				   true => true | false => (= (char8) (c, 0x58)) of
			      true =>
			      case (reader s') of
				NONE[char8 * 'a_2692] =>
				(SOME[int32 * 'a_2692] (zero, s))
			      | SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
				case (charToDigit c) of
				  NONE[int32] =>
				  (SOME[int32 * 'a_2692] (zero, s))
				| SOME[int32] n: int32 =>
				  (finishNum (s', (~? n)))
			    | false =>
			      case (charToDigit c) of
				NONE[int32] => (SOME[int32 * 'a_2692] (zero, s))
			      | SOME[int32] n: int32 => (finishNum (s', (~? n)))
			| (SOME[char8 * 'a_2692] (c: char8, s: 'a_2692), _) =>
			  case (charToDigit c) of
			    NONE[int32] => NONE[int32 * 'a_2692]
			  | SOME[int32] n: int32 => (finishNum (s, (~? n))))
	       val rec
		  negate: 'a_2692 -> (int32 * 'a_2692) Primitive.Option.t = 
		     (fn x_1322: 'a_2692 =>
		      case x_1322 of
			(s: 'a_2692) =>
			case (num s) of
			  NONE[int32 * 'a_2692] => NONE[int32 * 'a_2692]
			| SOME[int32 * 'a_2692] (n: int32, s: 'a_2692) =>
			  (SOME[int32 * 'a_2692] ((~ n), s)))
	   in
	      case (reader s) of
		NONE[char8 * 'a_2692] => NONE[int32 * 'a_2692]
	      | SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
		case c of
		  0x7E => (num s')
		| 0x2D => (num s') | 0x2B => (negate s') | _ => (negate s)
	   end)))
val fromString: string -> int32 Primitive.Option.t =
   (scanString_0 (int32) (scan (int32) DEC))
val precision': int32 = (zextdToInt sizeInBits)
val fromInt: int32 -> int64 = schckFromInt
val toInt: int64 -> int32 = schckToInt
val toLargeInt: int64 -> intInf = schckToLargeInt
val maxNumDigits: int32 = (+ (precision', 0x1))
val oneBuf: char8 array One.t =
   (make_0 (char8 array) (fn x_1326: unit =>
			  case x_1326 of
			    () => (array_1 (maxNumDigits, 0x0))))
val rec
   fmt: StringCvt.radix -> int64 -> string = 
      (fn x_1327: StringCvt.radix =>
       (fn x_1328: int64 =>
	case (x_1327, x_1328) of
	  (radix: StringCvt.radix, n: int64) =>
	  (use_0 (string, char8 array) (oneBuf,
					(fn x_1329: char8 array =>
					 case x_1329 of
					   buf: char8 array =>
					   let val radix: int64 =
						  (fromInt (radixToInt radix))
					       val rec
						  loop: int64 * int32 -> string = 
						     (fn x_1330: int64 * int32 =>
						      case x_1330 of
							((q: int64, i: int32)) =>
							let val _ =
							       (update_1 (buf,
									  i,
									  (digitToChar (toInt (~? (rem (q,
													radix)))))))
							    val q: int64 =
							       (quot (q, radix))
							in
							   case (= (int64) (q,
									    zero)) of
							     true =>
							     let val start: int32 =
								    case (< (n,
									     zero)) of
								      true =>
								      let val i: int32 =
									     (- (i,
										 0x1))
									  val () =
									     (update_1 (buf,
											i,
											0x7E))
								      in
									 i
								      end
								    | false => i
							     in
								(vector_6 (slice_6 (buf,
										    start,
										    NONE[int32])))
							     end
							   | false =>
							     (loop (q,
								    (- (i, 0x1))))
							end)
					   in
					      (loop (case (< (n, zero)) of
						       true => n
						     | false => (~? n),
						     (- (maxNumDigits, 0x1))))
					   end)))))
val wordSize: int32 = (zextdToInt sizeInBits)
val wordSize: int32 = (zextdToInt sizeInBits)
val rec
   toInt: word16 -> int32 = 
      (fn x_1331: word16 =>
       case x_1331 of
	 (w: word16) =>
	 let val i: int32 = (zchckToInt w)
	 in
	    case case case detectOverflow of
			true =>
			case precision of
			  NONE[int32] => false
			| SOME[int32] precision: int32 =>
			  (<= (precision, sizeInBits))
		      | false => false of
		   true => (< (i, 0x0)) | false => false of
	      true => raise Overflow | false => i
	 end)
val wordSize: int32 = (zextdToInt sizeInBits)
val rec
   st: word32 * word32 * word32 -> word32 * word32 * word32 = 
      (fn x_1332: word32 * word32 * word32 =>
       case x_1332 of
	 ((w: word32, msk: word32, sft: word32)) =>
	 let val odd: word32 = (andb (w, msk))
	     val evn: word32 = (xorb (w, odd))
	 in
	    ((xorb ((<<? (odd, sft)), (>>? (evn, sft)))),
	     (xorb (msk, (<<? (msk, (>>? (sft, 0x1)))))),
	     (>>? (sft, 0x1)))
	 end)
val (f: word32 * word32 * word32 -> word32 * word32 * word32, sft: word32) =
   case sizeInBitsWord of
     0x8 =>
     ((fn x_1333: word32 * word32 * word32 =>
       case x_1333 of
	 x: word32 * word32 * word32 => x),
      0x4)
   | 0x10 => (st, 0x8)
   | 0x20 =>
     ((o_1 (word32 * word32 * word32,
	    word32 * word32 * word32,
	    word32 * word32 * word32) (st, st)),
      0x10)
   | 0x40 =>
     ((o_1 (word32 * word32 * word32,
	    word32 * word32 * word32,
	    word32 * word32 * word32) ((o_1 (word32 * word32 * word32,
				 word32 * word32 * word32,
				 word32 * word32 * word32) (st, st)),
			   st)),
      0x20)
   | _ => raise (Fail "Word.bswap")
val rec
   bswap: word32 -> word32 = 
      (fn x_1334: word32 =>
       case x_1334 of
	 (w: word32) =>
	 ((fn x_1335: word32 * word32 * word32 =>
	   case x_1335 of
	     {1 = #: word32} => #) (f (w, (- ((<<? (one, sft)), one)), sft))))
val rec
   toInt: word32 -> int32 = 
      (fn x_1336: word32 =>
       case x_1336 of
	 (w: word32) =>
	 let val i: int32 = (zchckToInt w)
	 in
	    case case case detectOverflow of
			true =>
			case precision of
			  NONE[int32] => false
			| SOME[int32] precision: int32 =>
			  (<= (precision, sizeInBits))
		      | false => false of
		   true => (< (i, 0x0)) | false => false of
	      true => raise Overflow | false => i
	 end)
val wordSize: int32 = (zextdToInt sizeInBits)
val fromInt: int32 -> word64 = sextdFromInt
val binCvt: intInf -> string = (mkCvt {base = 0x2, smallCvt = (fmt BIN)})
val octCvt: intInf -> string = (mkCvt {base = 0x8, smallCvt = (fmt OCT)})
val decCvt: intInf -> string = (mkCvt {base = 0xA, smallCvt = (fmt DEC)})
val hexCvt: intInf -> string = (mkCvt {base = 0x10, smallCvt = (fmt HEX)})
val rec
   fmt: StringCvt.radix -> intInf -> string = 
      (fn x_1337: StringCvt.radix =>
       case x_1337 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => binCvt | OCT => octCvt | DEC => decCvt | HEX => hexCvt)
val toString: intInf -> string = (fmt DEC)
val rec
   binDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1338: char8 =>
       case x_1338 of
	 (ch: char8) =>
	 case ch of
	   0x30 => (SOME[word64] 0x0)
	 | 0x31 => (SOME[word64] 0x1) | _ => NONE[word64])
val <=: char8 * char8 -> bool = <=
val rec
   octDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1339: char8 =>
       case x_1339 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x37)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false => NONE[word64])
val rec
   decDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1340: char8 =>
       case x_1340 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x39)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false => NONE[word64])
val rec
   hexDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1341: char8 =>
       case x_1341 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x39)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false =>
	   case case (<= (0x61, ch)) of
		  true => (<= (ch, 0x66)) | false => false of
	     true =>
	     (SOME[word64] (fromInt (- ((ord ch), (- ((ord 0x61), 0xA))))))
	   | false =>
	     case case (<= (0x41, ch)) of
		    true => (<= (ch, 0x46)) | false => false of
	       true =>
	       (SOME[word64] (fromInt (- ((ord ch), (- ((ord 0x41), 0xA))))))
	     | false => NONE[word64])
val rec 'a
   toDigR: (char8 -> word64 Primitive.Option.t)
	   * ('a -> (char8 * 'a) Primitive.Option.t)
	   -> 'a -> (word64 * 'a) Primitive.Option.t = 
      (fn x_1342: (char8 -> word64 Primitive.Option.t)
		  * ('a -> (char8 * 'a) Primitive.Option.t) =>
       (fn x_1343: 'a =>
	case (x_1342, x_1343) of
	  ((charToDig: char8 -> word64 Primitive.Option.t,
	    cread: 'a -> (char8 * 'a) Primitive.Option.t),
	   s: 'a) =>
	  case (cread s) of
	    NONE[char8 * 'a] => NONE[word64 * 'a]
	  | SOME[char8 * 'a] (ch: char8, s': 'a) =>
	    case (charToDig ch) of
	      NONE[word64] => NONE[word64 * 'a]
	    | SOME[word64] dig: word64 => (SOME[word64 * 'a] (dig, s'))))
val rec 'a
   toChunkR: word64 * ('a -> (word64 * 'a) Primitive.Option.t)
	     -> 'a
		-> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t = 
      (fn x_1344: word64 * ('a -> (word64 * 'a) Primitive.Option.t) =>
       case x_1344 of
	 ((base: word64, dread: 'a -> (word64 * 'a) Primitive.Option.t)) =>
	 let val rec
		loop: {chunk: word64, left: int32, s: 'a, shift: word64}
		      -> {chunk: word64, more: bool, shift: word64} * 'a = 
		   (fn x_1346: {chunk: word64, left: int32, s: 'a, shift: word64} =>
		    case x_1346 of
		      ({left = left: int32,
			shift = shift: word64,
			chunk = chunk: word64,
			s = s: 'a}) =>
		      case (<= (left, 0x0)) of
			true => ({more = true, shift = shift, chunk = chunk}, s)
		      | false =>
			case (dread s) of
			  NONE[word64 * 'a] =>
			  ({more = false, shift = shift, chunk = chunk}, s)
			| SOME[word64 * 'a] (dig: word64, s': 'a) =>
			  (loop {left = (- (left, 0x1)),
				 shift = (* (base, shift)),
				 chunk = (+ ((* (base, chunk)), dig)),
				 s = s'}))
	     val digitsPerChunk: int32 =
		case (wordSize, base) of
		  (0x40, 0x10) => 0xF
		| (0x40, 0xA) => 0x12
		| (0x40, 0x8) => 0x14
		| (0x40, 0x2) => 0x3D
		| (0x20, 0x10) => 0x7
		| (0x20, 0xA) => 0x8
		| (0x20, 0x8) => 0x9
		| (0x20, 0x2) => 0x1D
		| _ => raise (Fail "IntInf.scan:digitsPerChunk")
	     val rec
		reader: 'a
			-> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t = 
		   (fn x_1345: 'a =>
		    case x_1345 of
		      (s: 'a) =>
		      case (dread s) of
			NONE[word64 * 'a] =>
			NONE[{chunk: word64, more: bool, shift: word64} * 'a]
		      | SOME[word64 * 'a] (dig: word64, next: 'a) =>
			(SOME[{chunk: word64, more: bool, shift: word64} * 'a] (loop {left = (- (digitsPerChunk,
												 0x1)),
										      shift = base,
										      chunk = dig,
										      s = next})))
	 in
	    reader
	 end)
val rec 'a
   toUnsR: ('a
	    -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1347: 'a
		  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t =>
       case x_1347 of
	 (ckread: 'a
		  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t) =>
	 let val rec
		loop: bool * intInf * 'a -> intInf * 'a = 
		   (fn x_1349: bool * intInf * 'a =>
		    case x_1349 of
		      ((more: bool, acc: intInf, s: 'a)) =>
		      case more of
			true =>
			case (ckread s) of
			  NONE[{chunk: word64, more: bool, shift: word64} * 'a] =>
			  (acc, s)
			| SOME[{chunk: word64, more: bool, shift: word64} * 'a] ({more = more: bool,
										  shift = shift: word64,
										  chunk = chunk: word64},
										 s': 'a) =>
			  (loop (more,
				 (+ ((* ((addTagCoerce shift), acc)),
				     (addTagCoerce chunk))),
				 s'))
		      | false => (acc, s))
	     val rec
		reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		   (fn x_1348: 'a =>
		    case x_1348 of
		      (s: 'a) =>
		      case (ckread s) of
			NONE[{chunk: word64, more: bool, shift: word64} * 'a] =>
			NONE[intInf * 'a]
		      | SOME[{chunk: word64, more: bool, shift: word64} * 'a] ({more = more: bool,
										chunk = chunk: word64},
									       s': 'a) =>
			(SOME[intInf * 'a] (loop (more, (addTagCoerce chunk), s'))))
	 in
	    reader
	 end)
val rec 'a
   toHexR: ('a -> (char8 * 'a) Primitive.Option.t)
	   * ('a -> (intInf * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1350: ('a -> (char8 * 'a) Primitive.Option.t)
		  * ('a -> (intInf * 'a) Primitive.Option.t) =>
       (fn x_1351: 'a =>
	case (x_1350, x_1351) of
	  ((cread: 'a -> (char8 * 'a) Primitive.Option.t,
	    uread: 'a -> (intInf * 'a) Primitive.Option.t),
	   s: 'a) =>
	  case (cread s) of
	    NONE[char8 * 'a] => NONE[intInf * 'a]
	  | SOME[char8 * 'a] (c1: char8, s1: 'a) =>
	    case (= (char8) (c1, 0x30)) of
	      true =>
	      case (cread s1) of
		NONE[char8 * 'a] => (SOME[intInf * 'a] (zero, s1))
	      | SOME[char8 * 'a] (c2: char8, s2: 'a) =>
		case case (= (char8) (c2, 0x78)) of
		       true => true | false => (= (char8) (c2, 0x58)) of
		  true =>
		  case (uread s2) of
		    NONE[intInf * 'a] => (SOME[intInf * 'a] (zero, s1))
		  | SOME[intInf * 'a] x: intInf * 'a => (SOME[intInf * 'a] x)
		| false => (uread s)
	    | false => (uread s)))
val rec 'a
   toSign: ('a -> (char8 * 'a) Primitive.Option.t)
	   * ('a -> (intInf * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1352: ('a -> (char8 * 'a) Primitive.Option.t)
		  * ('a -> (intInf * 'a) Primitive.Option.t) =>
       case x_1352 of
	 ((cread: 'a -> (char8 * 'a) Primitive.Option.t,
	   uread: 'a -> (intInf * 'a) Primitive.Option.t)) =>
	 let val rec
		reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		   (fn x_1353: 'a =>
		    case x_1353 of
		      (s: 'a) =>
		      let val s: 'a = ((skipWS_0 ('a) cread) s)
		      in
			 case (cread s) of
			   NONE[char8 * 'a] => NONE[intInf * 'a]
			 | SOME[char8 * 'a] (ch: char8, s': 'a) =>
			   let val (isNeg: bool, s'': 'a) =
				  case ch of
				    0x2B => (false, s')
				  | 0x2D => (true, s')
				  | 0x7E => (true, s')
				  | _ => (false, s)
			   in
			      case isNeg of
				true =>
				case (uread s'') of
				  NONE[intInf * 'a] => NONE[intInf * 'a]
				| SOME[intInf * 'a] (abs: intInf, s''': 'a) =>
				  (SOME[intInf * 'a] ((~ abs), s'''))
			      | false => (uread s'')
			   end
		      end)
	 in
	    reader
	 end)
val rec 'a
   reader: word64 * (char8 -> word64 Primitive.Option.t)
	   -> ('a -> (char8 * 'a) Primitive.Option.t)
	      -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1354: word64 * (char8 -> word64 Primitive.Option.t) =>
       (fn x_1355: 'a -> (char8 * 'a) Primitive.Option.t =>
	case (x_1354, x_1355) of
	  ((base: word64, dig: char8 -> word64 Primitive.Option.t),
	   cread: 'a -> (char8 * 'a) Primitive.Option.t) =>
	  let val dread: 'a -> (word64 * 'a) Primitive.Option.t =
		 (toDigR ('a) (dig, cread))
	      val ckread: 'a
			  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t =
		 (toChunkR ('a) (base, dread))
	      val uread: 'a -> (intInf * 'a) Primitive.Option.t =
		 (toUnsR ('a) ckread)
	      val hread: 'a -> (intInf * 'a) Primitive.Option.t =
		 case (= (word64) (base, 0x10)) of
		   true => (toHexR ('a) (cread, uread)) | false => uread
	      val reader: 'a -> (intInf * 'a) Primitive.Option.t =
		 (toSign ('a) (cread, hread))
	  in
	     reader
	  end))
val rec 'a_2865
   binReader: ('a_2865 -> (char8 * 'a_2865) Primitive.Option.t)
	      -> 'a_2865 -> (intInf * 'a_2865) Primitive.Option.t = 
      (fn x_1356: 'a_2865 -> (char8 * 'a_2865) Primitive.Option.t =>
       case x_1356 of
	 (z: 'a_2865 -> (char8 * 'a_2865) Primitive.Option.t) =>
	 ((reader ('a_2865) (0x2, binDig)) z))
val rec 'a_2866
   octReader: ('a_2866 -> (char8 * 'a_2866) Primitive.Option.t)
	      -> 'a_2866 -> (intInf * 'a_2866) Primitive.Option.t = 
      (fn x_1357: 'a_2866 -> (char8 * 'a_2866) Primitive.Option.t =>
       case x_1357 of
	 (z: 'a_2866 -> (char8 * 'a_2866) Primitive.Option.t) =>
	 ((reader ('a_2866) (0x8, octDig)) z))
val rec 'a_2867
   decReader: ('a_2867 -> (char8 * 'a_2867) Primitive.Option.t)
	      -> 'a_2867 -> (intInf * 'a_2867) Primitive.Option.t = 
      (fn x_1358: 'a_2867 -> (char8 * 'a_2867) Primitive.Option.t =>
       case x_1358 of
	 (z: 'a_2867 -> (char8 * 'a_2867) Primitive.Option.t) =>
	 ((reader ('a_2867) (0xA, decDig)) z))
val rec 'a_2868
   hexReader: ('a_2868 -> (char8 * 'a_2868) Primitive.Option.t)
	      -> 'a_2868 -> (intInf * 'a_2868) Primitive.Option.t = 
      (fn x_1359: 'a_2868 -> (char8 * 'a_2868) Primitive.Option.t =>
       case x_1359 of
	 (z: 'a_2868 -> (char8 * 'a_2868) Primitive.Option.t) =>
	 ((reader ('a_2868) (0x10, hexDig)) z))
val rec 'a_2869
   scan: StringCvt.radix
	 -> ('a_2869 -> (char8 * 'a_2869) Primitive.Option.t)
	    -> 'a_2869 -> (intInf * 'a_2869) Primitive.Option.t = 
      (fn x_1360: StringCvt.radix =>
       case x_1360 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => binReader ('a_2869)
	 | OCT => octReader ('a_2869)
	 | DEC => decReader ('a_2869)
	 | HEX => hexReader ('a_2869))
val fromString: string -> intInf Primitive.Option.t =
   (scanString_0 (intInf) (scan (int32) DEC))
val +: int32 * int32 -> int32 = +
val -: int32 * int32 -> int32 = -
val <: int32 * int32 -> bool = <
val <=: int32 * int32 -> bool = <=
val >: int32 * int32 -> bool = >
val >=: int32 * int32 -> bool = >=
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val fWord8: word8 array * int64 -> word8 = subArr
val fWord16: word8 array * int64 -> word16 = subArr
val fWord64: word8 array * int64 -> word64 = subArr
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 vector * int64 -> word8 = subVec
val fWord16: word8 vector * int64 -> word16 = subVec
val fWord64: word8 vector * int64 -> word64 = subVec
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 array * int64 * word8 -> unit = update
val fWord16: word8 array * int64 * word16 -> unit = update
val fWord64: word8 array * int64 * word64 -> unit = update
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 array * int64 -> word8 = subArr
val fWord16: word8 array * int64 -> word16 = subArr
val fWord32: word8 array * int64 -> word32 = subArr
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 vector * int64 -> word8 = subVec
val fWord16: word8 vector * int64 -> word16 = subVec
val fWord32: word8 vector * int64 -> word32 = subVec
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 array * int64 * word8 -> unit = update
val fWord16: word8 array * int64 * word16 -> unit = update
val fWord32: word8 array * int64 * word32 -> unit = update
val _ = fWord8
val _ = fWord16
val _ = fWord32
val maxOrd: int32 = (- (numChars, 0x1))
val rec
   chrOpt: int32 -> char8 Primitive.Option.t = 
      (fn x_1361: int32 =>
       case x_1361 of
	 (c: int32) =>
	 case case safe of
		true => (gtu (c, maxOrd)) | false => false of
	   true => NONE[char8] | false => (SOME[char8] (chrUnsafe c)))
val rec
   chr: int32 -> char8 = 
      (fn x_1362: int32 =>
       case x_1362 of
	 (c: int32) =>
	 case (chrOpt c) of
	   NONE[char8] => raise Chr | SOME[char8] c: char8 => c)
val new: int32 * char8 -> string = vector_4
val rec
   str: char8 -> string = 
      (fn x_1363: char8 =>
       case x_1363 of
	 (c: char8) => (new (0x1, c)))
val size: string -> int32 = length_9
val ^: string * string -> string = append_2
val implode: char8 list -> string = fromList_2
val rec
   extract: string * int32 * int32 Primitive.Option.t -> string = 
      (fn x_1364: string * int32 * int32 Primitive.Option.t =>
       case x_1364 of
	 ((s: string, start: int32, len: int32 Primitive.Option.t)) =>
	 (vector_5 (slice_5 (s, start, len))))
val rec
   substring: string * int32 * int32 -> string = 
      (fn x_1365: string * int32 * int32 =>
       case x_1365 of
	 ((s: string, start: int32, len: int32)) =>
	 (extract (s, start, (SOME[int32] len))))
val rec 'a_3275
   make: ((char8 * char8 -> bool) -> 'a_3275) -> 'a_3275 = 
      (fn x_1366: (char8 * char8 -> bool) -> 'a_3275 =>
       case x_1366 of
	 (f: (char8 * char8 -> bool) -> 'a_3275) => (f = (char8)))
val isPrefix: string -> string -> bool =
   (make (string -> string -> bool) isPrefix_2)
val null: string = (str (chr 0x0))
val rec
   nullTerm: string -> string = 
      (fn x_1367: string =>
       case x_1367 of
	 (s: string) => (^ (s, null)))
val string: char8 Sequence.Slice.t -> string = vector_5
val _ =
   (addExnMessager (fn x_1368: exn =>
		    case x_1368 of
		      e: exn =>
		      case e of
			Fail s: string =>
			(SOME[string] (concat_2 ["Fail: ", s]))
		      | _ => NONE[string]))
val nullTerm: string -> string =
   (o_1 (string, string, string) (fromString, nullTerm))
val rec ('a_3288, 'a_3287)
   makeLength: ('a_3287 * int32 -> 'a_3288) * ('a_3288 -> bool)
	       -> 'a_3287 -> int32 = 
      (fn x_1369: ('a_3287 * int32 -> 'a_3288) * ('a_3288 -> bool) =>
       (fn x_1370: 'a_3287 =>
	case (x_1369, x_1370) of
	  ((sub: 'a_3287 * int32 -> 'a_3288, term: 'a_3288 -> bool), p: 'a_3287) =>
	  let val rec
		 loop: int32 -> int32 = 
		    (fn x_1371: int32 =>
		     case x_1371 of
		       (i: int32) =>
		       case (term (sub (p, i))) of
			 true => i | false => (loop (+? (i, 0x1))))
	  in
	     (loop 0x0)
	  end))
val rec ('b, 'a)
   toArrayOfLength: 'a * ('a * int32 -> 'b) * int32 -> 'b array = 
      (fn x_1372: 'a * ('a * int32 -> 'b) * int32 =>
       case x_1372 of
	 ((s: 'a, sub: 'a * int32 -> 'b, n: int32)) =>
	 let val (a: 'b array, _) =
		(unfoldi_1 ('b, unit) (n,
				       (),
				       (fn x_1373: int32 * unit =>
					case x_1373 of
					  (i: int32, ()) => ((sub (s, i)), ()))))
	 in
	    a
	 end)
val rec
   sub: word64 * int32 -> char8 = 
      (fn x_1374: word64 * int32 =>
       case x_1374 of
	 ((cs: word64, i: int32)) =>
	 (idFromWord8 (getWord8 ((fromWord cs), (fromInt i)))))
val length: word64 -> int32 =
   (makeLength (char8, word64) (sub,
				(fn x_1375: char8 =>
				 case x_1375 of
				   0x0 => true | _ => false)))
val rec
   toCharArrayOfLength: word64 * int32 -> char8 array = 
      (fn x_1376: word64 * int32 =>
       case x_1376 of
	 ((cs: word64, n: int32)) =>
	 (toArrayOfLength (char8, word64) (cs, sub, n)))
val rec
   toStringOfLength: word64 * int32 -> string = 
      (fn x_1377: word64 * int32 =>
       case x_1377 of
	 ((cs: word64, n: int32)) =>
	 (unsafeFromArray_1 (fromPoly_0 (toCharArrayOfLength (cs, n)))))
val rec
   toString: word64 -> string = 
      (fn x_1378: word64 =>
       case x_1378 of
	 (cs: word64) => (toStringOfLength (cs, (length cs))))
val rec
   new: unit -> (unit -> unit) list ref = 
      (fn x_1379: unit =>
       case x_1379 of
	 (()) => (ref[(unit -> unit) list] []))
val rec 'a_3289
   addNew: 'a_3289 list ref * 'a_3289 -> unit = 
      (fn x_1380: 'a_3289 list ref * 'a_3289 =>
       case x_1380 of
	 ((cs: 'a_3289 list ref, f: 'a_3289)) =>
	 (:=_1 ('a_3289 list) (cs, (::['a_3289] (f, (!_1 ('a_3289 list) cs))))))
val rec
   clean: (unit -> unit) list ref -> unit = 
      (fn x_1381: (unit -> unit) list ref =>
       case x_1381 of
	 (cs: (unit -> unit) list ref) =>
	 ((app_1 (unit -> unit) (fn x_1382: unit -> unit =>
				 case x_1382 of
				   c: unit -> unit =>
				   (c ())
				   handle x_1383 => case x_1383 of
						      _ => ())) (!_1 ((unit -> unit) list) cs)))
val atExit: (unit -> unit) list ref = (new ())
val atLoadWorld: (unit -> unit) list ref = (new ())
val addNew_0: (unit -> unit) list ref * (unit -> unit) -> unit =
   addNew (unit -> unit)
val fromRep: int32 -> int32 = (fn x_1384: int32 => case x_1384 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1385: int32 => case x_1385 of x: int32 => x)
val fromRep: int32 -> int32 = (fn x_1386: int32 => case x_1386 of x: int32 => x)
val fromRep: int32 -> int32 = (fn x_1387: int32 => case x_1387 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1388: int32 => case x_1388 of x: int32 => x)
val fromRep: word32 -> word32 =
   (fn x_1389: word32 =>
    case x_1389 of
      x: word32 => x)
val fromRep: int32 -> int32 = (fn x_1390: int32 => case x_1390 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1391: int32 => case x_1391 of x: int32 => x)
val fromRep: word32 -> word32 =
   (fn x_1392: word32 =>
    case x_1392 of
      x: word32 => x)
val acces: int32 = (fromRep EACCES)
val addrinuse: int32 = (fromRep EADDRINUSE)
val addrnotavail: int32 = (fromRep EADDRNOTAVAIL)
val afnosupport: int32 = (fromRep EAFNOSUPPORT)
val again: int32 = (fromRep EAGAIN)
val already: int32 = (fromRep EALREADY)
val badf: int32 = (fromRep EBADF)
val badmsg: int32 = (fromRep EBADMSG)
val busy: int32 = (fromRep EBUSY)
val canceled: int32 = (fromRep ECANCELED)
val child: int32 = (fromRep ECHILD)
val connaborted: int32 = (fromRep ECONNABORTED)
val connrefused: int32 = (fromRep ECONNREFUSED)
val connreset: int32 = (fromRep ECONNRESET)
val deadlk: int32 = (fromRep EDEADLK)
val destaddrreq: int32 = (fromRep EDESTADDRREQ)
val dom: int32 = (fromRep EDOM)
val dquot: int32 = (fromRep EDQUOT)
val exist: int32 = (fromRep EEXIST)
val fault: int32 = (fromRep EFAULT)
val fbig: int32 = (fromRep EFBIG)
val hostunreach: int32 = (fromRep EHOSTUNREACH)
val idrm: int32 = (fromRep EIDRM)
val ilseq: int32 = (fromRep EILSEQ)
val inprogress: int32 = (fromRep EINPROGRESS)
val intr: int32 = (fromRep EINTR)
val inval: int32 = (fromRep EINVAL)
val io: int32 = (fromRep EIO)
val isconn: int32 = (fromRep EISCONN)
val isdir: int32 = (fromRep EISDIR)
val loop: int32 = (fromRep ELOOP)
val mfile: int32 = (fromRep EMFILE)
val mlink: int32 = (fromRep EMLINK)
val msgsize: int32 = (fromRep EMSGSIZE)
val multihop: int32 = (fromRep EMULTIHOP)
val nametoolong: int32 = (fromRep ENAMETOOLONG)
val netdown: int32 = (fromRep ENETDOWN)
val netreset: int32 = (fromRep ENETRESET)
val netunreach: int32 = (fromRep ENETUNREACH)
val nfile: int32 = (fromRep ENFILE)
val nobufs: int32 = (fromRep ENOBUFS)
val nodata: int32 = (fromRep ENODATA)
val nodev: int32 = (fromRep ENODEV)
val noent: int32 = (fromRep ENOENT)
val noexec: int32 = (fromRep ENOEXEC)
val nolck: int32 = (fromRep ENOLCK)
val nolink: int32 = (fromRep ENOLINK)
val nomem: int32 = (fromRep ENOMEM)
val nomsg: int32 = (fromRep ENOMSG)
val noprotoopt: int32 = (fromRep ENOPROTOOPT)
val nospc: int32 = (fromRep ENOSPC)
val nosr: int32 = (fromRep ENOSR)
val nostr: int32 = (fromRep ENOSTR)
val nosys: int32 = (fromRep ENOSYS)
val notconn: int32 = (fromRep ENOTCONN)
val notdir: int32 = (fromRep ENOTDIR)
val notempty: int32 = (fromRep ENOTEMPTY)
val notsock: int32 = (fromRep ENOTSOCK)
val notsup: int32 = (fromRep ENOTSUP)
val notty: int32 = (fromRep ENOTTY)
val nxio: int32 = (fromRep ENXIO)
val opnotsupp: int32 = (fromRep EOPNOTSUPP)
val overflow: int32 = (fromRep EOVERFLOW)
val perm: int32 = (fromRep EPERM)
val pipe: int32 = (fromRep EPIPE)
val proto: int32 = (fromRep EPROTO)
val protonosupport: int32 = (fromRep EPROTONOSUPPORT)
val prototype: int32 = (fromRep EPROTOTYPE)
val range: int32 = (fromRep ERANGE)
val rofs: int32 = (fromRep EROFS)
val spipe: int32 = (fromRep ESPIPE)
val srch: int32 = (fromRep ESRCH)
val stale: int32 = (fromRep ESTALE)
val time: int32 = (fromRep ETIME)
val timedout: int32 = (fromRep ETIMEDOUT)
val toobig: int32 = (fromRep E2BIG)
val txtbsy: int32 = (fromRep ETXTBSY)
val wouldblock: int32 = (fromRep EWOULDBLOCK)
val xdev: int32 = (fromRep EXDEV)
val rec 'a_3290
   ::?: (int32 * 'a_3290) * (int32 * 'a_3290) list -> (int32 * 'a_3290) list = 
      (fn x_1393: (int32 * 'a_3290) * (int32 * 'a_3290) list =>
       case x_1393 of
	 (((n: int32, s: 'a_3290), l: (int32 * 'a_3290) list)) =>
	 case (= (int32) (n, (fromRep 0xFFFFFFFF))) of
	   true => l | false => (::[int32 * 'a_3290] ((n, s), l)))
val errorNames: (int32 * string) list =
   (::? (string) ((acces, "acces"),
		  (::? (string) ((addrinuse, "addrinuse"),
				 (::? (string) ((addrnotavail, "addrnotavail"),
						(::? (string) ((afnosupport,
								"afnosupport"),
							       (::? (string) ((again,
									       "again"),
									      (::? (string) ((already,
											      "already"),
											     (::? (string) ((badf,
													     "badf"),
													    (::? (string) ((badmsg,
															    "badmsg"),
															   (::? (string) ((busy,
																	   "busy"),
																	  (::? (string) ((canceled,
																			  "canceled"),
																			 (::? (string) ((child,
																					 "child"),
																					(::? (string) ((connaborted,
																							"connaborted"),
																						       (::? (string) ((connrefused,
																								       "connrefused"),
																								      (::? (string) ((connreset,
																										      "connreset"),
																										     (::? (string) ((deadlk,
																												     "deadlk"),
																												    (::? (string) ((destaddrreq,
																														    "destaddrreq"),
																														   (::? (string) ((dom,
																																   "dom"),
																																  (::? (string) ((dquot,
																																		  "dquot"),
																																		 (::? (string) ((exist,
																																				 "exist"),
																																				(::? (string) ((fault,
																																						"fault"),
																																					       (::? (string) ((fbig,
																																							       "fbig"),
																																							      (::? (string) ((hostunreach,
																																									      "hostunreach"),
																																									     (::? (string) ((idrm,
																																											     "idrm"),
																																											    (::? (string) ((ilseq,
																																													    "ilseq"),
																																													   (::? (string) ((inprogress,
																																															   "inprogress"),
																																															  (::? (string) ((intr,
																																																	  "intr"),
																																																	 (::? (string) ((inval,
																																																			 "inval"),
																																																			(::? (string) ((io,
																																																					"io"),
																																																				       (::? (string) ((isconn,
																																																						       "isconn"),
																																																						      (::? (string) ((isdir,
																																																								      "isdir"),
																																																								     (::? (string) ((loop,
																																																										     "loop"),
																																																										    (::? (string) ((mfile,
																																																												    "mfile"),
																																																												   (::? (string) ((mlink,
																																																														   "mlink"),
																																																														  (::? (string) ((msgsize,
																																																																  "msgsize"),
																																																																 (::? (string) ((multihop,
																																																																		 "multihop"),
																																																																		(::? (string) ((nametoolong,
																																																																				"nametoolong"),
																																																																			       (::? (string) ((netdown,
																																																																					       "netdown"),
																																																																					      (::? (string) ((netreset,
																																																																							      "netreset"),
																																																																							     (::? (string) ((netunreach,
																																																																									     "netunreach"),
																																																																									    (::? (string) ((nfile,
																																																																											    "nfile"),
																																																																											   (::? (string) ((nobufs,
																																																																													   "nobufs"),
																																																																													  (::? (string) ((nodata,
																																																																															  "nodata"),
																																																																															 (::? (string) ((nodev,
																																																																																	 "nodev"),
																																																																																	(::? (string) ((noent,
																																																																																			"noent"),
																																																																																		       (::? (string) ((noexec,
																																																																																				       "noexec"),
																																																																																				      (::? (string) ((nolck,
																																																																																						      "nolck"),
																																																																																						     (::? (string) ((nolink,
																																																																																								     "nolink"),
																																																																																								    (::? (string) ((nomem,
																																																																																										    "nomem"),
																																																																																										   (::? (string) ((nomsg,
																																																																																												   "nomsg"),
																																																																																												  (::? (string) ((noprotoopt,
																																																																																														  "noprotoopt"),
																																																																																														 (::? (string) ((nospc,
																																																																																																 "nospc"),
																																																																																																(::? (string) ((nosr,
																																																																																																		"nosr"),
																																																																																																	       (::? (string) ((nostr,
																																																																																																			       "nostr"),
																																																																																																			      (::? (string) ((nosys,
																																																																																																					      "nosys"),
																																																																																																					     (::? (string) ((notconn,
																																																																																																							     "notconn"),
																																																																																																							    (::? (string) ((notdir,
																																																																																																									    "notdir"),
																																																																																																									   (::? (string) ((notempty,
																																																																																																											   "notempty"),
																																																																																																											  (::? (string) ((notsock,
																																																																																																													  "notsock"),
																																																																																																													 (::? (string) ((notsup,
																																																																																																															 "notsup"),
																																																																																																															(::? (string) ((notty,
																																																																																																																	"notty"),
																																																																																																																       (::? (string) ((nxio,
																																																																																																																		       "nxio"),
																																																																																																																		      (::? (string) ((opnotsupp,
																																																																																																																				      "opnotsupp"),
																																																																																																																				     (::? (string) ((overflow,
																																																																																																																						     "overflow"),
																																																																																																																						    (::? (string) ((perm,
																																																																																																																								    "perm"),
																																																																																																																								   (::? (string) ((pipe,
																																																																																																																										   "pipe"),
																																																																																																																										  (::? (string) ((proto,
																																																																																																																												  "proto"),
																																																																																																																												 (::? (string) ((protonosupport,
																																																																																																																														 "protonosupport"),
																																																																																																																														(::? (string) ((prototype,
																																																																																																																																"prototype"),
																																																																																																																															       (::? (string) ((range,
																																																																																																																																	       "range"),
																																																																																																																																	      (::? (string) ((rofs,
																																																																																																																																			      "rofs"),
																																																																																																																																			     (::? (string) ((spipe,
																																																																																																																																					     "spipe"),
																																																																																																																																					    (::? (string) ((srch,
																																																																																																																																							    "srch"),
																																																																																																																																							   (::? (string) ((stale,
																																																																																																																																									   "stale"),
																																																																																																																																									  (::? (string) ((time,
																																																																																																																																											  "time"),
																																																																																																																																											 (::? (string) ((timedout,
																																																																																																																																													 "timedout"),
																																																																																																																																													(::? (string) ((toobig,
																																																																																																																																															"toobig"),
																																																																																																																																														       (::? (string) ((txtbsy,
																																																																																																																																																       "txtbsy"),
																																																																																																																																																      (::? (string) ((wouldblock,
																																																																																																																																																		      "wouldblock"),
																																																																																																																																																		     (::? (string) ((xdev,
																																																																																																																																																				     "xdev"),
																																																																																																																																																				    []))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
exception SysErr of string * int32 Primitive.Option.t
val rec
   errorName: int32 -> string = 
      (fn x_1394: int32 =>
       case x_1394 of
	 (n: int32) =>
	 case ((find_0 (int32 * string) (fn x_1395: int32 * string =>
					 case x_1395 of
					   (m: int32, _) => (= (int32) (n, m)))) errorNames) of
	   NONE[int32 * string] => "<UNKNOWN>"
	 | SOME[int32 * string] (_, s: string) => s)
val _ =
   (addExnMessager (fn x_1396: exn =>
		    case x_1396 of
		      e: exn =>
		      case e of
			SysErr (s: string, eo: int32 Primitive.Option.t) =>
			(SOME[string] (concat_2 ["SysErr: ",
						 s,
						 case eo of
						   NONE[int32] => ""
						 | SOME[int32] e: int32 =>
						   (concat_2 [" [",
							      (errorName e),
							      "]"])]))
		      | _ => NONE[string]))
val rec
   errorMsg: int32 -> string = 
      (fn x_1397: int32 =>
       case x_1397 of
	 (n: int32) =>
	 let val cs: word64 = (strError (toRep n))
	 in
	    case (isNull (fromWord cs)) of
	      true => "Unknown error" | false => (toString cs)
	 end)
val rec 'a_3291
   raiseSys: int32 -> 'a_3291 = 
      (fn x_1398: int32 =>
       case x_1398 of
	 (n: int32) => raise (SysErr ((errorMsg n), (SOME[int32] n))))
val rec 'a_3292
   raiseSysWithMsg: int32 * string -> 'a_3292 = 
      (fn x_1399: int32 * string =>
       case x_1399 of
	 ((n: int32, msg: string)) =>
	 raise (SysErr ((^ ((^ ((errorMsg n), ": ")), msg)), (SOME[int32] n))))
val blocker: (unit -> unit -> unit) ref =
   (ref[unit -> unit -> unit] (fn x_1400: unit =>
			       case x_1400 of
				 () =>
				 (fn x_1401: unit =>
				  case x_1401 of
				    () => ())))
val restartFlag: bool ref = (ref[bool] true)
val ('b, ''a) syscallErr: {clear: bool, errVal: ''a, restart: bool}
			  * (unit
			     -> {handlers: (int32 * (unit -> 'b)) list,
				 post: ''a -> 'b,
				 return: ''a})
			  -> 'b =
   (fn x_1402: {clear: bool, errVal: ''a, restart: bool}
	       * (unit
		  -> {handlers: (int32 * (unit -> 'b)) list,
		      post: ''a -> 'b,
		      return: ''a}) =>
    case x_1402 of
      ({clear = clear: bool, restart = restart: bool, errVal = errVal: ''a},
       f: unit
	  -> {handlers: (int32 * (unit -> 'b)) list,
	      post: ''a -> 'b,
	      return: ''a}) =>
      let val rec
	     call: ({errno: int32, handlers: (int32 * (unit -> 'b)) list} -> 'b)
		   -> 'b = 
		(fn x_1410: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			    -> 'b =>
		 case x_1410 of
		   (err: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			 -> 'b) =>
		   let val () = (atomicBegin ())
		       val () =
			  case clear of
			    true => (clearErrno ()) | false => ()
		       val {return = return: ''a,
			    post = post: ''a -> 'b,
			    handlers = handlers: (int32 * (unit -> 'b)) list} =
			  (f ())
			  handle x_1411 => case x_1411 of
					     exn: exn =>
					     (atomicEnd ()) ;raise exn
		       val return: ''a = (check_0 (''a) return)
		   in
		      case (= (''a) (errVal, return)) of
			true =>
			let val e: int32 = (fromRep (getErrno ()))
			    val () = (atomicEnd ())
			in
			   (err {errno = e, handlers = handlers})
			end
		      | false =>
			(wind_0 ('b) ((fn x_1412: unit =>
				       case x_1412 of
					 () => (post return)),
				      atomicEnd))
		   end)
	  val rec
	     err: {default: unit -> 'b,
		   errno: int32,
		   handlers: (int32 * (unit -> 'b)) list}
		  -> 'b = 
		(fn x_1408: {default: unit -> 'b,
			     errno: int32,
			     handlers: (int32 * (unit -> 'b)) list} =>
		 case x_1408 of
		   ({default = default: unit -> 'b,
		     errno = errno: int32,
		     handlers = handlers: (int32 * (unit -> 'b)) list}) =>
		   case ((find_0 (int32 * (unit -> 'b)) (fn x_1409: int32
								    * (unit
								       -> 'b) =>
							 case x_1409 of
							   (e': int32, _) =>
							   (= (int32) (errno, e')))) handlers) of
		     NONE[int32 * (unit -> 'b)] => (default ())
		   | SOME[int32 * (unit -> 'b)] (_, handler: unit -> 'b) =>
		     (handler ()))
	  val rec
	     errBlocked: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			 -> 'b = 
		(fn x_1406: {errno: int32, handlers: (int32 * (unit -> 'b)) list} =>
		 case x_1406 of
		   ({errno = errno: int32,
		     handlers = handlers: (int32 * (unit -> 'b)) list}) =>
		   (err {default = (fn x_1407: unit =>
				    case x_1407 of
				      () => (raiseSys ('b) errno)),
			 errno = errno,
			 handlers = handlers}))
	  val rec
	     errUnblocked: {errno: int32, handlers: (int32 * (unit -> 'b)) list}
			   -> 'b = 
		(fn x_1403: {errno: int32, handlers: (int32 * (unit -> 'b)) list} =>
		 case x_1403 of
		   ({errno = errno: int32,
		     handlers = handlers: (int32 * (unit -> 'b)) list}) =>
		   (err {default = (fn x_1404: unit =>
				    case x_1404 of
				      () =>
				      case case case restart of
						  true =>
						  (= (int32) (errno, intr))
						| false => false of
					     true => (!_1 (bool) restartFlag)
					   | false => false of
					true =>
					case (= (word32) ((atomicState ()), 0x0)) of
					  true => (call errUnblocked)
					| false =>
					  let val finish: unit -> unit =
						 ((!_1 (unit -> unit -> unit) blocker) ())
					  in
					     (wind_0 ('b) ((fn x_1405: unit =>
							    case x_1405 of
							      () =>
							      (call errBlocked)),
							   finish))
					  end
				      | false => (raiseSys ('b) errno)),
			 errno = errno,
			 handlers = handlers}))
      in
	 (call errUnblocked)
      end)
val ''a_3293 simpleResultAux: {errVal: ''a_3293, restart: bool}
			      * (unit -> ''a_3293)
			      -> ''a_3293 =
   (fn x_1413: {errVal: ''a_3293, restart: bool} * (unit -> ''a_3293) =>
    case x_1413 of
      ({restart = restart: bool, errVal = errVal: ''a_3293}, f: unit -> ''a_3293) =>
      (syscallErr (''a_3293, ''a_3293) ({clear = false,
					 restart = restart,
					 errVal = errVal},
					(fn x_1414: unit =>
					 case x_1414 of
					   () =>
					   let val return: ''a_3293 = (f ())
					   in
					      {return = return,
					       post = (fn x_1415: ''a_3293 =>
						       case x_1415 of
							 ret: ''a_3293 => ret),
					       handlers = []}
					   end))))
val simpleResultRestart: (unit -> int32) -> int32 =
   (fn x_1416: unit -> int32 =>
    case x_1416 of
      f: unit -> int32 =>
      (simpleResultAux (int32) ({restart = true, errVal = (fromInt 0xFFFFFFFF)},
				f)))
val ''a_3294 simpleResultRestart': {errVal: ''a_3294} * (unit -> ''a_3294)
				   -> ''a_3294 =
   (fn x_1417: {errVal: ''a_3294} * (unit -> ''a_3294) =>
    case x_1417 of
      ({errVal = errVal: ''a_3294}, f: unit -> ''a_3294) =>
      (simpleResultAux (''a_3294) ({restart = true, errVal = errVal}, f)))
val ''a_3295 simpleResult': {errVal: ''a_3295} * (unit -> ''a_3295) -> ''a_3295 =
   (fn x_1418: {errVal: ''a_3295} * (unit -> ''a_3295) =>
    case x_1418 of
      ({errVal = errVal: ''a_3295}, f: unit -> ''a_3295) =>
      (simpleResultAux (''a_3295) ({restart = false, errVal = errVal}, f)))
val simpleRestart: (unit -> int32) -> unit =
   (o_1 (unit -> int32, unit, int32) (ignore_1 (int32), simpleResultRestart))
val ('a_3301, ''a_3300) syscall': {errVal: ''a_3300}
				  * (unit -> ''a_3300 * (''a_3300 -> 'a_3301))
				  -> 'a_3301 =
   (fn x_1419: {errVal: ''a_3300} * (unit -> ''a_3300 * (''a_3300 -> 'a_3301)) =>
    case x_1419 of
      ({errVal = errVal: ''a_3300}, f: unit -> ''a_3300 * (''a_3300 -> 'a_3301)) =>
      (syscallErr ('a_3301, ''a_3300) ({clear = false,
					restart = false,
					errVal = errVal},
				       (fn x_1420: unit =>
					case x_1420 of
					  () =>
					  let val (return: ''a_3300,
						   post: ''a_3300 -> 'a_3301) =
						 (f ())
					  in
					     {return = return,
					      post = post,
					      handlers = []}
					  end))))
val 'a_3303 syscall: (unit -> int32 * (int32 -> 'a_3303)) -> 'a_3303 =
   (fn x_1421: unit -> int32 * (int32 -> 'a_3303) =>
    case x_1421 of
      f: unit -> int32 * (int32 -> 'a_3303) =>
      (syscall' ('a_3303, int32) ({errVal = (fromInt 0xFFFFFFFF)}, f)))
val 'a raiseSysWithMsg_0: int32 * string -> 'a = raiseSysWithMsg ('a)
val 'a raiseSys_0: int32 -> 'a = raiseSys ('a)
val 'a syscall_0: (unit -> int32 * (int32 -> 'a)) -> 'a = syscall ('a)
val ''a simpleResultRestart'_0: {errVal: ''a} * (unit -> ''a) -> ''a =
   simpleResultRestart' (''a)
val ''a simpleResult'_0: {errVal: ''a} * (unit -> ''a) -> ''a =
   simpleResult' (''a)
exception Unordered
datatype IEEEReal.real_order = LESS
			       | EQUAL
			       | GREATER
			       | UNORDERED
datatype IEEEReal.float_class = INF
				| NAN
				| NORMAL
				| SUBNORMAL
				| ZERO
val rec 'a_3304
   mkClass: ('a_3304 -> int32) -> 'a_3304 -> IEEEReal.float_class = 
      (fn x_1422: 'a_3304 -> int32 =>
       (fn x_1423: 'a_3304 =>
	case (x_1422, x_1423) of
	  (class: 'a_3304 -> int32, x: 'a_3304) =>
	  let val i: int32 = (class x)
	  in
	     case (= (int32) (i, FP_NORMAL)) of
	       true => NORMAL
	     | false =>
	       case (= (int32) (i, FP_ZERO)) of
		 true => ZERO
	       | false =>
		 case (= (int32) (i, FP_INFINITE)) of
		   true => INF
		 | false =>
		   case (= (int32) (i, FP_NAN)) of
		     true => NAN
		   | false =>
		     case (= (int32) (i, FP_SUBNORMAL)) of
		       true => SUBNORMAL
		     | false => raise (Fail "Real_class returned bogus integer")
	  end))
datatype IEEEReal.RoundingMode.t = TO_NEAREST
				   | TO_NEGINF
				   | TO_POSINF
				   | TO_ZERO
val rec
   fromInt: int32 -> IEEEReal.RoundingMode.t = 
      (fn x_1424: int32 =>
       case x_1424 of
	 (i: int32) =>
	 let 
	 in
	    case (= (int32) (i, FE_TONEAREST)) of
	      true => TO_NEAREST
	    | false =>
	      case (= (int32) (i, FE_DOWNWARD)) of
		true => TO_NEGINF
	      | false =>
		case (= (int32) (i, FE_UPWARD)) of
		  true => TO_POSINF
		| false =>
		  case (= (int32) (i, FE_TOWARDZERO)) of
		    true => TO_ZERO
		  | false => raise (Fail "IEEEReal.RoundingMode.fromInt")
	 end)
val rec
   toInt: IEEEReal.RoundingMode.t -> int32 = 
      (fn x_1425: IEEEReal.RoundingMode.t =>
       case x_1425 of
	 (m: IEEEReal.RoundingMode.t) =>
	 let val i: int32 =
		case m of
		  TO_NEAREST => FE_TONEAREST
		| TO_NEGINF => FE_DOWNWARD
		| TO_POSINF => FE_UPWARD
		| TO_ZERO => FE_TOWARDZERO
	 in
	    case (= (int32) (i, FE_NOSUPPORT)) of
	      true => raise (Fail "IEEEReal rounding mode not supported")
	    | false => i
	 end)
val rec
   setRoundingMode: IEEEReal.RoundingMode.t -> unit = 
      (fn x_1426: IEEEReal.RoundingMode.t =>
       case x_1426 of
	 (m: IEEEReal.RoundingMode.t) =>
	 case (= (int32) ((setRoundingMode (toInt m)), 0x0)) of
	   true => () | false => raise (raiseSys_0 (exn) inval))
val getRoundingMode: unit -> IEEEReal.RoundingMode.t =
   (o_1 (unit, IEEEReal.RoundingMode.t, int32) (fromInt, getRoundingMode))
val rec 'a
   withRoundingMode: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a = 
      (fn x_1427: IEEEReal.RoundingMode.t * (unit -> 'a) =>
       case x_1427 of
	 ((m: IEEEReal.RoundingMode.t, th: unit -> 'a)) =>
	 let val m': IEEEReal.RoundingMode.t = (getRoundingMode ())
	     val _ = (setRoundingMode m)
	     val res: 'a = (th ())
	     val _ = (setRoundingMode m')
	 in
	    res
	 end)
val rec
   toString: {class: IEEEReal.float_class,
	      digits: int32 list,
	      exp: int32,
	      sign: bool}
	     -> string = 
      (fn x_1428: {class: IEEEReal.float_class,
		   digits: int32 list,
		   exp: int32,
		   sign: bool} =>
       case x_1428 of
	 ({class = class: IEEEReal.float_class,
	   sign = sign: bool,
	   digits = digits: int32 list,
	   exp = exp: int32}) =>
	 let val rec
		digitStr: unit -> string = 
		   (fn x_1430: unit =>
		    case x_1430 of
		      (()) =>
		      (implode ((map_2 (char8, int32) digitToChar) digits)))
	     val rec
		norm: unit -> string = 
		   (fn x_1429: unit =>
		    case x_1429 of
		      (()) =>
		      let val num: string = (^ ("0.", (digitStr ())))
		      in
			 case (= (int32) (exp, 0x0)) of
			   true => num
			 | false => (concat_2 [num, "E", (toString exp)])
		      end)
	     val num: string =
		case class of
		  ZERO => "0.0"
		| NORMAL => (norm ())
		| SUBNORMAL => (norm ())
		| INF => "inf"
		| NAN => "nan"
	 in
	    case sign of
	      true => (^ ("~", num)) | false => num
	 end)
val 'a withRoundingMode_0: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a =
   withRoundingMode ('a)
val 'a mkClass_0: ('a -> int32) -> 'a -> IEEEReal.float_class = mkClass ('a)
val +: real32 * real32 -> real32 = +
val -: real32 * real32 -> real32 = -
val /: real32 * real32 -> real32 = /
val <: real32 * real32 -> bool = <
val <=: real32 * real32 -> bool = <=
val >: real32 * real32 -> bool = >
val >=: real32 * real32 -> bool = >=
val ~: real32 -> real32 = ~
val realSize: int32 = (toInt realSize)
val precision: int32 = (toInt precision)
val signBit: real32 -> bool =
   (fn x_1431: real32 =>
    case x_1431 of
      r: real32 => (<> (int32) ((signBit r), 0x0)))
val rec 'a
   make: {fromRealUnsafe: 'a -> real32,
	  other: {precision: int32},
	  toRealUnsafe: real32 -> 'a}
	 -> (IEEEReal.RoundingMode.t -> 'a -> real32) * (real32 -> 'a) = 
      (fn x_1432: {fromRealUnsafe: 'a -> real32,
		   other: {precision: int32},
		   toRealUnsafe: real32 -> 'a} =>
       case x_1432 of
	 ({fromRealUnsafe = fromRealUnsafe: 'a -> real32,
	   toRealUnsafe = toRealUnsafe: real32 -> 'a,
	   other = other: {precision: int32}}) =>
	 case (= (int32) (precision,
			  ((fn x_1437: {precision: int32} =>
			    case x_1437 of
			      {precision = #: int32} => #) other))) of
	   true =>
	   ((fn x_1433: IEEEReal.RoundingMode.t =>
	     case x_1433 of
	       _ => fromRealUnsafe),
	    toRealUnsafe)
	 | false =>
	   ((fn x_1434: IEEEReal.RoundingMode.t =>
	     case x_1434 of
	       m: IEEEReal.RoundingMode.t =>
	       (fn x_1435: 'a =>
		case x_1435 of
		  r: 'a =>
		  (withRoundingMode_0 (real32) (m,
						(fn x_1436: unit =>
						 case x_1436 of
						   () => (fromRealUnsafe r)))))),
	    toRealUnsafe))
val (fromReal32: IEEEReal.RoundingMode.t -> real32 -> real32,
     toReal32: real32 -> real32) =
   (make (real32) {fromRealUnsafe = fromReal32Unsafe,
		   toRealUnsafe = toReal32Unsafe,
		   other = {precision = precision}})
val fReal32: real32 -> real32 = toReal32
val _ = fReal32
val fReal32: IEEEReal.RoundingMode.t -> real32 -> real32 = fromReal32
val _ = fReal32
val zero: real32 = (fromInt32Unsafe 0x0)
val one: real32 = (fromInt32Unsafe 0x1)
val two: real32 = (fromInt32Unsafe 0x2)
val half: real32 = (/ (one, two))
val class: real32 -> IEEEReal.float_class = (mkClass_0 (real32) class)
val rec
   roundReal: real32 * IEEEReal.RoundingMode.t -> real32 = 
      (fn x_1438: real32 * IEEEReal.RoundingMode.t =>
       case x_1438 of
	 ((x: real32, m: IEEEReal.RoundingMode.t)) =>
	 (withRoundingMode_0 (real32) (m,
				       (fn x_1439: unit =>
					case x_1439 of
					  () => (round x)))))
val rec
   strto: string * IEEEReal.RoundingMode.t -> real32 = 
      (fn x_1440: string * IEEEReal.RoundingMode.t =>
       case x_1440 of
	 ((str: string, rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (strto (str, rounding))
	 end)
exception Bad
datatype Real.mode = Fix
		     | Gen
		     | Sci
val one: int32 ref One.t =
   (make_0 (int32 ref) (fn x_1441: unit =>
			case x_1441 of
			  () => (ref[int32] 0x0)))
val rec
   gdtoa: real32 * Real.mode * int32 * IEEEReal.RoundingMode.t -> word64 * int32 = 
      (fn x_1442: real32 * Real.mode * int32 * IEEEReal.RoundingMode.t =>
       case x_1442 of
	 ((x: real32,
	   mode: Real.mode,
	   ndig: int32,
	   rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val mode: int32 = case mode of Fix => 0x3 | Gen => 0x0 | Sci => 0x2
	     val ndig: int32 = (fromInt ndig)
	     val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (use_0 (word64 * int32, int32 ref) (one,
						(fn x_1443: int32 ref =>
						 case x_1443 of
						   decpt: int32 ref =>
						   ((gdtoa (x,
							    mode,
							    ndig,
							    rounding,
							    decpt)),
						    (toInt (!_1 (int32) decpt))))))
	 end)
val rec
   toDecimal: real32
	      -> {class: IEEEReal.float_class,
		  digits: int32 list,
		  exp: int32,
		  sign: bool} = 
      (fn x_1444: real32 =>
       case x_1444 of
	 (x: real32) =>
	 case (class x) of
	   INF => {class = INF, digits = [], exp = 0x0, sign = (< (x, zero))}
	 | NAN => {class = NAN, digits = [], exp = 0x0, sign = false}
	 | ZERO => {class = ZERO, digits = [], exp = 0x0, sign = (signBit x)}
	 | c: IEEEReal.float_class =>
	   let val (cs: word64, exp: int32) = (gdtoa (x, Gen, 0x0, TO_NEAREST))
	       val rec
		  loop: int32 * int32 list -> int32 list = 
		     (fn x_1445: int32 * int32 list =>
		      case x_1445 of
			((i: int32, ac: int32 list)) =>
			case (< (i, 0x0)) of
			  true => ac
			| false =>
			  (loop ((- (i, 0x1)),
				 (::[int32] ((- ((ord (sub (cs, i))), (ord 0x30))),
					     ac)))))
	       val digits: int32 list = (loop ((- ((length cs), 0x1)), []))
	   in
	      {class = c, digits = digits, exp = exp, sign = (< (x, zero))}
	   end)
val rec
   fix: string * word64 * int32 * int32 -> string = 
      (fn x_1446: string * word64 * int32 * int32 =>
       case x_1446 of
	 ((sign: string, cs: word64, decpt: int32, ndig: int32)) =>
	 let val length: int32 = (length cs)
	 in
	    case (< (decpt, 0x0)) of
	      true =>
	      (concat_2 [sign,
			 "0.",
			 (new ((~ decpt), 0x30)),
			 (toString cs),
			 (new ((+ ((- (ndig, length)), decpt)), 0x30))])
	    | false =>
	      let val whole: string =
		     case (= (int32) (decpt, 0x0)) of
		       true => "0"
		     | false =>
		       (tabulate_4 (decpt,
				    (fn x_1447: int32 =>
				     case x_1447 of
				       i: int32 =>
				       case (< (i, length)) of
					 true => (sub (cs, i)) | false => 0x30)))
	      in
		 case (= (int32) (0x0, ndig)) of
		   true => (concat_2 [sign, whole])
		 | false =>
		   let val frac: string =
			  (tabulate_4 (ndig,
				       (fn x_1448: int32 =>
					case x_1448 of
					  i: int32 =>
					  let val j: int32 = (+ (i, decpt))
					  in
					     case (< (j, length)) of
					       true => (sub (cs, j))
					     | false => 0x30
					  end)))
		   in
		      (concat_2 [sign, whole, ".", frac])
		   end
	      end
	 end)
val rec
   sci: real32 * int32 -> string = 
      (fn x_1449: real32 * int32 =>
       case x_1449 of
	 ((x: real32, ndig: int32)) =>
	 let val sign: string = case (< (x, zero)) of true => "~" | false => ""
	     val (cs: word64, decpt: int32) =
		(gdtoa (x, Sci, (+ (0x1, ndig)), (getRoundingMode ())))
	     val length: int32 = (length cs)
	     val whole: string =
		(tabulate_4 (0x1,
			     (fn x_1451: int32 =>
			      case x_1451 of
				_ => (sub (cs, 0x0)))))
	     val frac: string =
		case (= (int32) (0x0, ndig)) of
		  true => ""
		| false =>
		  (concat_2 [".",
			     (tabulate_4 (ndig,
					  (fn x_1450: int32 =>
					   case x_1450 of
					     i: int32 =>
					     let val j: int32 = (+ (i, 0x1))
					     in
						case (< (j, length)) of
						  true => (sub (cs, j))
						| false => 0x30
					     end)))])
	     val exp: int32 = (- (decpt, 0x1))
	     val exp: string =
		let val (exp: int32, sign: string) =
		       case (< (exp, 0x0)) of
			 true => ((~ exp), "~") | false => (exp, "")
		in
		   (concat_2 [sign, (toString exp)])
		end
	 in
	    (concat_2 [sign, whole, frac, "E", exp])
	 end)
val rec
   gen: real32 * int32 -> string = 
      (fn x_1452: real32 * int32 =>
       case x_1452 of
	 ((x: real32, n: int32)) =>
	 case (class x) of
	   INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	 | NAN => "nan"
	 | _ =>
	   let val (prefix: string, x: real32) =
		  case (< (x, zero)) of
		    true => ("~", (~ x)) | false => ("", x)
	       val ss: char8 Sequence.Slice.t = (full_5 (sci (x, (- (n, 0x1)))))
	       val rec
		  isE: char8 -> bool = 
		     (fn x_1459: char8 =>
		      case x_1459 of
			(c: char8) => (= (char8) (c, 0x45)))
	       val rec
		  isZero: char8 -> bool = 
		     (fn x_1458: char8 =>
		      case x_1458 of
			(c: char8) => (= (char8) (c, 0x30)))
	       val expS: string =
		  (string ((taker_2 (o_1 (char8, bool, bool) (not, isE))) ss))
	       val exp: int32 = (valOf_1 (int32) (fromString expS))
	       val man: string =
		  ((translate_2 (fn x_1457: char8 =>
				 case x_1457 of
				   0x2E => "" | c: char8 => (str c))) (string ((dropr_2 isZero) ((takel_2 (o_1 (char8,
									     bool,
									     bool) (not,
										    isE))) ss))))
	       val manSize: int32 = (size man)
	       val rec
		  zeros: int32 -> string = 
		     (fn x_1455: int32 =>
		      case x_1455 of
			(i: int32) =>
			(tabulate_4 (i,
				     (fn x_1456: int32 =>
				      case x_1456 of
					_ => 0x30))))
	       val rec
		  dotAt: int32 -> string = 
		     (fn x_1454: int32 =>
		      case x_1454 of
			(i: int32) =>
			(concat_2 [(substring (man, 0x0, i)),
				   ".",
				   (extract (man, i, NONE[int32]))]))
	       val rec
		  sci: unit -> string = 
		     (fn x_1453: unit =>
		      case x_1453 of
			(()) =>
			(concat_2 [prefix,
				   case (= (int32) (manSize, 0x1)) of
				     true => man | false => (dotAt 0x1),
				   "E",
				   expS]))
	       val -: int32 * int32 -> int32 = -
	       val +: int32 * int32 -> int32 = +
	       val ~: int32 -> int32 = ~
	       val >=: int32 * int32 -> bool = >=
	   in
	      case (>= (exp,
			case (= (int32) (manSize, 0x1)) of
			  true => 0x3 | false => (+ (manSize, 0x3)))) of
		true => (sci ())
	      | false =>
		case (>= (exp, (- (manSize, 0x1)))) of
		  true =>
		  (concat_2 [prefix, man, (zeros (- (exp, (- (manSize, 0x1)))))])
		| false =>
		  case (>= (exp, 0x0)) of
		    true => (concat_2 [prefix, (dotAt (+ (exp, 0x1)))])
		  | false =>
		    case (>= (exp,
			      case (= (int32) (manSize, 0x1)) of
				true => 0xFFFFFFFE | false => 0xFFFFFFFD)) of
		      true =>
		      (concat_2 [prefix, "0.", (zeros (- ((~ exp), 0x1))), man])
		    | false => (sci ())
	   end)
val rec
   fmt: StringCvt.realfmt -> real32 -> string = 
      (fn x_1460: StringCvt.realfmt =>
       case x_1460 of
	 (spec: StringCvt.realfmt) =>
	 let val doit: real32 -> string =
		case spec of
		  EXACT =>
		  (o_1 (real32,
			string,
			{class: IEEEReal.float_class,
			 digits: int32 list,
			 exp: int32,
			 sign: bool}) (toString, toDecimal))
		| FIX opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1461: real32 =>
		      case x_1461 of
			x: real32 =>
			let val sign: string =
			       case (< (x, zero)) of
				 true => "~" | false => ""
			    val (cs: word64, decpt: int32) =
			       (gdtoa (x, Fix, n, (getRoundingMode ())))
			in
			   (fix (sign, cs, decpt, n))
			end)
		  end
		| GEN opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0xC
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x1)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1462: real32 =>
		      case x_1462 of
			x: real32 => (gen (x, n)))
		  end
		| SCI opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1463: real32 =>
		      case x_1463 of
			x: real32 => (sci (x, n)))
		  end
	 in
	    (fn x_1464: real32 =>
	     case x_1464 of
	       x: real32 =>
	       case (class x) of
		 NAN => "nan"
	       | INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	       | _ => (doit x))
	 end)
val rec 'a
   make: {fromIntUnsafe: 'a -> real32,
	  other: {maxInt': 'a, minInt': 'a, precision': int32},
	  toIntUnsafe: real32 -> 'a}
	 -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
      (fn x_1465: {fromIntUnsafe: 'a -> real32,
		   other: {maxInt': 'a, minInt': 'a, precision': int32},
		   toIntUnsafe: real32 -> 'a} =>
       case x_1465 of
	 ({fromIntUnsafe = fromIntUnsafe: 'a -> real32,
	   toIntUnsafe = toIntUnsafe: real32 -> 'a,
	   other = other: {maxInt': 'a, minInt': 'a, precision': int32}}) =>
	 (fromIntUnsafe,
	  case (< (precision,
		   ((fn x_1475: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1475 of
		       {precision' = #: int32} => #) other))) of
	    true =>
	    let val maxInt': 'a =
		   ((fn x_1468: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1468 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1467: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1467 of
		       {minInt' = #: 'a} => #) other)
		val (maxInt: real32, minInt: real32) =
		   (withRoundingMode_0 (real32 * real32) (TO_ZERO,
							  (fn x_1466: unit =>
							   case x_1466 of
							     () =>
							     ((fromIntUnsafe maxInt'),
							      (fromIntUnsafe minInt')))))
	    in
	       (fn x_1469: IEEEReal.RoundingMode.t =>
		case x_1469 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1470: real32 =>
		   case x_1470 of
		     x: real32 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true => raise Overflow | false => raise Domain))
	    end
	  | false =>
	    let val maxInt': 'a =
		   ((fn x_1472: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1472 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1471: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1471 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real32 = (fromIntUnsafe maxInt')
		val minInt: real32 = (fromIntUnsafe minInt')
	    in
	       (fn x_1473: IEEEReal.RoundingMode.t =>
		case x_1473 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1474: real32 =>
		   case x_1474 of
		     x: real32 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false =>
			 case (< (x, (+ (maxInt, one)))) of
			   true =>
			   case m of
			     TO_NEGINF => maxInt'
			   | TO_POSINF => raise Overflow
			   | TO_ZERO => maxInt'
			   | TO_NEAREST =>
			     case (>= ((- (x, maxInt)), half)) of
			       true => raise Overflow | false => maxInt'
			 | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true =>
			 case (< ((- (minInt, one)), x)) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => minInt'
			   | TO_ZERO => minInt'
			   | TO_NEAREST =>
			     case (< ((- (x, minInt)), (~ half))) of
			       true => raise Overflow | false => minInt'
			 | false => raise Overflow
		       | false => raise Domain))
	    end))
val (fromInt8: int8 -> real32, toInt8: IEEEReal.RoundingMode.t -> real32 -> int8) =
   (make (int8) {fromIntUnsafe = fromInt8Unsafe,
		 toIntUnsafe = toInt8Unsafe,
		 other = {maxInt' = maxInt',
			  minInt' = minInt',
			  precision' = precision'}})
val (fromInt16: int16 -> real32,
     toInt16: IEEEReal.RoundingMode.t -> real32 -> int16) =
   (make (int16) {fromIntUnsafe = fromInt16Unsafe,
		  toIntUnsafe = toInt16Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt32: int32 -> real32,
     toInt32: IEEEReal.RoundingMode.t -> real32 -> int32) =
   (make (int32) {fromIntUnsafe = fromInt32Unsafe,
		  toIntUnsafe = toInt32Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt64: int64 -> real32,
     toInt64: IEEEReal.RoundingMode.t -> real32 -> int64) =
   (make (int64) {fromIntUnsafe = fromInt64Unsafe,
		  toIntUnsafe = toInt64Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val fromIntInf: intInf -> real32 =
   (fn x_1476: intInf =>
    case x_1476 of
      i: intInf =>
      let val str: string =
	     case (< (i, 0)) of
	       true => (^ ("-", (toString (~ i)))) | false => (toString i)
	  val x: real32 = (strto ((nullTerm str), (getRoundingMode ())))
      in
	 x
      end)
val toIntInf: IEEEReal.RoundingMode.t -> real32 -> intInf =
   (fn x_1477: IEEEReal.RoundingMode.t =>
    case x_1477 of
      mode: IEEEReal.RoundingMode.t =>
      (fn x_1478: real32 =>
       case x_1478 of
	 x: real32 =>
	 case (class x) of
	   INF => raise Overflow
	 | NAN => raise Domain
	 | ZERO => 0
	 | _ =>
	   let val x: real32 = (roundReal (x, mode))
	   in
	      case (class x) of
		INF => raise Overflow
	      | _ =>
		(valOf_1 (intInf) (fromString ((fmt (FIX (SOME[int32] 0x0))) x)))
	   end))
val fInt8: int8 -> real32 = fromInt8
val fInt16: int16 -> real32 = fromInt16
val fInt64: int64 -> real32 = fromInt64
val fIntInf: intInf -> real32 = fromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> real32 = fromInt8
val fInt16: int16 -> real32 = fromInt16
val fInt32: int32 -> real32 = fromInt32
val fInt64: int64 -> real32 = fromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: IEEEReal.RoundingMode.t -> real32 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real32 -> int16 = toInt16
val fInt64: IEEEReal.RoundingMode.t -> real32 -> int64 = toInt64
val fIntInf: IEEEReal.RoundingMode.t -> real32 -> intInf = toIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: IEEEReal.RoundingMode.t -> real32 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real32 -> int16 = toInt16
val fInt32: IEEEReal.RoundingMode.t -> real32 -> int32 = toInt32
val fInt64: IEEEReal.RoundingMode.t -> real32 -> int64 = toInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val rec 'a
   make: {fromWordUnsafe: 'a -> real32,
	  other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
	  toWordUnsafe: real32 -> 'a}
	 -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
      (fn x_1479: {fromWordUnsafe: 'a -> real32,
		   other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
		   toWordUnsafe: real32 -> 'a} =>
       case x_1479 of
	 ({fromWordUnsafe = fromWordUnsafe: 'a -> real32,
	   toWordUnsafe = toWordUnsafe: real32 -> 'a,
	   other = other: {maxWord': 'a, wordSize: int32, zeroWord: 'a}}) =>
	 (fromWordUnsafe,
	  case (<= (precision,
		    ((fn x_1489: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		      case x_1489 of
			{wordSize = #: int32} => #) other))) of
	    true =>
	    let val maxWord': 'a =
		   ((fn x_1482: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1482 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real32 =
		   (withRoundingMode_0 (real32) (TO_ZERO,
						 (fn x_1481: unit =>
						  case x_1481 of
						    () =>
						    (fromWordUnsafe maxWord'))))
		val zeroWord: 'a =
		   ((fn x_1480: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1480 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1483: IEEEReal.RoundingMode.t =>
		case x_1483 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1484: real32 =>
		   case x_1484 of
		     x: real32 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end
	  | false =>
	    let val maxWord': 'a =
		   ((fn x_1486: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1486 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real32 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1485: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1485 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1487: IEEEReal.RoundingMode.t =>
		case x_1487 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1488: real32 =>
		   case x_1488 of
		     x: real32 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false =>
			   case (< (x, (+ (maxWord, one)))) of
			     true =>
			     case m of
			       TO_NEGINF => maxWord'
			     | TO_POSINF => raise Overflow
			     | TO_ZERO => maxWord'
			     | TO_NEAREST =>
			       case (>= ((- (x, maxWord)), half)) of
				 true => raise Overflow | false => maxWord'
			   | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end))
val (fromWord8: word8 -> real32,
     toWord8: IEEEReal.RoundingMode.t -> real32 -> word8) =
   (make (word8) {fromWordUnsafe = fromWord8Unsafe,
		  toWordUnsafe = toWord8Unsafe,
		  other = {maxWord' = maxWord',
			   wordSize = wordSize,
			   zeroWord = zero}})
val (fromWord16: word16 -> real32,
     toWord16: IEEEReal.RoundingMode.t -> real32 -> word16) =
   (make (word16) {fromWordUnsafe = fromWord16Unsafe,
		   toWordUnsafe = toWord16Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord32: word32 -> real32,
     toWord32: IEEEReal.RoundingMode.t -> real32 -> word32) =
   (make (word32) {fromWordUnsafe = fromWord32Unsafe,
		   toWordUnsafe = toWord32Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord64: word64 -> real32,
     toWord64: IEEEReal.RoundingMode.t -> real32 -> word64) =
   (make (word64) {fromWordUnsafe = fromWord64Unsafe,
		   toWordUnsafe = toWord64Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val fWord8: word8 -> real32 = fromWord8
val fWord16: word16 -> real32 = fromWord16
val fWord64: word64 -> real32 = fromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> real32 = fromWord8
val fWord16: word16 -> real32 = fromWord16
val fWord32: word32 -> real32 = fromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: IEEEReal.RoundingMode.t -> real32 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real32 -> word16 = toWord16
val fWord64: IEEEReal.RoundingMode.t -> real32 -> word64 = toWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: IEEEReal.RoundingMode.t -> real32 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real32 -> word16 = toWord16
val fWord32: IEEEReal.RoundingMode.t -> real32 -> word32 = toWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val +: real64 * real64 -> real64 = +
val -: real64 * real64 -> real64 = -
val /: real64 * real64 -> real64 = /
val <: real64 * real64 -> bool = <
val <=: real64 * real64 -> bool = <=
val >: real64 * real64 -> bool = >
val >=: real64 * real64 -> bool = >=
val ~: real64 -> real64 = ~
val precision: int32 = (toInt precision)
val signBit: real64 -> bool =
   (fn x_1490: real64 =>
    case x_1490 of
      r: real64 => (<> (int32) ((signBit r), 0x0)))
val rec 'a
   make: {fromRealUnsafe: 'a -> real64,
	  other: {precision: int32},
	  toRealUnsafe: real64 -> 'a}
	 -> (IEEEReal.RoundingMode.t -> 'a -> real64) * (real64 -> 'a) = 
      (fn x_1491: {fromRealUnsafe: 'a -> real64,
		   other: {precision: int32},
		   toRealUnsafe: real64 -> 'a} =>
       case x_1491 of
	 ({fromRealUnsafe = fromRealUnsafe: 'a -> real64,
	   toRealUnsafe = toRealUnsafe: real64 -> 'a,
	   other = other: {precision: int32}}) =>
	 case (= (int32) (precision,
			  ((fn x_1496: {precision: int32} =>
			    case x_1496 of
			      {precision = #: int32} => #) other))) of
	   true =>
	   ((fn x_1492: IEEEReal.RoundingMode.t =>
	     case x_1492 of
	       _ => fromRealUnsafe),
	    toRealUnsafe)
	 | false =>
	   ((fn x_1493: IEEEReal.RoundingMode.t =>
	     case x_1493 of
	       m: IEEEReal.RoundingMode.t =>
	       (fn x_1494: 'a =>
		case x_1494 of
		  r: 'a =>
		  (withRoundingMode_0 (real64) (m,
						(fn x_1495: unit =>
						 case x_1495 of
						   () => (fromRealUnsafe r)))))),
	    toRealUnsafe))
val (fromReal32: IEEEReal.RoundingMode.t -> real32 -> real64,
     toReal32: real64 -> real32) =
   (make (real32) {fromRealUnsafe = fromReal32Unsafe,
		   toRealUnsafe = toReal32Unsafe,
		   other = {precision = precision}})
val fReal32: real64 -> real32 = toReal32
val _ = fReal32
val fReal32: IEEEReal.RoundingMode.t -> real32 -> real64 = fromReal32
val _ = fReal32
val zero: real64 = (fromInt32Unsafe 0x0)
val one: real64 = (fromInt32Unsafe 0x1)
val two: real64 = (fromInt32Unsafe 0x2)
val half: real64 = (/ (one, two))
val class: real64 -> IEEEReal.float_class = (mkClass_0 (real64) class)
val rec
   roundReal: real64 * IEEEReal.RoundingMode.t -> real64 = 
      (fn x_1497: real64 * IEEEReal.RoundingMode.t =>
       case x_1497 of
	 ((x: real64, m: IEEEReal.RoundingMode.t)) =>
	 (withRoundingMode_0 (real64) (m,
				       (fn x_1498: unit =>
					case x_1498 of
					  () => (round x)))))
val rec
   strto: string * IEEEReal.RoundingMode.t -> real64 = 
      (fn x_1499: string * IEEEReal.RoundingMode.t =>
       case x_1499 of
	 ((str: string, rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (strto (str, rounding))
	 end)
exception Bad
datatype Real.mode = Fix
		     | Gen
		     | Sci
val one: int32 ref One.t =
   (make_0 (int32 ref) (fn x_1500: unit =>
			case x_1500 of
			  () => (ref[int32] 0x0)))
val rec
   gdtoa: real64 * Real.mode * int32 * IEEEReal.RoundingMode.t -> word64 * int32 = 
      (fn x_1501: real64 * Real.mode * int32 * IEEEReal.RoundingMode.t =>
       case x_1501 of
	 ((x: real64,
	   mode: Real.mode,
	   ndig: int32,
	   rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val mode: int32 = case mode of Fix => 0x3 | Gen => 0x0 | Sci => 0x2
	     val ndig: int32 = (fromInt ndig)
	     val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (use_0 (word64 * int32, int32 ref) (one,
						(fn x_1502: int32 ref =>
						 case x_1502 of
						   decpt: int32 ref =>
						   ((gdtoa (x,
							    mode,
							    ndig,
							    rounding,
							    decpt)),
						    (toInt (!_1 (int32) decpt))))))
	 end)
val rec
   toDecimal: real64
	      -> {class: IEEEReal.float_class,
		  digits: int32 list,
		  exp: int32,
		  sign: bool} = 
      (fn x_1503: real64 =>
       case x_1503 of
	 (x: real64) =>
	 case (class x) of
	   INF => {class = INF, digits = [], exp = 0x0, sign = (< (x, zero))}
	 | NAN => {class = NAN, digits = [], exp = 0x0, sign = false}
	 | ZERO => {class = ZERO, digits = [], exp = 0x0, sign = (signBit x)}
	 | c: IEEEReal.float_class =>
	   let val (cs: word64, exp: int32) = (gdtoa (x, Gen, 0x0, TO_NEAREST))
	       val rec
		  loop: int32 * int32 list -> int32 list = 
		     (fn x_1504: int32 * int32 list =>
		      case x_1504 of
			((i: int32, ac: int32 list)) =>
			case (< (i, 0x0)) of
			  true => ac
			| false =>
			  (loop ((- (i, 0x1)),
				 (::[int32] ((- ((ord (sub (cs, i))), (ord 0x30))),
					     ac)))))
	       val digits: int32 list = (loop ((- ((length cs), 0x1)), []))
	   in
	      {class = c, digits = digits, exp = exp, sign = (< (x, zero))}
	   end)
val rec
   fix: string * word64 * int32 * int32 -> string = 
      (fn x_1505: string * word64 * int32 * int32 =>
       case x_1505 of
	 ((sign: string, cs: word64, decpt: int32, ndig: int32)) =>
	 let val length: int32 = (length cs)
	 in
	    case (< (decpt, 0x0)) of
	      true =>
	      (concat_2 [sign,
			 "0.",
			 (new ((~ decpt), 0x30)),
			 (toString cs),
			 (new ((+ ((- (ndig, length)), decpt)), 0x30))])
	    | false =>
	      let val whole: string =
		     case (= (int32) (decpt, 0x0)) of
		       true => "0"
		     | false =>
		       (tabulate_4 (decpt,
				    (fn x_1506: int32 =>
				     case x_1506 of
				       i: int32 =>
				       case (< (i, length)) of
					 true => (sub (cs, i)) | false => 0x30)))
	      in
		 case (= (int32) (0x0, ndig)) of
		   true => (concat_2 [sign, whole])
		 | false =>
		   let val frac: string =
			  (tabulate_4 (ndig,
				       (fn x_1507: int32 =>
					case x_1507 of
					  i: int32 =>
					  let val j: int32 = (+ (i, decpt))
					  in
					     case (< (j, length)) of
					       true => (sub (cs, j))
					     | false => 0x30
					  end)))
		   in
		      (concat_2 [sign, whole, ".", frac])
		   end
	      end
	 end)
val rec
   sci: real64 * int32 -> string = 
      (fn x_1508: real64 * int32 =>
       case x_1508 of
	 ((x: real64, ndig: int32)) =>
	 let val sign: string = case (< (x, zero)) of true => "~" | false => ""
	     val (cs: word64, decpt: int32) =
		(gdtoa (x, Sci, (+ (0x1, ndig)), (getRoundingMode ())))
	     val length: int32 = (length cs)
	     val whole: string =
		(tabulate_4 (0x1,
			     (fn x_1510: int32 =>
			      case x_1510 of
				_ => (sub (cs, 0x0)))))
	     val frac: string =
		case (= (int32) (0x0, ndig)) of
		  true => ""
		| false =>
		  (concat_2 [".",
			     (tabulate_4 (ndig,
					  (fn x_1509: int32 =>
					   case x_1509 of
					     i: int32 =>
					     let val j: int32 = (+ (i, 0x1))
					     in
						case (< (j, length)) of
						  true => (sub (cs, j))
						| false => 0x30
					     end)))])
	     val exp: int32 = (- (decpt, 0x1))
	     val exp: string =
		let val (exp: int32, sign: string) =
		       case (< (exp, 0x0)) of
			 true => ((~ exp), "~") | false => (exp, "")
		in
		   (concat_2 [sign, (toString exp)])
		end
	 in
	    (concat_2 [sign, whole, frac, "E", exp])
	 end)
val rec
   gen: real64 * int32 -> string = 
      (fn x_1511: real64 * int32 =>
       case x_1511 of
	 ((x: real64, n: int32)) =>
	 case (class x) of
	   INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	 | NAN => "nan"
	 | _ =>
	   let val (prefix: string, x: real64) =
		  case (< (x, zero)) of
		    true => ("~", (~ x)) | false => ("", x)
	       val ss: char8 Sequence.Slice.t = (full_5 (sci (x, (- (n, 0x1)))))
	       val rec
		  isE: char8 -> bool = 
		     (fn x_1518: char8 =>
		      case x_1518 of
			(c: char8) => (= (char8) (c, 0x45)))
	       val rec
		  isZero: char8 -> bool = 
		     (fn x_1517: char8 =>
		      case x_1517 of
			(c: char8) => (= (char8) (c, 0x30)))
	       val expS: string =
		  (string ((taker_2 (o_1 (char8, bool, bool) (not, isE))) ss))
	       val exp: int32 = (valOf_1 (int32) (fromString expS))
	       val man: string =
		  ((translate_2 (fn x_1516: char8 =>
				 case x_1516 of
				   0x2E => "" | c: char8 => (str c))) (string ((dropr_2 isZero) ((takel_2 (o_1 (char8,
									     bool,
									     bool) (not,
										    isE))) ss))))
	       val manSize: int32 = (size man)
	       val rec
		  zeros: int32 -> string = 
		     (fn x_1514: int32 =>
		      case x_1514 of
			(i: int32) =>
			(tabulate_4 (i,
				     (fn x_1515: int32 =>
				      case x_1515 of
					_ => 0x30))))
	       val rec
		  dotAt: int32 -> string = 
		     (fn x_1513: int32 =>
		      case x_1513 of
			(i: int32) =>
			(concat_2 [(substring (man, 0x0, i)),
				   ".",
				   (extract (man, i, NONE[int32]))]))
	       val rec
		  sci: unit -> string = 
		     (fn x_1512: unit =>
		      case x_1512 of
			(()) =>
			(concat_2 [prefix,
				   case (= (int32) (manSize, 0x1)) of
				     true => man | false => (dotAt 0x1),
				   "E",
				   expS]))
	       val -: int32 * int32 -> int32 = -
	       val +: int32 * int32 -> int32 = +
	       val ~: int32 -> int32 = ~
	       val >=: int32 * int32 -> bool = >=
	   in
	      case (>= (exp,
			case (= (int32) (manSize, 0x1)) of
			  true => 0x3 | false => (+ (manSize, 0x3)))) of
		true => (sci ())
	      | false =>
		case (>= (exp, (- (manSize, 0x1)))) of
		  true =>
		  (concat_2 [prefix, man, (zeros (- (exp, (- (manSize, 0x1)))))])
		| false =>
		  case (>= (exp, 0x0)) of
		    true => (concat_2 [prefix, (dotAt (+ (exp, 0x1)))])
		  | false =>
		    case (>= (exp,
			      case (= (int32) (manSize, 0x1)) of
				true => 0xFFFFFFFE | false => 0xFFFFFFFD)) of
		      true =>
		      (concat_2 [prefix, "0.", (zeros (- ((~ exp), 0x1))), man])
		    | false => (sci ())
	   end)
val rec
   fmt: StringCvt.realfmt -> real64 -> string = 
      (fn x_1519: StringCvt.realfmt =>
       case x_1519 of
	 (spec: StringCvt.realfmt) =>
	 let val doit: real64 -> string =
		case spec of
		  EXACT =>
		  (o_1 (real64,
			string,
			{class: IEEEReal.float_class,
			 digits: int32 list,
			 exp: int32,
			 sign: bool}) (toString, toDecimal))
		| FIX opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1520: real64 =>
		      case x_1520 of
			x: real64 =>
			let val sign: string =
			       case (< (x, zero)) of
				 true => "~" | false => ""
			    val (cs: word64, decpt: int32) =
			       (gdtoa (x, Fix, n, (getRoundingMode ())))
			in
			   (fix (sign, cs, decpt, n))
			end)
		  end
		| GEN opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0xC
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x1)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1521: real64 =>
		      case x_1521 of
			x: real64 => (gen (x, n)))
		  end
		| SCI opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1522: real64 =>
		      case x_1522 of
			x: real64 => (sci (x, n)))
		  end
	 in
	    (fn x_1523: real64 =>
	     case x_1523 of
	       x: real64 =>
	       case (class x) of
		 NAN => "nan"
	       | INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	       | _ => (doit x))
	 end)
val rec 'a
   make: {fromIntUnsafe: 'a -> real64,
	  other: {maxInt': 'a, minInt': 'a, precision': int32},
	  toIntUnsafe: real64 -> 'a}
	 -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
      (fn x_1524: {fromIntUnsafe: 'a -> real64,
		   other: {maxInt': 'a, minInt': 'a, precision': int32},
		   toIntUnsafe: real64 -> 'a} =>
       case x_1524 of
	 ({fromIntUnsafe = fromIntUnsafe: 'a -> real64,
	   toIntUnsafe = toIntUnsafe: real64 -> 'a,
	   other = other: {maxInt': 'a, minInt': 'a, precision': int32}}) =>
	 (fromIntUnsafe,
	  case (< (precision,
		   ((fn x_1534: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1534 of
		       {precision' = #: int32} => #) other))) of
	    true =>
	    let val maxInt': 'a =
		   ((fn x_1527: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1527 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1526: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1526 of
		       {minInt' = #: 'a} => #) other)
		val (maxInt: real64, minInt: real64) =
		   (withRoundingMode_0 (real64 * real64) (TO_ZERO,
							  (fn x_1525: unit =>
							   case x_1525 of
							     () =>
							     ((fromIntUnsafe maxInt'),
							      (fromIntUnsafe minInt')))))
	    in
	       (fn x_1528: IEEEReal.RoundingMode.t =>
		case x_1528 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1529: real64 =>
		   case x_1529 of
		     x: real64 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true => raise Overflow | false => raise Domain))
	    end
	  | false =>
	    let val maxInt': 'a =
		   ((fn x_1531: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1531 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1530: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1530 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real64 = (fromIntUnsafe maxInt')
		val minInt: real64 = (fromIntUnsafe minInt')
	    in
	       (fn x_1532: IEEEReal.RoundingMode.t =>
		case x_1532 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1533: real64 =>
		   case x_1533 of
		     x: real64 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false =>
			 case (< (x, (+ (maxInt, one)))) of
			   true =>
			   case m of
			     TO_NEGINF => maxInt'
			   | TO_POSINF => raise Overflow
			   | TO_ZERO => maxInt'
			   | TO_NEAREST =>
			     case (>= ((- (x, maxInt)), half)) of
			       true => raise Overflow | false => maxInt'
			 | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true =>
			 case (< ((- (minInt, one)), x)) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => minInt'
			   | TO_ZERO => minInt'
			   | TO_NEAREST =>
			     case (< ((- (x, minInt)), (~ half))) of
			       true => raise Overflow | false => minInt'
			 | false => raise Overflow
		       | false => raise Domain))
	    end))
val (fromInt8: int8 -> real64, toInt8: IEEEReal.RoundingMode.t -> real64 -> int8) =
   (make (int8) {fromIntUnsafe = fromInt8Unsafe,
		 toIntUnsafe = toInt8Unsafe,
		 other = {maxInt' = maxInt',
			  minInt' = minInt',
			  precision' = precision'}})
val (fromInt16: int16 -> real64,
     toInt16: IEEEReal.RoundingMode.t -> real64 -> int16) =
   (make (int16) {fromIntUnsafe = fromInt16Unsafe,
		  toIntUnsafe = toInt16Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt32: int32 -> real64,
     toInt32: IEEEReal.RoundingMode.t -> real64 -> int32) =
   (make (int32) {fromIntUnsafe = fromInt32Unsafe,
		  toIntUnsafe = toInt32Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt64: int64 -> real64,
     toInt64: IEEEReal.RoundingMode.t -> real64 -> int64) =
   (make (int64) {fromIntUnsafe = fromInt64Unsafe,
		  toIntUnsafe = toInt64Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val fromIntInf: intInf -> real64 =
   (fn x_1535: intInf =>
    case x_1535 of
      i: intInf =>
      let val str: string =
	     case (< (i, 0)) of
	       true => (^ ("-", (toString (~ i)))) | false => (toString i)
	  val x: real64 = (strto ((nullTerm str), (getRoundingMode ())))
      in
	 x
      end)
val toIntInf: IEEEReal.RoundingMode.t -> real64 -> intInf =
   (fn x_1536: IEEEReal.RoundingMode.t =>
    case x_1536 of
      mode: IEEEReal.RoundingMode.t =>
      (fn x_1537: real64 =>
       case x_1537 of
	 x: real64 =>
	 case (class x) of
	   INF => raise Overflow
	 | NAN => raise Domain
	 | ZERO => 0
	 | _ =>
	   let val x: real64 = (roundReal (x, mode))
	   in
	      case (class x) of
		INF => raise Overflow
	      | _ =>
		(valOf_1 (intInf) (fromString ((fmt (FIX (SOME[int32] 0x0))) x)))
	   end))
val fInt8: int8 -> real64 = fromInt8
val fInt16: int16 -> real64 = fromInt16
val fInt64: int64 -> real64 = fromInt64
val fIntInf: intInf -> real64 = fromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> real64 = fromInt8
val fInt16: int16 -> real64 = fromInt16
val fInt32: int32 -> real64 = fromInt32
val fInt64: int64 -> real64 = fromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: IEEEReal.RoundingMode.t -> real64 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real64 -> int16 = toInt16
val fInt64: IEEEReal.RoundingMode.t -> real64 -> int64 = toInt64
val fIntInf: IEEEReal.RoundingMode.t -> real64 -> intInf = toIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: IEEEReal.RoundingMode.t -> real64 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real64 -> int16 = toInt16
val fInt32: IEEEReal.RoundingMode.t -> real64 -> int32 = toInt32
val fInt64: IEEEReal.RoundingMode.t -> real64 -> int64 = toInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val rec 'a
   make: {fromWordUnsafe: 'a -> real64,
	  other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
	  toWordUnsafe: real64 -> 'a}
	 -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
      (fn x_1538: {fromWordUnsafe: 'a -> real64,
		   other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
		   toWordUnsafe: real64 -> 'a} =>
       case x_1538 of
	 ({fromWordUnsafe = fromWordUnsafe: 'a -> real64,
	   toWordUnsafe = toWordUnsafe: real64 -> 'a,
	   other = other: {maxWord': 'a, wordSize: int32, zeroWord: 'a}}) =>
	 (fromWordUnsafe,
	  case (<= (precision,
		    ((fn x_1548: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		      case x_1548 of
			{wordSize = #: int32} => #) other))) of
	    true =>
	    let val maxWord': 'a =
		   ((fn x_1541: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1541 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real64 =
		   (withRoundingMode_0 (real64) (TO_ZERO,
						 (fn x_1540: unit =>
						  case x_1540 of
						    () =>
						    (fromWordUnsafe maxWord'))))
		val zeroWord: 'a =
		   ((fn x_1539: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1539 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1542: IEEEReal.RoundingMode.t =>
		case x_1542 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1543: real64 =>
		   case x_1543 of
		     x: real64 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end
	  | false =>
	    let val maxWord': 'a =
		   ((fn x_1545: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1545 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real64 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1544: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1544 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1546: IEEEReal.RoundingMode.t =>
		case x_1546 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1547: real64 =>
		   case x_1547 of
		     x: real64 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false =>
			   case (< (x, (+ (maxWord, one)))) of
			     true =>
			     case m of
			       TO_NEGINF => maxWord'
			     | TO_POSINF => raise Overflow
			     | TO_ZERO => maxWord'
			     | TO_NEAREST =>
			       case (>= ((- (x, maxWord)), half)) of
				 true => raise Overflow | false => maxWord'
			   | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end))
val (fromWord8: word8 -> real64,
     toWord8: IEEEReal.RoundingMode.t -> real64 -> word8) =
   (make (word8) {fromWordUnsafe = fromWord8Unsafe,
		  toWordUnsafe = toWord8Unsafe,
		  other = {maxWord' = maxWord',
			   wordSize = wordSize,
			   zeroWord = zero}})
val (fromWord16: word16 -> real64,
     toWord16: IEEEReal.RoundingMode.t -> real64 -> word16) =
   (make (word16) {fromWordUnsafe = fromWord16Unsafe,
		   toWordUnsafe = toWord16Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord32: word32 -> real64,
     toWord32: IEEEReal.RoundingMode.t -> real64 -> word32) =
   (make (word32) {fromWordUnsafe = fromWord32Unsafe,
		   toWordUnsafe = toWord32Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord64: word64 -> real64,
     toWord64: IEEEReal.RoundingMode.t -> real64 -> word64) =
   (make (word64) {fromWordUnsafe = fromWord64Unsafe,
		   toWordUnsafe = toWord64Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val fWord8: word8 -> real64 = fromWord8
val fWord16: word16 -> real64 = fromWord16
val fWord64: word64 -> real64 = fromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> real64 = fromWord8
val fWord16: word16 -> real64 = fromWord16
val fWord32: word32 -> real64 = fromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: IEEEReal.RoundingMode.t -> real64 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real64 -> word16 = toWord16
val fWord64: IEEEReal.RoundingMode.t -> real64 -> word64 = toWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: IEEEReal.RoundingMode.t -> real64 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real64 -> word16 = toWord16
val fWord32: IEEEReal.RoundingMode.t -> real64 -> word32 = toWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val bswap: word32 -> word32 = bswap
val subArrRev: word8 array * int64 -> real32 =
   (o_1 (word8 array * int64, real32, word32) ((o_1 (word32, real32, word32) (castFromWord,
									      bswap)),
					       subArr))
val subVecRev: word8 vector * int64 -> real32 =
   (o_1 (word8 vector * int64, real32, word32) ((o_1 (word32, real32, word32) (castFromWord,
									       bswap)),
						subVec))
val rec
   updateRev: word8 array * int64 * real32 -> unit = 
      (fn x_1549: word8 array * int64 * real32 =>
       case x_1549 of
	 ((a: word8 array, i: int64, r: real32)) =>
	 (update (a, i, (bswap (castToWord r)))))
val subArr: word8 array * int64 -> real32 =
   (o_1 (word8 array * int64, real32, word32) (castFromWord, subArr))
val subVec: word8 vector * int64 -> real32 =
   (o_1 (word8 vector * int64, real32, word32) (castFromWord, subVec))
val update: word8 array * int64 * real32 -> unit =
   (fn x_1550: word8 array * int64 * real32 =>
    case x_1550 of
      (a: word8 array, i: int64, r: real32) => (update (a, i, (castToWord r))))
val fReal32: int32 = realSize
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArr
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVec
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = update
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArrRev
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVecRev
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = updateRev
val _ = fReal32
val fReal32: int32 = realSize
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArr
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVec
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = update
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArrRev
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVecRev
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = updateRev
val _ = fReal32
val ticksPerSecond: intInf = 1000000000
datatype Time.time = T of intInf
exception Time
val rec
   make: intInf -> (intInf -> Time.time) * (Time.time -> intInf) = 
      (fn x_1551: intInf =>
       case x_1551 of
	 (ticksPer: intInf) =>
	 let val d: intInf = (quot (ticksPerSecond, ticksPer))
	 in
	    ((fn x_1553: intInf =>
	      case x_1553 of
		i: intInf => (T (* (i, d)))),
	     (fn x_1552: Time.time =>
	      case x_1552 of
		T i: intInf => (quot (i, d))))
	 end)
val (fromSeconds: intInf -> Time.time, toSeconds: Time.time -> intInf) =
   (make 1)
datatype Date.weekday = Mon
			| Tue
			| Wed
			| Thu
			| Fri
			| Sat
			| Sun
datatype Date.month = Jan
		      | Feb
		      | Mar
		      | Apr
		      | May
		      | Jun
		      | Jul
		      | Aug
		      | Sep
		      | Oct
		      | Nov
		      | Dec
datatype Date.t = T of {day: int32,
			hour: int32,
			isDst: bool Primitive.Option.t,
			minute: int32,
			month: Date.month,
			offset: int32 Primitive.Option.t,
			second: int32,
			weekDay: Date.weekday,
			year: int32,
			yearDay: int32}
exception Date
exception BlockingNotSupported
exception ClosedStream
exception Io of {cause: exn, function: string, name: string}
val _ =
   (addExnMessager (fn x_1554: exn =>
		    case x_1554 of
		      e: exn =>
		      case e of
			Io {cause = cause: exn,
			    function = function: string,
			    name = name: string} =>
			(SOME[string] (concat_2 ["Io: ",
						 function,
						 " "",
						 name,
						 "" failed with ",
						 (exnMessage cause)]))
		      | _ => NONE[string]))
exception NonblockingNotSupported
exception RandomAccessNotSupported
datatype IO.buffer_mode = NO_BUF
			  | LINE_BUF
			  | BLOCK_BUF
datatype PrimIO.reader = RD of {avail: unit -> int32 Primitive.Option.t,
				block: (unit -> unit) Primitive.Option.t,
				canInput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				readArr: (word8 Sequence.Slice.t -> int32) Primitive.Option.t,
				readArrNB: (word8 Sequence.Slice.t
					    -> int32 Primitive.Option.t) Primitive.Option.t,
				readVec: (int32 -> word8 vector) Primitive.Option.t,
				readVecNB: (int32
					    -> word8 vector Primitive.Option.t) Primitive.Option.t,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t}
datatype PrimIO.writer = WR of {block: (unit -> unit) Primitive.Option.t,
				canOutput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t,
				writeArr: (word8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeArrNB: (word8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t,
				writeVec: (word8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeVecNB: (word8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t}
datatype PrimIO.reader = RD of {avail: unit -> int32 Primitive.Option.t,
				block: (unit -> unit) Primitive.Option.t,
				canInput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				readArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
				readArrNB: (char8 Sequence.Slice.t
					    -> int32 Primitive.Option.t) Primitive.Option.t,
				readVec: (int32 -> string) Primitive.Option.t,
				readVecNB: (int32 -> string Primitive.Option.t) Primitive.Option.t,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t}
datatype PrimIO.writer = WR of {block: (unit -> unit) Primitive.Option.t,
				canOutput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t,
				writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeArrNB: (char8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t,
				writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeVecNB: (char8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t}
val rec
   augmentWriter: PrimIO.writer -> PrimIO.writer = 
      (fn x_1555: PrimIO.writer =>
       case x_1555 of
	 (WR {name = name: string,
	      chunkSize = chunkSize: int32,
	      writeVec = writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
	      writeArr = writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
	      writeVecNB = writeVecNB: (char8 Sequence.Slice.t
					-> int32 Primitive.Option.t) Primitive.Option.t,
	      writeArrNB = writeArrNB: (char8 Sequence.Slice.t
					-> int32 Primitive.Option.t) Primitive.Option.t,
	      block = block: (unit -> unit) Primitive.Option.t,
	      canOutput = canOutput: (unit -> bool) Primitive.Option.t,
	      getPos = getPos: (unit -> int64) Primitive.Option.t,
	      setPos = setPos: (int64 -> unit) Primitive.Option.t,
	      endPos = endPos: (unit -> int64) Primitive.Option.t,
	      verifyPos = verifyPos: (unit -> int64) Primitive.Option.t,
	      close = close: unit -> unit,
	      ioDesc = ioDesc: int32 Primitive.Option.t}) =>
	 let val rec 'a_3713
		augmentWrite: (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t
			      * (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t
			      -> (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t
				 * (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t = 
		   (fn x_1559: (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t
			       * (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t =>
		    case x_1559 of
		      ((writeVec: (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t,
			writeArr: (char8 Sequence.Slice.t -> 'a_3713) Primitive.Option.t)) =>
		      case (writeVec, writeArr) of
			(SOME[char8 Sequence.Slice.t -> 'a_3713] writeVec: char8 Sequence.Slice.t
									   -> 'a_3713,
			 SOME[char8 Sequence.Slice.t -> 'a_3713] writeArr: char8 Sequence.Slice.t
									   -> 'a_3713) =>
			((SOME[char8 Sequence.Slice.t -> 'a_3713] writeVec),
			 (SOME[char8 Sequence.Slice.t -> 'a_3713] writeArr))
		      | (NONE[char8 Sequence.Slice.t -> 'a_3713],
			 SOME[char8 Sequence.Slice.t -> 'a_3713] writeArr: char8 Sequence.Slice.t
									   -> 'a_3713) =>
			((SOME[char8 Sequence.Slice.t -> 'a_3713] (fn x_1560: char8 Sequence.Slice.t =>
								   case x_1560 of
								     sl: char8 Sequence.Slice.t =>
								     (writeArr (full_6 (tabulate_5 ((length_10 sl),
												    (fn x_1561: int32 =>
												     case x_1561 of
												       i: int32 =>
												       (sub_7 (sl,
													       i))))))))),
			 (SOME[char8 Sequence.Slice.t -> 'a_3713] writeArr))
		      | (SOME[char8 Sequence.Slice.t -> 'a_3713] writeVec: char8 Sequence.Slice.t
									   -> 'a_3713,
			 NONE[char8 Sequence.Slice.t -> 'a_3713]) =>
			((SOME[char8 Sequence.Slice.t -> 'a_3713] writeVec),
			 (SOME[char8 Sequence.Slice.t -> 'a_3713] (fn x_1562: char8 Sequence.Slice.t =>
								   case x_1562 of
								     sl: char8 Sequence.Slice.t =>
								     (writeVec (full_5 (vector_6 sl))))))
		      | (NONE[char8 Sequence.Slice.t -> 'a_3713],
			 NONE[char8 Sequence.Slice.t -> 'a_3713]) =>
			(NONE[char8 Sequence.Slice.t -> 'a_3713],
			 NONE[char8 Sequence.Slice.t -> 'a_3713]))
	     val rec ('a_3715, 'a_3714)
		augmentSeq: ('a_3715 -> 'a_3714) Primitive.Option.t
			    * ('a_3715 -> 'a_3714 Primitive.Option.t) Primitive.Option.t
			    -> ('a_3715 -> 'a_3714) Primitive.Option.t
			       * ('a_3715 -> 'a_3714 Primitive.Option.t) Primitive.Option.t = 
		   (fn x_1556: ('a_3715 -> 'a_3714) Primitive.Option.t
			       * ('a_3715 -> 'a_3714 Primitive.Option.t) Primitive.Option.t =>
		    case x_1556 of
		      ((writeSeq: ('a_3715 -> 'a_3714) Primitive.Option.t,
			writeSeqNB: ('a_3715 -> 'a_3714 Primitive.Option.t) Primitive.Option.t)) =>
		      case (writeSeq, writeSeqNB) of
			(SOME['a_3715 -> 'a_3714] writeSeq: 'a_3715 -> 'a_3714,
			 SOME['a_3715 -> 'a_3714 Primitive.Option.t] writeSeqNB: 'a_3715
										 -> 'a_3714 Primitive.Option.t) =>
			((SOME['a_3715 -> 'a_3714] writeSeq),
			 (SOME['a_3715 -> 'a_3714 Primitive.Option.t] writeSeqNB))
		      | (NONE['a_3715 -> 'a_3714],
			 SOME['a_3715 -> 'a_3714 Primitive.Option.t] writeSeqNB: 'a_3715
										 -> 'a_3714 Primitive.Option.t) =>
			(case block of
			   NONE[unit -> unit] => NONE['a_3715 -> 'a_3714]
			 | SOME[unit -> unit] block: unit -> unit =>
			   (SOME['a_3715 -> 'a_3714] (fn x_1557: 'a_3715 =>
						      case x_1557 of
							x: 'a_3715 =>
							(block ())
							;(valOf_1 ('a_3714) (writeSeqNB x)))),
			 (SOME['a_3715 -> 'a_3714 Primitive.Option.t] writeSeqNB))
		      | (SOME['a_3715 -> 'a_3714] writeSeq: 'a_3715 -> 'a_3714,
			 NONE['a_3715 -> 'a_3714 Primitive.Option.t]) =>
			((SOME['a_3715 -> 'a_3714] writeSeq),
			 case canOutput of
			   NONE[unit -> bool] =>
			   NONE['a_3715 -> 'a_3714 Primitive.Option.t]
			 | SOME[unit -> bool] canOutput: unit -> bool =>
			   (SOME['a_3715 -> 'a_3714 Primitive.Option.t] (fn x_1558: 'a_3715 =>
									 case x_1558 of
									   x: 'a_3715 =>
									   case (canOutput ()) of
									     true =>
									     (SOME['a_3714] (writeSeq x))
									   | false =>
									     NONE['a_3714])))
		      | (NONE['a_3715 -> 'a_3714],
			 NONE['a_3715 -> 'a_3714 Primitive.Option.t]) =>
			(NONE['a_3715 -> 'a_3714],
			 NONE['a_3715 -> 'a_3714 Primitive.Option.t]))
	     val ((writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		   writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t),
		  (writeVecNB: (char8 Sequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t,
		   writeArrNB: (char8 Sequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t)) =
		((augmentWrite (int32) (writeVec, writeArr)),
		 (augmentWrite (int32 Primitive.Option.t) (writeVecNB,
							   writeArrNB)))
	     val ((writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		   writeVecNB: (char8 Sequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t),
		  (writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		   writeArrNB: (char8 Sequence.Slice.t
				-> int32 Primitive.Option.t) Primitive.Option.t)) =
		((augmentSeq (char8 Sequence.Slice.t, int32) (writeVec,
							      writeVecNB)),
		 (augmentSeq (char8 Sequence.Slice.t, int32) (writeArr,
							      writeArrNB)))
	 in
	    (WR {name = name,
		 chunkSize = chunkSize,
		 writeVec = writeVec,
		 writeArr = writeArr,
		 writeVecNB = writeVecNB,
		 writeArrNB = writeArrNB,
		 block = block,
		 canOutput = canOutput,
		 getPos = getPos,
		 setPos = setPos,
		 endPos = endPos,
		 verifyPos = verifyPos,
		 close = close,
		 ioDesc = ioDesc})
	 end)
val ('b, 'a) stub: string * ('a -> 'b) -> 'a -> 'b =
   (fn x_1563: string * ('a -> 'b) =>
    case x_1563 of
      (msg: string, f: 'a -> 'b) =>
      case let 
	   in
	      (= (Primitive.MLton.Platform.OS.t) (MinGW, host))
	   end of
	true =>
	(fn x_1564: 'a =>
	 case x_1564 of
	   _ =>
	   case true of
	     true => () | false => (print msg) ;(print "
")
	   ;(raiseSysWithMsg_0 ('b) (nosys, msg)))
      | false => f)
val fcntl3: int32 * int32 * int32 -> int32 =
   (stub (int32, int32 * int32 * int32) ("fcntl3", fcntl3))
val rec
   isatty: int32 -> bool = 
      (fn x_1565: int32 =>
       case x_1565 of
	 (fd: int32) => (<> (int32) ((isatty (toRep fd)), zero)))
val fromSeconds: int64 -> Time.time =
   (o_1 (int64, Time.time, intInf) (fromSeconds, toLargeInt))
val fdToIOD: int32 -> int32 = (o_1 (int32, int32, int32) (fromRep, toRep))
datatype PosixFileSys.dirstream = DS of word64 Primitive.Option.t ref
val stdout: int32 = (fromRep 0x1)
val empty: int32 = (castFromSysWord 0x0)
val flags: int32 list -> int32 = ((foldl_0 (int32, int32) orb) empty)
val append: int32 = APPEND
val nonblock: int32 = NONBLOCK
datatype PosixFileSys.open_mode = O_RDONLY
				  | O_WRONLY
				  | O_RDWR
datatype PosixFileSys.ST.stat = T of {atime: Time.time,
				      ctime: Time.time,
				      dev: int32,
				      gid: word32,
				      ino: word64,
				      mode: word16,
				      mtime: Time.time,
				      nlink: int32,
				      size: int64,
				      uid: word32}
val rec
   fromC: unit -> PosixFileSys.ST.stat = 
      (fn x_1566: unit =>
       case x_1566 of
	 (()) =>
	 (T {dev = (getDev ()),
	     ino = (getINo ()),
	     mode = (getMode ()),
	     nlink = (toInt (getNLink ())),
	     uid = (fromRep (getUId ())),
	     gid = (fromRep (getGId ())),
	     size = (getSize ()),
	     atime = (fromSeconds (getATime ())),
	     mtime = (fromSeconds (getMTime ())),
	     ctime = (fromSeconds (getCTime ()))}))
val rec 'a_3721
   make: ({atime: Time.time,
	   ctime: Time.time,
	   dev: int32,
	   gid: word32,
	   ino: word64,
	   mode: word16,
	   mtime: Time.time,
	   nlink: int32,
	   size: int64,
	   uid: word32}
	  -> 'a_3721)
	 -> PosixFileSys.ST.stat -> 'a_3721 = 
      (fn x_1567: {atime: Time.time,
		   ctime: Time.time,
		   dev: int32,
		   gid: word32,
		   ino: word64,
		   mode: word16,
		   mtime: Time.time,
		   nlink: int32,
		   size: int64,
		   uid: word32}
		  -> 'a_3721 =>
       (fn x_1568: PosixFileSys.ST.stat =>
	case (x_1567, x_1568) of
	  (sel: {atime: Time.time,
		 ctime: Time.time,
		 dev: int32,
		 gid: word32,
		 ino: word64,
		 mode: word16,
		 mtime: Time.time,
		 nlink: int32,
		 size: int64,
		 uid: word32}
		-> 'a_3721,
	   T r: {atime: Time.time,
		 ctime: Time.time,
		 dev: int32,
		 gid: word32,
		 ino: word64,
		 mode: word16,
		 mtime: Time.time,
		 nlink: int32,
		 size: int64,
		 uid: word32}) =>
	  (sel r)))
val mode: PosixFileSys.ST.stat -> word16 =
   (make (word16) (fn x_1569: {atime: Time.time,
			       ctime: Time.time,
			       dev: int32,
			       gid: word32,
			       ino: word64,
			       mode: word16,
			       mtime: Time.time,
			       nlink: int32,
			       size: int64,
			       uid: word32} =>
		   case x_1569 of
		     {mode = #: word16} => #))
val size: PosixFileSys.ST.stat -> int64 =
   (make (int64) (fn x_1570: {atime: Time.time,
			      ctime: Time.time,
			      dev: int32,
			      gid: word32,
			      ino: word64,
			      mode: word16,
			      mtime: Time.time,
			      nlink: int32,
			      size: int64,
			      uid: word32} =>
		  case x_1570 of
		    {size = #: int64} => #))
val rec
   make: (word16 -> int32) -> PosixFileSys.ST.stat -> bool = 
      (fn x_1571: word16 -> int32 =>
       (fn x_1572: PosixFileSys.ST.stat =>
	case (x_1571, x_1572) of
	  (prim: word16 -> int32, s: PosixFileSys.ST.stat) =>
	  (<> (int32) ((prim (mode s)), zero))))
val isReg: PosixFileSys.ST.stat -> bool = (make isReg)
val rec 'a_3722
   make: ('a_3722 -> int32) -> 'a_3722 -> PosixFileSys.ST.stat = 
      (fn x_1573: 'a_3722 -> int32 =>
       (fn x_1574: 'a_3722 =>
	case (x_1573, x_1574) of
	  (prim: 'a_3722 -> int32, arg: 'a_3722) =>
	  (syscall_0 (PosixFileSys.ST.stat) (fn x_1575: unit =>
					     case x_1575 of
					       () =>
					       ((prim arg),
						(fn x_1576: int32 =>
						 case x_1576 of
						   _ => (fromC ())))))))
val fstat: int32 -> PosixFileSys.ST.stat =
   (o_1 (int32, PosixFileSys.ST.stat, int32) ((make (int32) fstat), toRep))
datatype PosixFileSys.access_mode = A_READ
				    | A_WRITE
				    | A_EXEC
val rec
   close: int32 -> unit = 
      (fn x_1577: int32 =>
       case x_1577 of
	 (fd: int32) =>
	 (simpleRestart (fn x_1578: unit =>
			 case x_1578 of
			   () => (close (toRep fd)))))
val rec
   setfl: int32 * int32 -> unit = 
      (fn x_1579: int32 * int32 =>
       case x_1579 of
	 ((fd: int32, flags: int32)) =>
	 (simpleRestart (fn x_1580: unit =>
			 case x_1580 of
			   () => (fcntl3 ((toRep fd), F_SETFL, flags)))))
datatype PosixIO.whence = SEEK_SET
			  | SEEK_CUR
			  | SEEK_END
val whenceToInt: PosixIO.whence -> int32 =
   (fn x_1581: PosixIO.whence =>
    case x_1581 of
      SEEK_SET => SEEK_SET | SEEK_CUR => SEEK_CUR | SEEK_END => SEEK_END)
val rec
   lseek: int32 * int64 * PosixIO.whence -> int64 = 
      (fn x_1582: int32 * int64 * PosixIO.whence =>
       case x_1582 of
	 ((fd: int32, n: int64, w: PosixIO.whence)) =>
	 (simpleResult'_0 (int64) ({errVal = (fromInt 0xFFFFFFFF)},
				   (fn x_1583: unit =>
				    case x_1583 of
				      () =>
				      (lseek ((toRep fd), n, (whenceToInt w)))))))
datatype PosixIO.lock_type = F_RDLCK
			     | F_WRLCK
			     | F_UNLCK
val pos0: int64 = (fromInt 0x0)
val rec
   isReg: int32 -> bool = 
      (fn x_1584: int32 =>
       case x_1584 of
	 (fd: int32) => (isReg (fstat fd)))
val rec
   posFns: bool ref * int32
	   -> {endPos: (unit -> int64) Primitive.Option.t,
	       getPos: (unit -> int64) Primitive.Option.t,
	       pos: int64 ref,
	       setPos: (int64 -> unit) Primitive.Option.t,
	       verifyPos: (unit -> int64) Primitive.Option.t} = 
      (fn x_1585: bool ref * int32 =>
       case x_1585 of
	 ((closed: bool ref, fd: int32)) =>
	 case (isReg fd) of
	   true =>
	   let val pos: int64 ref = (ref[int64] pos0)
	       val rec
		  getPos: unit -> int64 = 
		     (fn x_1589: unit =>
		      case x_1589 of
			(()) => (!_1 (int64) pos))
	       val rec
		  setPos: int64 -> unit = 
		     (fn x_1588: int64 =>
		      case x_1588 of
			(p: int64) =>
			case (!_1 (bool) closed) of
			  true => raise ClosedStream | false => ()
			;(:=_1 (int64) (pos, (lseek (fd, p, SEEK_SET)))))
	       val rec
		  endPos: unit -> int64 = 
		     (fn x_1587: unit =>
		      case x_1587 of
			(()) =>
			case (!_1 (bool) closed) of
			  true => raise ClosedStream | false => ()
			;(size (fstat fd)))
	       val rec
		  verifyPos: unit -> int64 = 
		     (fn x_1586: unit =>
		      case x_1586 of
			(()) =>
			let val curPos: int64 = (lseek (fd, pos0, SEEK_CUR))
			in
			   (:=_1 (int64) (pos, curPos)) ;curPos
			end)
	       val _ = (verifyPos ())
	   in
	      {pos = pos,
	       getPos = (SOME[unit -> int64] getPos),
	       setPos = (SOME[int64 -> unit] setPos),
	       endPos = (SOME[unit -> int64] endPos),
	       verifyPos = (SOME[unit -> int64] verifyPos)}
	   end
	 | false =>
	   {pos = (ref[int64] pos0),
	    getPos = NONE[unit -> int64],
	    setPos = NONE[int64 -> unit],
	    endPos = NONE[unit -> int64],
	    verifyPos = NONE[unit -> int64]})
val rec ('a_3747,
	 'a_3746,
	 'a_3745,
	 'a_3744,
	 'a_3743,
	 'a_3742,
	 'a_3741,
	 'a_3740,
	 'a_3739,
	 'a_3738,
	 'a_3737,
	 'a_3736,
	 'a_3735,
	 'a_3734)
   make: {RD: {avail: unit -> int32 Primitive.Option.t,
	       block: 'a_3743 Primitive.Option.t,
	       canInput: 'a_3744 Primitive.Option.t,
	       chunkSize: int32,
	       close: unit -> unit,
	       endPos: (unit -> int64) Primitive.Option.t,
	       getPos: (unit -> int64) Primitive.Option.t,
	       ioDesc: int32 Primitive.Option.t,
	       name: 'a_3741,
	       readArr: ('a_3738 -> int32) Primitive.Option.t,
	       readArrNB: ('a_3738 -> int32 Primitive.Option.t) Primitive.Option.t,
	       readVec: (int32 -> 'a_3742) Primitive.Option.t,
	       readVecNB: (int32 -> 'a_3742 Primitive.Option.t) Primitive.Option.t,
	       setPos: (int64 -> unit) Primitive.Option.t,
	       verifyPos: (unit -> int64) Primitive.Option.t}
	      -> 'a_3745,
	  WR: {block: 'a_3736 Primitive.Option.t,
	       canOutput: 'a_3737 Primitive.Option.t,
	       chunkSize: 'a_3735,
	       close: unit -> unit,
	       endPos: (unit -> int64) Primitive.Option.t,
	       getPos: (unit -> int64) Primitive.Option.t,
	       ioDesc: int32 Primitive.Option.t,
	       name: 'a_3734,
	       setPos: (int64 -> unit) Primitive.Option.t,
	       verifyPos: (unit -> int64) Primitive.Option.t,
	       writeArr: ('a_3738 -> int32) Primitive.Option.t,
	       writeArrNB: ('a_3738 -> int32 Primitive.Option.t) Primitive.Option.t,
	       writeVec: ('a_3739 -> int32) Primitive.Option.t,
	       writeVecNB: ('a_3739 -> int32 Primitive.Option.t) Primitive.Option.t}
	      -> 'a_3740,
	  fromVector: 'a_3747 vector -> 'a_3742,
	  readArr: int32 * 'a_3747 array * int32 * word64 -> int64,
	  setMode: int32 -> unit,
	  toArraySlice: 'a_3738 -> 'a_3747 Sequence.Slice.t,
	  toVectorSlice: 'a_3739 -> 'a_3746 Sequence.Slice.t,
	  vectorLength: 'a_3742 -> int32,
	  writeArr: int32 * 'a_3747 array * int32 * word64 -> int64,
	  writeVec: int32 * 'a_3746 vector * int32 * word64 -> int64}
	 -> {mkReader: {fd: int32, initBlkMode: bool, name: 'a_3741} -> 'a_3745,
	     mkWriter: {appendMode: bool,
			chunkSize: 'a_3735,
			fd: int32,
			initBlkMode: bool,
			name: 'a_3734}
		       -> 'a_3740,
	     readArr: int32 * 'a_3738 -> int32,
	     readVec: int32 * int32 -> 'a_3742,
	     writeArr: int32 * 'a_3738 -> int32,
	     writeVec: int32 * 'a_3739 -> int32} = 
      (fn x_1590: {RD: {avail: unit -> int32 Primitive.Option.t,
			block: 'a_3743 Primitive.Option.t,
			canInput: 'a_3744 Primitive.Option.t,
			chunkSize: int32,
			close: unit -> unit,
			endPos: (unit -> int64) Primitive.Option.t,
			getPos: (unit -> int64) Primitive.Option.t,
			ioDesc: int32 Primitive.Option.t,
			name: 'a_3741,
			readArr: ('a_3738 -> int32) Primitive.Option.t,
			readArrNB: ('a_3738 -> int32 Primitive.Option.t) Primitive.Option.t,
			readVec: (int32 -> 'a_3742) Primitive.Option.t,
			readVecNB: (int32 -> 'a_3742 Primitive.Option.t) Primitive.Option.t,
			setPos: (int64 -> unit) Primitive.Option.t,
			verifyPos: (unit -> int64) Primitive.Option.t}
		       -> 'a_3745,
		   WR: {block: 'a_3736 Primitive.Option.t,
			canOutput: 'a_3737 Primitive.Option.t,
			chunkSize: 'a_3735,
			close: unit -> unit,
			endPos: (unit -> int64) Primitive.Option.t,
			getPos: (unit -> int64) Primitive.Option.t,
			ioDesc: int32 Primitive.Option.t,
			name: 'a_3734,
			setPos: (int64 -> unit) Primitive.Option.t,
			verifyPos: (unit -> int64) Primitive.Option.t,
			writeArr: ('a_3738 -> int32) Primitive.Option.t,
			writeArrNB: ('a_3738 -> int32 Primitive.Option.t) Primitive.Option.t,
			writeVec: ('a_3739 -> int32) Primitive.Option.t,
			writeVecNB: ('a_3739 -> int32 Primitive.Option.t) Primitive.Option.t}
		       -> 'a_3740,
		   fromVector: 'a_3747 vector -> 'a_3742,
		   readArr: int32 * 'a_3747 array * int32 * word64 -> int64,
		   setMode: int32 -> unit,
		   toArraySlice: 'a_3738 -> 'a_3747 Sequence.Slice.t,
		   toVectorSlice: 'a_3739 -> 'a_3746 Sequence.Slice.t,
		   vectorLength: 'a_3742 -> int32,
		   writeArr: int32 * 'a_3747 array * int32 * word64 -> int64,
		   writeVec: int32 * 'a_3746 vector * int32 * word64 -> int64} =>
       case x_1590 of
	 ({RD = RD: {avail: unit -> int32 Primitive.Option.t,
		     block: 'a_3743 Primitive.Option.t,
		     canInput: 'a_3744 Primitive.Option.t,
		     chunkSize: int32,
		     close: unit -> unit,
		     endPos: (unit -> int64) Primitive.Option.t,
		     getPos: (unit -> int64) Primitive.Option.t,
		     ioDesc: int32 Primitive.Option.t,
		     name: 'a_3741,
		     readArr: ('a_3738 -> int32) Primitive.Option.t,
		     readArrNB: ('a_3738 -> int32 Primitive.Option.t) Primitive.Option.t,
		     readVec: (int32 -> 'a_3742) Primitive.Option.t,
		     readVecNB: (int32 -> 'a_3742 Primitive.Option.t) Primitive.Option.t,
		     setPos: (int64 -> unit) Primitive.Option.t,
		     verifyPos: (unit -> int64) Primitive.Option.t}
		    -> 'a_3745,
	   WR = WR: {block: 'a_3736 Primitive.Option.t,
		     canOutput: 'a_3737 Primitive.Option.t,
		     chunkSize: 'a_3735,
		     close: unit -> unit,
		     endPos: (unit -> int64) Primitive.Option.t,
		     getPos: (unit -> int64) Primitive.Option.t,
		     ioDesc: int32 Primitive.Option.t,
		     name: 'a_3734,
		     setPos: (int64 -> unit) Primitive.Option.t,
		     verifyPos: (unit -> int64) Primitive.Option.t,
		     writeArr: ('a_3738 -> int32) Primitive.Option.t,
		     writeArrNB: ('a_3738 -> int32 Primitive.Option.t) Primitive.Option.t,
		     writeVec: ('a_3739 -> int32) Primitive.Option.t,
		     writeVecNB: ('a_3739 -> int32 Primitive.Option.t) Primitive.Option.t}
		    -> 'a_3740,
	   fromVector = fromVector: 'a_3747 vector -> 'a_3742,
	   readArr = readArr: int32 * 'a_3747 array * int32 * word64 -> int64,
	   setMode = setMode: int32 -> unit,
	   toArraySlice = toArraySlice: 'a_3738 -> 'a_3747 Sequence.Slice.t,
	   toVectorSlice = toVectorSlice: 'a_3739 -> 'a_3746 Sequence.Slice.t,
	   vectorLength = vectorLength: 'a_3742 -> int32,
	   writeArr = writeArr: int32 * 'a_3747 array * int32 * word64 -> int64,
	   writeVec = writeVec: int32 * 'a_3746 vector * int32 * word64 -> int64}) =>
	 let val primReadArr: int32 * 'a_3747 array * int32 * int32 -> int64 =
		(fn x_1630: int32 * 'a_3747 array * int32 * int32 =>
		 case x_1630 of
		   (fd: int32, buf: 'a_3747 array, i: int32, sz: int32) =>
		   (readArr ((toRep fd), buf, (fromInt i), (fromInt sz))))
	     val primWriteArr: int32 * 'a_3747 array * int32 * int32 -> int64 =
		(fn x_1629: int32 * 'a_3747 array * int32 * int32 =>
		 case x_1629 of
		   (fd: int32, buf: 'a_3747 array, i: int32, sz: int32) =>
		   (writeArr ((toRep fd), buf, (fromInt i), (fromInt sz))))
	     val primWriteVec: int32 * 'a_3746 vector * int32 * int32 -> int64 =
		(fn x_1628: int32 * 'a_3746 vector * int32 * int32 =>
		 case x_1628 of
		   (fd: int32, buf: 'a_3746 vector, i: int32, sz: int32) =>
		   (writeVec ((toRep fd), buf, (fromInt i), (fromInt sz))))
	     val setMode: int32 -> unit =
		(fn x_1627: int32 =>
		 case x_1627 of
		   fd: int32 =>
		   case let 
			in
			   case host of
			     MinGW => true | _ => false
			end of
		     true => (setMode (toRep fd)) | false => ())
	     val rec
		readArr: int32 * 'a_3738 -> int32 = 
		   (fn x_1625: int32 * 'a_3738 =>
		    case x_1625 of
		      ((fd: int32, sl: 'a_3738)) =>
		      let val (buf: 'a_3747 array, i: int32, sz: int32) =
			     (base_5 ('a_3747) (toArraySlice sl))
			  val bytesRead: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1626: unit =>
							       case x_1626 of
								 () =>
								 (primReadArr (fd,
									       buf,
									       i,
									       sz)))))
			  val bytesRead: int32 = (toInt bytesRead)
		      in
			 bytesRead
		      end)
	     val rec
		readVec: int32 * int32 -> 'a_3742 = 
		   (fn x_1623: int32 * int32 =>
		    case x_1623 of
		      ((fd: int32, n: int32)) =>
		      let val buf: 'a_3747 array = (arrayUninit_0 ('a_3747) n)
			  val bytesRead: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1624: unit =>
							       case x_1624 of
								 () =>
								 (primReadArr (fd,
									       buf,
									       0x0,
									       n)))))
			  val bytesRead: int32 = (toInt bytesRead)
		      in
			 (fromVector case (= (int32) (n, bytesRead)) of
				       true => (unsafeFromArray_0 ('a_3747) buf)
				     | false =>
				       (vector_3 ('a_3747) (slice_4 ('a_3747) (buf,
									       0x0,
									       (SOME[int32] bytesRead)))))
		      end)
	     val rec
		writeArr: int32 * 'a_3738 -> int32 = 
		   (fn x_1621: int32 * 'a_3738 =>
		    case x_1621 of
		      ((fd: int32, sl: 'a_3738)) =>
		      let val (buf: 'a_3747 array, i: int32, sz: int32) =
			     (base_5 ('a_3747) (toArraySlice sl))
			  val bytesWrote: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1622: unit =>
							       case x_1622 of
								 () =>
								 (primWriteArr (fd,
										buf,
										i,
										sz)))))
			  val bytesWrote: int32 = (toInt bytesWrote)
		      in
			 bytesWrote
		      end)
	     val rec
		writeVec: int32 * 'a_3739 -> int32 = 
		   (fn x_1619: int32 * 'a_3739 =>
		    case x_1619 of
		      ((fd: int32, sl: 'a_3739)) =>
		      let val (buf: 'a_3746 vector, i: int32, sz: int32) =
			     (base_2 ('a_3746) (toVectorSlice sl))
			  val bytesWrote: int64 =
			     (simpleResultRestart'_0 (int64) ({errVal = (castFromFixedInt 0xFFFFFFFFFFFFFFFF)},
							      (fn x_1620: unit =>
							       case x_1620 of
								 () =>
								 (primWriteVec (fd,
										buf,
										i,
										sz)))))
			  val bytesWrote: int32 = (toInt bytesWrote)
		      in
			 bytesWrote
		      end)
	     val rec
		mkReader: {fd: int32, initBlkMode: bool, name: 'a_3741}
			  -> 'a_3745 = 
		   (fn x_1604: {fd: int32, initBlkMode: bool, name: 'a_3741} =>
		    case x_1604 of
		      ({fd = fd: int32,
			name = name: 'a_3741,
			initBlkMode = initBlkMode: bool}) =>
		      let val closed: bool ref = (ref[bool] false)
			  val {pos = pos: int64 ref,
			       getPos = getPos: (unit -> int64) Primitive.Option.t,
			       setPos = setPos: (int64 -> unit) Primitive.Option.t,
			       endPos = endPos: (unit -> int64) Primitive.Option.t,
			       verifyPos = verifyPos: (unit -> int64) Primitive.Option.t} =
			     (posFns (closed, fd))
			  val blocking: bool ref = (ref[bool] initBlkMode)
			  val rec
			     blockingOn: unit -> unit = 
				(fn x_1618: unit =>
				 case x_1618 of
				   (()) =>
				   (setfl (fd, (flags [])))
				   ;(:=_1 (bool) (blocking, true)))
			  val rec
			     blockingOff: unit -> unit = 
				(fn x_1617: unit =>
				 case x_1617 of
				   (()) =>
				   (setfl (fd, nonblock))
				   ;(:=_1 (bool) (blocking, false)))
			  val rec
			     ensureOpen: unit -> unit = 
				(fn x_1616: unit =>
				 case x_1616 of
				   (()) =>
				   case (!_1 (bool) closed) of
				     true => raise ClosedStream | false => ())
			  val rec
			     incPos: int32 -> unit = 
				(fn x_1615: int32 =>
				 case x_1615 of
				   (k: int32) =>
				   (:=_1 (int64) (pos,
						  (+ ((!_1 (int64) pos),
						      (fromInt k))))))
			  val readVec: int32 -> 'a_3742 =
			     (fn x_1614: int32 =>
			      case x_1614 of
				n: int32 =>
				let val v: 'a_3742 = (readVec (fd, n))
				in
				   (incPos (vectorLength v)) ;v
				end)
			  val readArr: 'a_3738 -> int32 =
			     (fn x_1613: 'a_3738 =>
			      case x_1613 of
				x: 'a_3738 =>
				let val k: int32 = (readArr (fd, x))
				in
				   (incPos k) ;k
				end)
			  val rec ('a_3727, 'a_3726)
			     blockWrap: ('a_3726 -> 'a_3727)
					-> 'a_3726 -> 'a_3727 = 
				(fn x_1611: 'a_3726 -> 'a_3727 =>
				 (fn x_1612: 'a_3726 =>
				  case (x_1611, x_1612) of
				    (f: 'a_3726 -> 'a_3727, x: 'a_3726) =>
				    (ensureOpen ())
				    ;case (!_1 (bool) blocking) of
				       true => () | false => (blockingOn ())
				    ;(f x)))
			  val rec ('a_3729, 'a_3728)
			     noBlockWrap: ('a_3728 -> 'a_3729)
					  -> 'a_3728
					     -> 'a_3729 Primitive.Option.t = 
				(fn x_1608: 'a_3728 -> 'a_3729 =>
				 (fn x_1609: 'a_3728 =>
				  case (x_1608, x_1609) of
				    (f: 'a_3728 -> 'a_3729, x: 'a_3728) =>
				    (ensureOpen ())
				    ;case (!_1 (bool) blocking) of
				       true => (blockingOff ()) | false => ()
				    ;(SOME['a_3729] (f x))
				     handle x_1610 => case x_1610 of
							e: exn as SysErr (_,
									  SOME[int32] cause: int32) =>
							case (= (int32) (cause,
									 again)) of
							  true => NONE['a_3729]
							| false => raise e))
			  val close: unit -> unit =
			     (fn x_1607: unit =>
			      case x_1607 of
				() =>
				case (!_1 (bool) closed) of
				  true => ()
				| false =>
				  (:=_1 (bool) (closed, true)) ;(close fd))
			  val avail: unit -> int32 Primitive.Option.t =
			     case (isReg fd) of
			       true =>
			       (fn x_1605: unit =>
				case x_1605 of
				  () =>
				  case (!_1 (bool) closed) of
				    true => (SOME[int32] 0x0)
				  | false =>
				    (SOME[int32] (toInt (- ((size (fstat fd)),
							    (!_1 (int64) pos))))))
			     | false =>
			       (fn x_1606: unit =>
				case x_1606 of
				  () =>
				  case (!_1 (bool) closed) of
				    true => (SOME[int32] 0x0)
				  | false => NONE[int32])
			  val () = (setMode fd)
		      in
			 (RD {avail = avail,
			      block = NONE['a_3743],
			      canInput = NONE['a_3744],
			      chunkSize = (toInt bufSize),
			      close = close,
			      endPos = endPos,
			      getPos = getPos,
			      ioDesc = (SOME[int32] (fdToIOD fd)),
			      name = name,
			      readArr = (SOME['a_3738 -> int32] (blockWrap (int32,
									    'a_3738) readArr)),
			      readArrNB = (SOME['a_3738
						-> int32 Primitive.Option.t] (noBlockWrap (int32,
											   'a_3738) readArr)),
			      readVec = (SOME[int32 -> 'a_3742] (blockWrap ('a_3742,
									    int32) readVec)),
			      readVecNB = (SOME[int32
						-> 'a_3742 Primitive.Option.t] (noBlockWrap ('a_3742,
											     int32) readVec)),
			      setPos = setPos,
			      verifyPos = verifyPos})
		      end)
	     val rec
		mkWriter: {appendMode: bool,
			   chunkSize: 'a_3735,
			   fd: int32,
			   initBlkMode: bool,
			   name: 'a_3734}
			  -> 'a_3740 = 
		   (fn x_1591: {appendMode: bool,
				chunkSize: 'a_3735,
				fd: int32,
				initBlkMode: bool,
				name: 'a_3734} =>
		    case x_1591 of
		      ({fd = fd: int32,
			name = name: 'a_3734,
			initBlkMode = initBlkMode: bool,
			appendMode = appendMode: bool,
			chunkSize = chunkSize: 'a_3735}) =>
		      let val closed: bool ref = (ref[bool] false)
			  val {pos = pos: int64 ref,
			       getPos = getPos: (unit -> int64) Primitive.Option.t,
			       setPos = setPos: (int64 -> unit) Primitive.Option.t,
			       endPos = endPos: (unit -> int64) Primitive.Option.t,
			       verifyPos = verifyPos: (unit -> int64) Primitive.Option.t} =
			     (posFns (closed, fd))
			  val rec
			     incPos: int32 -> int32 = 
				(fn x_1603: int32 =>
				 case x_1603 of
				   (k: int32) =>
				   (:=_1 (int64) (pos,
						  (+ ((!_1 (int64) pos),
						      (fromInt k)))))
				   ;k)
			  val blocking: bool ref = (ref[bool] initBlkMode)
			  val appendFlgs: int32 =
			     (flags case appendMode of
				      true => [append] | false => [])
			  val rec
			     updateStatus: unit -> unit = 
				(fn x_1602: unit =>
				 case x_1602 of
				   (()) =>
				   let val flgs: int32 =
					  case (!_1 (bool) blocking) of
					    true => appendFlgs
					  | false =>
					    (flags [nonblock, appendFlgs])
				   in
				      (setfl (fd, flgs))
				   end)
			  val rec
			     ensureOpen: unit -> unit = 
				(fn x_1601: unit =>
				 case x_1601 of
				   (()) =>
				   case (!_1 (bool) closed) of
				     true => raise ClosedStream | false => ())
			  val rec
			     ensureBlock: bool -> unit = 
				(fn x_1600: bool =>
				 case x_1600 of
				   (x: bool) =>
				   case (!_1 (bool) blocking) of
				     true => ()
				   | false =>
				     (:=_1 (bool) (blocking, x))
				     ;(updateStatus ()))
			  val rec
			     putV: int32 * 'a_3739 -> int32 = 
				(fn x_1599: int32 * 'a_3739 =>
				 case x_1599 of
				   (x: int32 * 'a_3739) => (incPos (writeVec x)))
			  val rec
			     putA: int32 * 'a_3738 -> int32 = 
				(fn x_1598: int32 * 'a_3738 =>
				 case x_1598 of
				   (x: int32 * 'a_3738) => (incPos (writeArr x)))
			  val rec ('a_3731, 'a_3730)
			     write: (int32 * 'a_3730 -> 'a_3731) * bool
				    -> 'a_3730 -> 'a_3731 = 
				(fn x_1596: (int32 * 'a_3730 -> 'a_3731) * bool =>
				 (fn x_1597: 'a_3730 =>
				  case (x_1596, x_1597) of
				    ((put: int32 * 'a_3730 -> 'a_3731,
				      block: bool),
				     arg: 'a_3730) =>
				    (ensureOpen ())
				    ;(ensureBlock block)
				    ;(put (fd, arg))))
			  val rec ('a_3733, 'a_3732)
			     handleBlock: ('a_3732 -> 'a_3733)
					  -> 'a_3732
					     -> 'a_3733 Primitive.Option.t = 
				(fn x_1593: 'a_3732 -> 'a_3733 =>
				 (fn x_1594: 'a_3732 =>
				  case (x_1593, x_1594) of
				    (writer: 'a_3732 -> 'a_3733, arg: 'a_3732) =>
				    (SOME['a_3733] (writer arg))
				    handle x_1595 => case x_1595 of
						       e: exn as SysErr (_,
									 SOME[int32] cause: int32) =>
						       case (= (int32) (cause,
									again)) of
							 true => NONE['a_3733]
						       | false => raise e))
			  val close: unit -> unit =
			     (fn x_1592: unit =>
			      case x_1592 of
				() =>
				case (!_1 (bool) closed) of
				  true => ()
				| false =>
				  (:=_1 (bool) (closed, true)) ;(close fd))
			  val () = (setMode fd)
		      in
			 (WR {block = NONE['a_3736],
			      canOutput = NONE['a_3737],
			      chunkSize = chunkSize,
			      close = close,
			      endPos = endPos,
			      getPos = getPos,
			      ioDesc = (SOME[int32] (fdToIOD fd)),
			      name = name,
			      setPos = setPos,
			      verifyPos = verifyPos,
			      writeArr = (SOME['a_3738 -> int32] (write (int32,
									 'a_3738) (putA,
										   true))),
			      writeArrNB = (SOME['a_3738
						 -> int32 Primitive.Option.t] (handleBlock (int32,
											    'a_3738) (write (int32,
													     'a_3738) (putA,
														       false)))),
			      writeVec = (SOME['a_3739 -> int32] (write (int32,
									 'a_3739) (putV,
										   true))),
			      writeVecNB = (SOME['a_3739
						 -> int32 Primitive.Option.t] (handleBlock (int32,
											    'a_3739) (write (int32,
													     'a_3739) (putV,
														       false))))})
		      end)
	 in
	    {mkReader = mkReader,
	     mkWriter = mkWriter,
	     readArr = readArr,
	     readVec = readVec,
	     writeArr = writeArr,
	     writeVec = writeVec}
	 end)
val {mkReader = mkTextReader: {fd: int32, initBlkMode: bool, name: string}
			      -> PrimIO.reader,
     mkWriter = mkTextWriter: {appendMode: bool,
			       chunkSize: int32,
			       fd: int32,
			       initBlkMode: bool,
			       name: string}
			      -> PrimIO.writer} =
   (make (char8,
	  char8,
	  PrimIO.reader,
	  unit -> bool,
	  unit -> unit,
	  string,
	  string,
	  PrimIO.writer,
	  char8 Sequence.Slice.t,
	  char8 Sequence.Slice.t,
	  unit -> bool,
	  unit -> unit,
	  int32,
	  string) {RD = RD,
		   WR = WR,
		   fromVector = (fn x_1631: string =>
				 case x_1631 of
				   v: string => v),
		   readArr = readChar8,
		   setMode = settext,
		   toArraySlice = toPoly_1,
		   toVectorSlice = toPoly_0,
		   vectorLength = length_9,
		   writeArr = writeChar8Arr,
		   writeVec = writeChar8Vec})
datatype PosixProcess.waitpid_arg = W_ANY_CHILD
				    | W_CHILD of int32
				    | W_SAME_GROUP
				    | W_GROUP of int32
datatype PosixProcess.exit_status = W_EXITED
				    | W_EXITSTATUS of word8
				    | W_SIGNALED of int32
				    | W_STOPPED of int32
datatype PosixProcess.killpid_arg = K_PROC of int32
				    | K_SAME_GROUP
				    | K_GROUP of int32
datatype StreamIOExtra.buf = Buf of {array: word8 array, size: int32 ref}
datatype StreamIOExtra.bufferMode = NO_BUF
				    | LINE_BUF of StreamIOExtra.buf
				    | BLOCK_BUF of StreamIOExtra.buf
datatype StreamIOExtra.state = Active
			       | Terminated
			       | Closed
datatype StreamIOExtra.outstream = Out of {augmented_writer: PrimIO.writer,
					   bufferMode: StreamIOExtra.bufferMode ref,
					   state: StreamIOExtra.state ref,
					   writer: PrimIO.writer}
datatype StreamIOExtra.out_pos = OutPos of {outstream: StreamIOExtra.outstream,
					    pos: int64}
datatype StreamIOExtra.state = Link of {buf: StreamIOExtra.buf}
			       | Eos of {buf: StreamIOExtra.buf}
			       | End
			       | Truncated
			       | Closed
	 StreamIOExtra.buf = Buf of {base: int64 Primitive.Option.t,
				     inp: word8 vector,
				     next: StreamIOExtra.state ref}
datatype StreamIOExtra.instream = In of {buf: StreamIOExtra.buf,
					 common: {augmented_reader: PrimIO.reader,
						  reader: PrimIO.reader,
						  tail: StreamIOExtra.state ref ref},
					 pos: int32}
datatype StreamIOExtra.Close.t = T of {close: unit -> unit,
				       name: string,
				       tail: StreamIOExtra.state ref ref}
datatype ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
datatype ImperativeIOExtra.state = Closed
				   | Open of {eos: bool}
				   | Stream of StreamIOExtra.instream
datatype ImperativeIOExtra.instream = In of {augmentedReader: PrimIO.reader,
					     buf: word8 array,
					     first: int32 ref,
					     last: int32 ref,
					     reader: PrimIO.reader,
					     state: ImperativeIOExtra.state ref}
val chunkSize: int32 = (toInt bufSize)
val line: {isLine: char8 -> bool, lineElem: char8} Primitive.Option.t =
   (SOME[{isLine: char8 -> bool, lineElem: char8}] {isLine = (fn x_1632: char8 =>
							      case x_1632 of
								c: char8 =>
								(= (char8) (c,
									    0xA))),
						    lineElem = 0xA})
val mkWriter: {appendMode: bool,
	       chunkSize: int32,
	       fd: int32,
	       initBlkMode: bool,
	       name: string}
	      -> PrimIO.writer =
   mkTextWriter
val someElem: char8 = 0x0
val rec 'a_3785
   liftExn: string -> string -> exn -> 'a_3785 = 
      (fn x_1633: string =>
       (fn x_1634: string =>
	(fn x_1635: exn =>
	 case (x_1633, x_1634, x_1635) of
	   (name: string, function: string, cause: exn) =>
	   raise (Io {name = name, function = function, cause = cause}))))
datatype StreamIOExtra.buf = Buf of {array: char8 array, size: int32 ref}
datatype StreamIOExtra.bufferMode = NO_BUF
				    | LINE_BUF of StreamIOExtra.buf
				    | BLOCK_BUF of StreamIOExtra.buf
val rec
   newLineBuf: int32 -> StreamIOExtra.bufferMode = 
      (fn x_1636: int32 =>
       case x_1636 of
	 (bufSize: int32) =>
	 (LINE_BUF (Buf {size = (ref[int32] 0x0),
			 array = (array_1 (bufSize, someElem))})))
val rec
   newBlockBuf: int32 -> StreamIOExtra.bufferMode = 
      (fn x_1637: int32 =>
       case x_1637 of
	 (bufSize: int32) =>
	 (BLOCK_BUF (Buf {size = (ref[int32] 0x0),
			  array = (array_1 (bufSize, someElem))})))
datatype StreamIOExtra.state = Active
			       | Terminated
			       | Closed
val rec
   active: StreamIOExtra.state -> bool = 
      (fn x_1638: StreamIOExtra.state =>
       case x_1638 of
	 (state: StreamIOExtra.state) =>
	 case state of
	   Active => true | _ => false)
val rec
   terminated: StreamIOExtra.state -> bool = 
      (fn x_1639: StreamIOExtra.state =>
       case x_1639 of
	 (state: StreamIOExtra.state) => (not (active state)))
val rec
   closed: StreamIOExtra.state -> bool = 
      (fn x_1640: StreamIOExtra.state =>
       case x_1640 of
	 (state: StreamIOExtra.state) =>
	 case state of
	   Closed => true | _ => false)
datatype StreamIOExtra.outstream = Out of {augmented_writer: PrimIO.writer,
					   bufferMode: StreamIOExtra.bufferMode ref,
					   state: StreamIOExtra.state ref,
					   writer: PrimIO.writer}
val rec 'a_3786
   outstreamSel: StreamIOExtra.outstream
		 * ({augmented_writer: PrimIO.writer,
		     bufferMode: StreamIOExtra.bufferMode ref,
		     state: StreamIOExtra.state ref,
		     writer: PrimIO.writer}
		    -> 'a_3786)
		 -> 'a_3786 = 
      (fn x_1641: StreamIOExtra.outstream
		  * ({augmented_writer: PrimIO.writer,
		      bufferMode: StreamIOExtra.bufferMode ref,
		      state: StreamIOExtra.state ref,
		      writer: PrimIO.writer}
		     -> 'a_3786) =>
       case x_1641 of
	 ((Out v: {augmented_writer: PrimIO.writer,
		   bufferMode: StreamIOExtra.bufferMode ref,
		   state: StreamIOExtra.state ref,
		   writer: PrimIO.writer},
	   sel: {augmented_writer: PrimIO.writer,
		 bufferMode: StreamIOExtra.bufferMode ref,
		 state: StreamIOExtra.state ref,
		 writer: PrimIO.writer}
		-> 'a_3786)) =>
	 (sel v))
val rec
   outstreamWriter: StreamIOExtra.outstream -> PrimIO.writer = 
      (fn x_1642: StreamIOExtra.outstream =>
       case x_1642 of
	 (os: StreamIOExtra.outstream) =>
	 (outstreamSel (PrimIO.writer) (os,
					(fn x_1643: {augmented_writer: PrimIO.writer,
						     bufferMode: StreamIOExtra.bufferMode ref,
						     state: StreamIOExtra.state ref,
						     writer: PrimIO.writer} =>
					 case x_1643 of
					   {writer = #: PrimIO.writer} => #))))
val rec 'a_3787
   writerSel: PrimIO.writer
	      * ({block: (unit -> unit) Primitive.Option.t,
		  canOutput: (unit -> bool) Primitive.Option.t,
		  chunkSize: int32,
		  close: unit -> unit,
		  endPos: (unit -> int64) Primitive.Option.t,
		  getPos: (unit -> int64) Primitive.Option.t,
		  ioDesc: int32 Primitive.Option.t,
		  name: string,
		  setPos: (int64 -> unit) Primitive.Option.t,
		  verifyPos: (unit -> int64) Primitive.Option.t,
		  writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		  writeArrNB: (char8 Sequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t,
		  writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		  writeVecNB: (char8 Sequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t}
		 -> 'a_3787)
	      -> 'a_3787 = 
      (fn x_1644: PrimIO.writer
		  * ({block: (unit -> unit) Primitive.Option.t,
		      canOutput: (unit -> bool) Primitive.Option.t,
		      chunkSize: int32,
		      close: unit -> unit,
		      endPos: (unit -> int64) Primitive.Option.t,
		      getPos: (unit -> int64) Primitive.Option.t,
		      ioDesc: int32 Primitive.Option.t,
		      name: string,
		      setPos: (int64 -> unit) Primitive.Option.t,
		      verifyPos: (unit -> int64) Primitive.Option.t,
		      writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		      writeArrNB: (char8 Sequence.Slice.t
				   -> int32 Primitive.Option.t) Primitive.Option.t,
		      writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		      writeVecNB: (char8 Sequence.Slice.t
				   -> int32 Primitive.Option.t) Primitive.Option.t}
		     -> 'a_3787) =>
       case x_1644 of
	 ((WR v: {block: (unit -> unit) Primitive.Option.t,
		  canOutput: (unit -> bool) Primitive.Option.t,
		  chunkSize: int32,
		  close: unit -> unit,
		  endPos: (unit -> int64) Primitive.Option.t,
		  getPos: (unit -> int64) Primitive.Option.t,
		  ioDesc: int32 Primitive.Option.t,
		  name: string,
		  setPos: (int64 -> unit) Primitive.Option.t,
		  verifyPos: (unit -> int64) Primitive.Option.t,
		  writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		  writeArrNB: (char8 Sequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t,
		  writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		  writeVecNB: (char8 Sequence.Slice.t
			       -> int32 Primitive.Option.t) Primitive.Option.t},
	   sel: {block: (unit -> unit) Primitive.Option.t,
		 canOutput: (unit -> bool) Primitive.Option.t,
		 chunkSize: int32,
		 close: unit -> unit,
		 endPos: (unit -> int64) Primitive.Option.t,
		 getPos: (unit -> int64) Primitive.Option.t,
		 ioDesc: int32 Primitive.Option.t,
		 name: string,
		 setPos: (int64 -> unit) Primitive.Option.t,
		 verifyPos: (unit -> int64) Primitive.Option.t,
		 writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		 writeArrNB: (char8 Sequence.Slice.t -> int32 Primitive.Option.t) Primitive.Option.t,
		 writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
		 writeVecNB: (char8 Sequence.Slice.t -> int32 Primitive.Option.t) Primitive.Option.t}
		-> 'a_3787)) =>
	 (sel v))
val rec
   outstreamName: StreamIOExtra.outstream -> string = 
      (fn x_1645: StreamIOExtra.outstream =>
       case x_1645 of
	 (os: StreamIOExtra.outstream) =>
	 (writerSel (string) ((outstreamWriter os),
			      (fn x_1646: {block: (unit -> unit) Primitive.Option.t,
					   canOutput: (unit -> bool) Primitive.Option.t,
					   chunkSize: int32,
					   close: unit -> unit,
					   endPos: (unit -> int64) Primitive.Option.t,
					   getPos: (unit -> int64) Primitive.Option.t,
					   ioDesc: int32 Primitive.Option.t,
					   name: string,
					   setPos: (int64 -> unit) Primitive.Option.t,
					   verifyPos: (unit -> int64) Primitive.Option.t,
					   writeArr: (char8 Sequence.Slice.t
						      -> int32) Primitive.Option.t,
					   writeArrNB: (char8 Sequence.Slice.t
							-> int32 Primitive.Option.t) Primitive.Option.t,
					   writeVec: (char8 Sequence.Slice.t
						      -> int32) Primitive.Option.t,
					   writeVecNB: (char8 Sequence.Slice.t
							-> int32 Primitive.Option.t) Primitive.Option.t} =>
			       case x_1646 of
				 {name = #: string} => #))))
val rec ('b, 'a)
   flushGen: ('a -> int32)
	     * ('a -> 'b * int32 * int32)
	     * ('b * int32 * int32 Primitive.Option.t -> 'a)
	     * 'a
	     -> unit = 
      (fn x_1647: ('a -> int32)
		  * ('a -> 'b * int32 * int32)
		  * ('b * int32 * int32 Primitive.Option.t -> 'a)
		  * 'a =>
       case x_1647 of
	 ((write: 'a -> int32,
	   base: 'a -> 'b * int32 * int32,
	   slice: 'b * int32 * int32 Primitive.Option.t -> 'a,
	   a: 'a)) =>
	 let val (b: 'b, i: int32, sz: int32) = (base a)
	     val max: int32 = (+ (i, sz))
	     val rec
		loop: int32 -> unit = 
		   (fn x_1648: int32 =>
		    case x_1648 of
		      (i: int32) =>
		      case (= (int32) (i, max)) of
			true => ()
		      | false =>
			let val j: int32 =
			       (write (slice (b, i, (SOME[int32] (- (max, i))))))
			in
			   case (= (int32) (j, 0x0)) of
			     true => raise (Fail "partial write")
			   | false => (loop (+ (i, j)))
			end)
	 in
	    (loop i)
	 end)
val rec
   flushVec: PrimIO.writer * char8 Sequence.Slice.t -> unit = 
      (fn x_1649: PrimIO.writer * char8 Sequence.Slice.t =>
       case x_1649 of
	 ((writer: PrimIO.writer, x: char8 Sequence.Slice.t)) =>
	 case (writerSel ((char8 Sequence.Slice.t -> int32) Primitive.Option.t) (writer,
										 (fn x_1650: {block: (unit
												      -> unit) Primitive.Option.t,
											      canOutput: (unit
													  -> bool) Primitive.Option.t,
											      chunkSize: int32,
											      close: unit
												     -> unit,
											      endPos: (unit
												       -> int64) Primitive.Option.t,
											      getPos: (unit
												       -> int64) Primitive.Option.t,
											      ioDesc: int32 Primitive.Option.t,
											      name: string,
											      setPos: (int64
												       -> unit) Primitive.Option.t,
											      verifyPos: (unit
													  -> int64) Primitive.Option.t,
											      writeArr: (char8 Sequence.Slice.t
													 -> int32) Primitive.Option.t,
											      writeArrNB: (char8 Sequence.Slice.t
													   -> int32 Primitive.Option.t) Primitive.Option.t,
											      writeVec: (char8 Sequence.Slice.t
													 -> int32) Primitive.Option.t,
											      writeVecNB: (char8 Sequence.Slice.t
													   -> int32 Primitive.Option.t) Primitive.Option.t} =>
										  case x_1650 of
										    {writeVec = #: (char8 Sequence.Slice.t
												    -> int32) Primitive.Option.t} =>
										    #))) of
	   NONE[char8 Sequence.Slice.t -> int32] => raise BlockingNotSupported
	 | SOME[char8 Sequence.Slice.t -> int32] writeVec: char8 Sequence.Slice.t
							   -> int32 =>
	   (flushGen (string, char8 Sequence.Slice.t) (writeVec,
						       base_6,
						       slice_5,
						       x)))
val rec
   flushArr: PrimIO.writer * char8 Sequence.Slice.t -> unit = 
      (fn x_1651: PrimIO.writer * char8 Sequence.Slice.t =>
       case x_1651 of
	 ((writer: PrimIO.writer, x: char8 Sequence.Slice.t)) =>
	 case (writerSel ((char8 Sequence.Slice.t -> int32) Primitive.Option.t) (writer,
										 (fn x_1652: {block: (unit
												      -> unit) Primitive.Option.t,
											      canOutput: (unit
													  -> bool) Primitive.Option.t,
											      chunkSize: int32,
											      close: unit
												     -> unit,
											      endPos: (unit
												       -> int64) Primitive.Option.t,
											      getPos: (unit
												       -> int64) Primitive.Option.t,
											      ioDesc: int32 Primitive.Option.t,
											      name: string,
											      setPos: (int64
												       -> unit) Primitive.Option.t,
											      verifyPos: (unit
													  -> int64) Primitive.Option.t,
											      writeArr: (char8 Sequence.Slice.t
													 -> int32) Primitive.Option.t,
											      writeArrNB: (char8 Sequence.Slice.t
													   -> int32 Primitive.Option.t) Primitive.Option.t,
											      writeVec: (char8 Sequence.Slice.t
													 -> int32) Primitive.Option.t,
											      writeVecNB: (char8 Sequence.Slice.t
													   -> int32 Primitive.Option.t) Primitive.Option.t} =>
										  case x_1652 of
										    {writeArr = #: (char8 Sequence.Slice.t
												    -> int32) Primitive.Option.t} =>
										    #))) of
	   NONE[char8 Sequence.Slice.t -> int32] => raise BlockingNotSupported
	 | SOME[char8 Sequence.Slice.t -> int32] writeArr: char8 Sequence.Slice.t
							   -> int32 =>
	   (flushGen (char8 array, char8 Sequence.Slice.t) (writeArr,
							    base_7,
							    slice_6,
							    x)))
val rec
   flushBuf': PrimIO.writer * int32 ref * char8 array -> unit = 
      (fn x_1653: PrimIO.writer * int32 ref * char8 array =>
       case x_1653 of
	 ((writer: PrimIO.writer, size: int32 ref, array: char8 array)) =>
	 let val size': int32 = (!_1 (int32) size)
	 in
	    (:=_1 (int32) (size, 0x0))
	    ;(flushArr (writer, (slice_6 (array, 0x0, (SOME[int32] size')))))
	 end)
val rec
   flushBuf: PrimIO.writer * StreamIOExtra.buf -> unit = 
      (fn x_1654: PrimIO.writer * StreamIOExtra.buf =>
       case x_1654 of
	 ((writer: PrimIO.writer,
	   Buf {size = size: int32 ref, array = array: char8 array})) =>
	 (flushBuf' (writer, size, array)))
val rec
   output: StreamIOExtra.outstream * string -> unit = 
      (fn x_1655: StreamIOExtra.outstream * string =>
       case x_1655 of
	 ((os: StreamIOExtra.outstream as Out {augmented_writer = augmented_writer: PrimIO.writer,
					       state = state: StreamIOExtra.state ref,
					       bufferMode = bufferMode: StreamIOExtra.bufferMode ref},
	   v: string)) =>
	 case (terminated (!_1 (StreamIOExtra.state) state)) of
	   true => (((liftExn (unit) (outstreamName os)) "output") ClosedStream)
	 | false =>
	   let val rec
		  put: unit -> unit = 
		     (fn x_1658: unit =>
		      case x_1658 of
			(()) => (flushVec (augmented_writer, (full_5 v))))
	       val rec
		  doit: StreamIOExtra.buf * (unit -> bool) -> unit = 
		     (fn x_1657: StreamIOExtra.buf * (unit -> bool) =>
		      case x_1657 of
			((buf: StreamIOExtra.buf as Buf {size = size: int32 ref,
							 array = array: char8 array},
			  maybe: unit -> bool)) =>
			let val curSize: int32 = (!_1 (int32) size)
			    val newSize: int32 = (+ (curSize, (length_9 v)))
			in
			   case case (>= (newSize, (length_11 array))) of
				  true => true | false => (maybe ()) of
			     true =>
			     (flushBuf (augmented_writer, buf)) ;(put ())
			   | false =>
			     (copyVec_1 {src = v, dst = array, di = curSize})
			     ;(:=_1 (int32) (size, newSize))
			end)
	   in
	      case (!_1 (StreamIOExtra.bufferMode) bufferMode) of
		NO_BUF => (put ())
	      | LINE_BUF buf: StreamIOExtra.buf =>
		(doit (buf,
		       (fn x_1659: unit =>
			case x_1659 of
			  () =>
			  case line of
			    NONE[{isLine: char8 -> bool, lineElem: char8}] =>
			    false
			  | SOME[{isLine: char8 -> bool, lineElem: char8}] {isLine = isLine: char8
											     -> bool} =>
			    ((exists_2 isLine) v))))
	      | BLOCK_BUF buf: StreamIOExtra.buf =>
		(doit (buf, (fn x_1660: unit => case x_1660 of () => false)))
	   end
	   handle x_1656 => case x_1656 of
			      exn: exn =>
			      (((liftExn (unit) (outstreamName os)) "output") exn))
val rec
   flushOut: StreamIOExtra.outstream -> unit = 
      (fn x_1661: StreamIOExtra.outstream =>
       case x_1661 of
	 (os: StreamIOExtra.outstream as Out {augmented_writer = augmented_writer: PrimIO.writer,
					      state = state: StreamIOExtra.state ref,
					      bufferMode = bufferMode: StreamIOExtra.bufferMode ref}) =>
	 case (terminated (!_1 (StreamIOExtra.state) state)) of
	   true => ()
	 | false =>
	   case (!_1 (StreamIOExtra.bufferMode) bufferMode) of
	     NO_BUF => ()
	   | LINE_BUF buf: StreamIOExtra.buf =>
	     (flushBuf (augmented_writer, buf))
	   | BLOCK_BUF buf: StreamIOExtra.buf =>
	     (flushBuf (augmented_writer, buf))
	     handle x_1662 => case x_1662 of
				exn: exn =>
				(((liftExn (unit) (outstreamName os)) "flushOut") exn))
val rec
   makeTerminated: StreamIOExtra.outstream -> unit = 
      (fn x_1663: StreamIOExtra.outstream =>
       case x_1663 of
	 (Out {bufferMode = bufferMode: StreamIOExtra.bufferMode ref}) =>
	 let val rec
		doit: StreamIOExtra.buf -> unit = 
		   (fn x_1664: StreamIOExtra.buf =>
		    case x_1664 of
		      (Buf {array = array: char8 array, size = size: int32 ref}) =>
		      (:=_1 (int32) (size, (length_11 array))))
	 in
	    case (!_1 (StreamIOExtra.bufferMode) bufferMode) of
	      BLOCK_BUF b: StreamIOExtra.buf => (doit b)
	    | LINE_BUF b: StreamIOExtra.buf => (doit b) | NO_BUF => ()
	 end)
val rec
   closeOut: StreamIOExtra.outstream -> unit = 
      (fn x_1665: StreamIOExtra.outstream =>
       case x_1665 of
	 (os: StreamIOExtra.outstream as Out {state = state: StreamIOExtra.state ref}) =>
	 case (closed (!_1 (StreamIOExtra.state) state)) of
	   true => ()
	 | false =>
	   (flushOut os)
	   ;case (terminated (!_1 (StreamIOExtra.state) state)) of
	      true => ()
	    | false =>
	      ((writerSel (unit -> unit) ((outstreamWriter os),
					  (fn x_1667: {block: (unit -> unit) Primitive.Option.t,
						       canOutput: (unit -> bool) Primitive.Option.t,
						       chunkSize: int32,
						       close: unit -> unit,
						       endPos: (unit -> int64) Primitive.Option.t,
						       getPos: (unit -> int64) Primitive.Option.t,
						       ioDesc: int32 Primitive.Option.t,
						       name: string,
						       setPos: (int64 -> unit) Primitive.Option.t,
						       verifyPos: (unit -> int64) Primitive.Option.t,
						       writeArr: (char8 Sequence.Slice.t
								  -> int32) Primitive.Option.t,
						       writeArrNB: (char8 Sequence.Slice.t
								    -> int32 Primitive.Option.t) Primitive.Option.t,
						       writeVec: (char8 Sequence.Slice.t
								  -> int32) Primitive.Option.t,
						       writeVecNB: (char8 Sequence.Slice.t
								    -> int32 Primitive.Option.t) Primitive.Option.t} =>
					   case x_1667 of
					     {close = #: unit -> unit} => #))) ())
	   ;(:=_1 (StreamIOExtra.state) (state, Closed))
	   ;(makeTerminated os)
	   handle x_1666 => case x_1666 of
			      exn: exn =>
			      (((liftExn (unit) (outstreamName os)) "closeOut") exn))
val rec
   mkOutstream': {bufferMode: IO.buffer_mode,
		  closed: bool,
		  writer: PrimIO.writer}
		 -> StreamIOExtra.outstream = 
      (fn x_1668: {bufferMode: IO.buffer_mode,
		   closed: bool,
		   writer: PrimIO.writer} =>
       case x_1668 of
	 ({writer = writer: PrimIO.writer,
	   closed = closed: bool,
	   bufferMode = bufferMode: IO.buffer_mode}) =>
	 let val bufSize: int32 =
		(writerSel (int32) (writer,
				    (fn x_1669: {block: (unit -> unit) Primitive.Option.t,
						 canOutput: (unit -> bool) Primitive.Option.t,
						 chunkSize: int32,
						 close: unit -> unit,
						 endPos: (unit -> int64) Primitive.Option.t,
						 getPos: (unit -> int64) Primitive.Option.t,
						 ioDesc: int32 Primitive.Option.t,
						 name: string,
						 setPos: (int64 -> unit) Primitive.Option.t,
						 verifyPos: (unit -> int64) Primitive.Option.t,
						 writeArr: (char8 Sequence.Slice.t
							    -> int32) Primitive.Option.t,
						 writeArrNB: (char8 Sequence.Slice.t
							      -> int32 Primitive.Option.t) Primitive.Option.t,
						 writeVec: (char8 Sequence.Slice.t
							    -> int32) Primitive.Option.t,
						 writeVecNB: (char8 Sequence.Slice.t
							      -> int32 Primitive.Option.t) Primitive.Option.t} =>
				     case x_1669 of
				       {chunkSize = #: int32} => #)))
	 in
	    (Out {writer = writer,
		  augmented_writer = (augmentWriter writer),
		  state = (ref[StreamIOExtra.state] case closed of
						      true => Closed
						    | false => Active),
		  bufferMode = (ref[StreamIOExtra.bufferMode] case bufferMode of
								NO_BUF => NO_BUF
							      | LINE_BUF =>
								(newLineBuf bufSize)
							      | BLOCK_BUF =>
								(newBlockBuf bufSize))})
	 end)
datatype StreamIOExtra.out_pos = OutPos of {outstream: StreamIOExtra.outstream,
					    pos: int64}
datatype StreamIOExtra.state = Link of {buf: StreamIOExtra.buf}
			       | Eos of {buf: StreamIOExtra.buf}
			       | End
			       | Truncated
			       | Closed
	 StreamIOExtra.buf = Buf of {base: int64 Primitive.Option.t,
				     inp: string,
				     next: StreamIOExtra.state ref}
datatype StreamIOExtra.instream = In of {buf: StreamIOExtra.buf,
					 common: {augmented_reader: PrimIO.reader,
						  reader: PrimIO.reader,
						  tail: StreamIOExtra.state ref ref},
					 pos: int32}
datatype StreamIOExtra.Close.t = T of {close: unit -> unit,
				       name: string,
				       tail: StreamIOExtra.state ref ref}
val openOutstreams: (StreamIOExtra.outstream * {close: bool}) list ref =
   (ref[(StreamIOExtra.outstream * {close: bool}) list] [])
val mkOutstream'': {bufferMode: IO.buffer_mode,
		    closeAtExit: bool,
		    closed: bool,
		    writer: PrimIO.writer}
		   -> StreamIOExtra.outstream =
   let val _ =
	  (addNew_0 (atExit,
		     (fn x_1670: unit =>
		      case x_1670 of
			() =>
			((app_0 (StreamIOExtra.outstream * {close: bool}) (fn x_1671: StreamIOExtra.outstream
										      * {close: bool} =>
									   case x_1671 of
									     (os: StreamIOExtra.outstream,
									      {close = close: bool}) =>
									     case close of
									       true =>
									       (closeOut os)
									     | false =>
									       (flushOut os))) (!_1 ((StreamIOExtra.outstream
												      * {close: bool}) list) openOutstreams)))))
   in
      (fn x_1672: {bufferMode: IO.buffer_mode,
		   closeAtExit: bool,
		   closed: bool,
		   writer: PrimIO.writer} =>
       case x_1672 of
	 {bufferMode = bufferMode: IO.buffer_mode,
	  closeAtExit = closeAtExit: bool,
	  closed = closed: bool,
	  writer = writer: PrimIO.writer} =>
	 let val os: StreamIOExtra.outstream =
		(mkOutstream' {bufferMode = bufferMode,
			       closed = closed,
			       writer = writer})
	     val _ =
		case closed of
		  true => ()
		| false =>
		  (:=_1 ((StreamIOExtra.outstream * {close: bool}) list) (openOutstreams,
									  (::[StreamIOExtra.outstream
									      * {close: bool}] ((os,
												 {close = closeAtExit}),
												(!_1 ((StreamIOExtra.outstream
												       * {close: bool}) list) openOutstreams)))))
	 in
	    os
	 end)
   end
datatype ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
val rec
   get: ImperativeIOExtra.Outstream.t -> StreamIOExtra.outstream = 
      (fn x_1673: ImperativeIOExtra.Outstream.t =>
       case x_1673 of
	 (T r: StreamIOExtra.outstream ref) => (!_1 (StreamIOExtra.outstream) r))
val rec
   make: StreamIOExtra.outstream -> ImperativeIOExtra.Outstream.t = 
      (fn x_1674: StreamIOExtra.outstream =>
       case x_1674 of
	 (s: StreamIOExtra.outstream) => (T (ref[StreamIOExtra.outstream] s)))
val rec
   output: ImperativeIOExtra.Outstream.t * string -> unit = 
      (fn x_1675: ImperativeIOExtra.Outstream.t * string =>
       case x_1675 of
	 ((os: ImperativeIOExtra.Outstream.t, v: string)) =>
	 (output ((get os), v)))
val rec
   flushOut: ImperativeIOExtra.Outstream.t -> unit = 
      (fn x_1676: ImperativeIOExtra.Outstream.t =>
       case x_1676 of
	 (os: ImperativeIOExtra.Outstream.t) => (flushOut (get os)))
val mkOutstream: StreamIOExtra.outstream -> ImperativeIOExtra.Outstream.t = make
val rec
   newOut: {appendMode: bool,
	    bufferMode: IO.buffer_mode,
	    closeAtExit: bool,
	    fd: int32,
	    name: string}
	   -> ImperativeIOExtra.Outstream.t = 
      (fn x_1677: {appendMode: bool,
		   bufferMode: IO.buffer_mode,
		   closeAtExit: bool,
		   fd: int32,
		   name: string} =>
       case x_1677 of
	 ({appendMode = appendMode: bool,
	   bufferMode = bufferMode: IO.buffer_mode,
	   closeAtExit = closeAtExit: bool,
	   fd = fd: int32,
	   name = name: string}) =>
	 let val writer: PrimIO.writer =
		(mkWriter {appendMode = appendMode,
			   chunkSize = chunkSize,
			   fd = fd,
			   initBlkMode = true,
			   name = name})
	     val outstream: StreamIOExtra.outstream =
		(mkOutstream'' {bufferMode = bufferMode,
				closeAtExit = closeAtExit,
				closed = false,
				writer = writer})
	 in
	    (mkOutstream outstream)
	 end)
val newOut: {appendMode: bool, closeAtExit: bool, fd: int32, name: string}
	    -> ImperativeIOExtra.Outstream.t =
   (fn x_1678: {appendMode: bool, closeAtExit: bool, fd: int32, name: string} =>
    case x_1678 of
      {appendMode = appendMode: bool,
       closeAtExit = closeAtExit: bool,
       fd = fd: int32,
       name = name: string} =>
      (newOut {appendMode = appendMode,
	       bufferMode = case (isatty fd) of
			      true => LINE_BUF | false => BLOCK_BUF,
	       closeAtExit = closeAtExit,
	       fd = fd,
	       name = name}))
val stdOut: ImperativeIOExtra.Outstream.t =
   (newOut {appendMode = true,
	    closeAtExit = false,
	    fd = stdout,
	    name = "<stdout>"})
datatype ImperativeIOExtra.state = Closed
				   | Open of {eos: bool}
				   | Stream of StreamIOExtra.instream
datatype ImperativeIOExtra.instream = In of {augmentedReader: PrimIO.reader,
					     buf: char8 array,
					     first: int32 ref,
					     last: int32 ref,
					     reader: PrimIO.reader,
					     state: ImperativeIOExtra.state ref}
val rec
   print: string -> unit = 
      (fn x_1679: string =>
       case x_1679 of
	 (s: string) => (output (stdOut, s)) ;(flushOut stdOut))
exception Path
exception InvalidArc
datatype OS_FileSys.file_id = FID of {dev: word64, ino: word64}
exception Sqrt
exception Ln
exception Ord
exception Io of string
exception Interrupt
val rec ('a_3801, 'a_3800)
   wrap: ('a_3801 * int64 -> 'a_3800) -> 'a_3801 * int32 -> 'a_3800 = 
      (fn x_1680: 'a_3801 * int64 -> 'a_3800 =>
       (fn x_1681: 'a_3801 * int32 =>
	case (x_1680, x_1681) of
	  (f: 'a_3801 * int64 -> 'a_3800, (p: 'a_3801, i: int32)) =>
	  (f (p, (fromInt i)))))
val getInt32: cpointer * int32 -> int32 = (wrap (cpointer, int32) getInt32)
val getWord32: cpointer * int32 -> word32 = (wrap (cpointer, word32) getWord32)
val gcState: cpointer = gcState
val current: unit -> Primitive.MLton.CallStack.t =
   (fn x_1682: unit =>
    case x_1682 of
      () =>
      case (not keep) of
	true => (T (array_0 (word32) (0x0, 0x0)))
      | false =>
	let val a: word32 array =
	       (arrayUninit_0 (word32) (toInt (numStackFrames gcState)))
	    val () = (callStack (gcState, a))
	in
	   (T a)
	end)
val toStrings: Primitive.MLton.CallStack.t -> string list =
   (fn x_1683: Primitive.MLton.CallStack.t =>
    case x_1683 of
      T a: word32 array =>
      case (not keep) of
	true => []
      | false =>
	let val skip: int32 = (- ((length_8 (word32) a), 0x1))
	in
	   (((foldri_1 (string list, word32) (fn x_1684: int32
							 * word32
							 * string list =>
					      case x_1684 of
						(i: int32,
						 frameIndex: word32,
						 ac: string list) =>
						case (>= (i, skip)) of
						  true => ac
						| false =>
						  let val p: cpointer =
							 (frameIndexSourceSeq (gcState,
									       frameIndex))
						      val max: int32 =
							 (toInt (getInt32 (p,
									   0x0)))
						      val rec
							 loop: int32
							       * string list
							       -> string list = 
							    (fn x_1685: int32
									* string list =>
							     case x_1685 of
							       ((j: int32,
								 ac: string list)) =>
							       case (> (j, max)) of
								 true => ac
							       | false =>
								 (loop ((+ (j,
									    0x1)),
									(::[string] ((toString (sourceName (gcState,
													    (getWord32 (p,
															j))))),
										     ac)))))
						  in
						     (loop (0x1, ac))
						  end)) []) a)
	end)
val fromInt: int32 -> int32 = (o_1 (int32, int32, int32) (fromRep, fromInt))
val toInt: int32 -> int32 = (o_1 (int32, int32, int32) (toInt, toRep))
val failure: int32 = (fromInt 0x1)
val success: int32 = (fromInt 0x0)
val exiting: bool ref = (ref[bool] false)
val rec
   halt: int32 -> unit = 
      (fn x_1686: int32 =>
       case x_1686 of
	 (status: int32) => (halt (toRep status)))
val rec 'a
   exit: int32 -> 'a = 
      (fn x_1687: int32 =>
       case x_1687 of
	 (status: int32) =>
	 case (!_1 (bool) exiting) of
	   true => raise (Fail "MLton.Exit.exit")
	 | false =>
	   let val _ = (:=_1 (bool) (exiting, true))
	       val i: int32 = (toInt status)
	   in
	      case case (<= (0x0, i)) of
		     true => (< (i, 0x100)) | false => false of
		true =>
		let 
		in
		   (clean atExit)
		end
		;(halt status)
		;raise (Fail "MLton.Exit.exit")
	      | false =>
		raise (Fail (concat_2 ["MLton.Exit.exit(",
				       (toString i),
				       "): ",
				       "exit must have 0 <= status < 256"]))
	   end)
val message: string -> unit = print
val rec 'a
   wrapSuffix: (unit -> unit) -> unit -> 'a = 
      (fn x_1688: unit -> unit =>
       (fn x_1689: unit =>
	case (x_1688, x_1689) of
	  (suffix: unit -> unit, ()) =>
	  (suffix ())
	  ;(message "Top-level suffix returned.
")
	  ;(exit ('a) failure)
	  handle x_1690 => case x_1690 of
			     _ =>
			     (message "Top-level suffix raised exception.
")
			     ;(halt failure)
			     ;raise (Fail "MLton.Exit.wrapSuffix")))
val rec
   suffixArchiveOrLibrary: unit -> unit = 
      (fn x_1691: unit =>
       case x_1691 of
	 (()) =>
	 let val () = (returnToC ())
	     val _ = (:=_1 (bool) (exiting, true))
	     val () = let  in (clean atExit) end
	     val () = (returnToC ())
	 in
	    ()
	 end)
val rec 'a_3807
   suffixExecutable: unit -> 'a_3807 = 
      (fn x_1692: unit =>
       case x_1692 of
	 (()) => (exit ('a_3807) success))
val defaultSuffix: unit -> unit =
   let 
   in
      case host of
	Archive => suffixArchiveOrLibrary
      | Executable => suffixExecutable (unit)
      | LibArchive => suffixArchiveOrLibrary
      | Library => suffixArchiveOrLibrary
   end
val rec 'a
   defaultTopLevelSuffix: unit -> 'a = 
      (fn x_1693: unit =>
       case x_1693 of
	 (()) => ((wrapSuffix ('a) defaultSuffix) ()))
val history: exn -> string list =
   case keepHistory of
     true =>
     (setExtendExtra (fn x_1694: Primitive.MLton.CallStack.t Primitive.Option.t =>
		      case x_1694 of
			e: Primitive.MLton.CallStack.t Primitive.Option.t =>
			case e of
			  NONE[Primitive.MLton.CallStack.t] =>
			  (SOME[Primitive.MLton.CallStack.t] (current ()))
			| SOME[Primitive.MLton.CallStack.t] _ => e))
     ;(fn x_1695: exn =>
       case x_1695 of
	 e: exn =>
	 case (extra e) of
	   NONE[Primitive.MLton.CallStack.t] => []
	 | SOME[Primitive.MLton.CallStack.t] cs: Primitive.MLton.CallStack.t =>
	   let val rec
		  loop: string list -> string list = 
		     (fn x_1696: string list =>
		      case x_1696 of
			(xs: string list) =>
			case xs of
			  [] => []
			| ::[string] (x: string, xs: string list) =>
			  case ((isPrefix "MLtonExn.fn ") x) of
			    true => xs | false => (loop xs))
	   in
	      (loop (toStrings cs))
	   end)
   | false => (fn x_1697: exn => case x_1697 of _ => [])
val message: string -> unit = print
val rec 'a
   wrapHandler: (exn -> unit) -> exn -> 'a = 
      (fn x_1698: exn -> unit =>
       (fn x_1699: exn =>
	case (x_1698, x_1699) of
	  (handler: exn -> unit, exn: exn) =>
	  (handler exn)
	  ;(message "Top-level handler returned.
")
	  ;(exit ('a) failure)
	  handle x_1700 => case x_1700 of
			     _ =>
			     (message "Top-level handler raised exception.
")
			     ;(halt failure)
			     ;raise (Fail "MLton.Exn.wrapHandler")))
val 'a_3808 defaultHandler: exn -> 'a_3808 =
   (fn x_1701: exn =>
    case x_1701 of
      exn: exn =>
      (message (concat_2 ["unhandled exception: ", (exnMessage exn), "
"]))
      ;case (history exn) of
	 [] => ()
       | l: string list =>
	 (message "with history:
")
	 ;((app_0 (string) (fn x_1702: string =>
			    case x_1702 of
			      s: string => (message (concat_2 ["	", s, "
"])))) l)
      ;(exit ('a_3808) failure))
val rec 'a
   defaultTopLevelHandler: exn -> 'a = 
      (fn x_1703: exn =>
       case x_1703 of
	 (exn: exn) => ((wrapHandler ('a) defaultHandler (unit)) exn))
datatype MLtonThread.AtomicState.t = NonAtomic
				     | Atomic of int32
datatype 'a MLtonThread.thread = Dead
				 | Interrupted of thread
				 | New of 'a -> unit
				 | Paused of ((unit -> 'a) -> unit) * thread
datatype 'a MLtonThread.t = T of 'a MLtonThread.thread ref
datatype MLtonThread.state = Normal
			     | InHandler
datatype MLtonSignal.Mask.t = AllBut of int32 list
			      | Some of int32 list
datatype MLtonSignal.Handler.t = Default
				 | Handler of unit MLtonThread.t
					      -> unit MLtonThread.t
				 | Ignore
				 | InvalidSignal
exception MisuseOfForget
exception DoublyRedirected
datatype 'use MLtonProcess.Child.childt = FileDesc of int32
					  | Stream of 'use * ('use -> unit)
					  | Term
datatype ('use, 'dir) MLtonProcess.Param.t = File of string
					     | FileDesc of int32
					     | Pipe
					     | Self
datatype ('stdin, 'stdout, 'stderr) MLtonProcess.t = T of {pid: int32,
							   status: PosixProcess.exit_status Primitive.Option.t ref,
							   stderr: 'stderr MLtonProcess.Child.childt ref,
							   stdin: 'stdin MLtonProcess.Child.childt ref,
							   stdout: 'stdout MLtonProcess.Child.childt ref}
datatype OS_IO.iodesc_kind = K of string
datatype OS_IO.poll_desc = PollDesc of int32 * {pri: bool, rd: bool, wr: bool}
datatype OS_IO.poll_info = PollInfo of int32 * {pri: bool, rd: bool, wr: bool}
exception Poll
datatype Timer.SysUsr.t = T of {sys: Time.time, usr: Time.time}
val hton: word16 -> word16 = htons
val ntoh: word16 -> word16 = ntohs
val hton: int16 -> int16 =
   (o_1 (int16, int16, word16) ((o_1 (word16, int16, word16) (idFromWord16ToInt16,
							      hton)),
				idFromInt16ToWord16))
val ntoh: int16 -> int16 =
   (o_1 (int16, int16, word16) ((o_1 (word16, int16, word16) (idFromWord16ToInt16,
							      ntoh)),
				idFromInt16ToWord16))
val ('a_3954, 'a_3953) fInt8: 'a_3954 -> 'a_3953 =
   (fn x_1704: 'a_3954 =>
    case x_1704 of
      _ => raise (Fail "Net.C_Int.hton: fInt8"))
val fInt16: int16 -> int16 = hton
val ('a_3956, 'a_3955) fInt64: 'a_3956 -> 'a_3955 =
   (fn x_1705: 'a_3956 =>
    case x_1705 of
      _ => raise (Fail "Net.C_Int.hton: fInt64"))
val fInt8_0: int8 -> int8 = fInt8 (int8, int8)
val fInt64_0: int64 -> int64 = fInt64 (int64, int64)
val _ = fInt8_0
val _ = fInt16
val _ = fInt64_0
val ('a_3960, 'a_3959) fInt8: 'a_3960 -> 'a_3959 =
   (fn x_1706: 'a_3960 =>
    case x_1706 of
      _ => raise (Fail "Net.C_Int.ntoh: fInt8"))
val fInt16: int16 -> int16 = ntoh
val ('a_3962, 'a_3961) fInt64: 'a_3962 -> 'a_3961 =
   (fn x_1707: 'a_3962 =>
    case x_1707 of
      _ => raise (Fail "Net.C_Int.ntoh: fInt64"))
val fInt8_1: int8 -> int8 = fInt8 (int8, int8)
val fInt64_1: int64 -> int64 = fInt64 (int64, int64)
val _ = fInt8_1
val _ = fInt16
val _ = fInt64_1
datatype NetHostDB.entry = T of {addrType: int32,
				 addrs: word8 vector list,
				 aliases: string list,
				 name: string}
datatype NetProtDB.entry = T of {aliases: string list,
				 name: string,
				 protocol: int32}
datatype NetServDB.entry = T of {aliases: string list,
				 name: string,
				 port: int32,
				 protocol: string}
datatype Socket.sock_addr = SA of word8 vector
datatype Socket.dgram = DGRAM
datatype Socket.stream = MODE
datatype Socket.passive = PASSIVE
datatype Socket.active = ACTIVE
datatype Socket.shutdown_mode = NO_RECVS
				| NO_SENDS
				| NO_RECVS_OR_SENDS
datatype INetSock.inet = INET
datatype UnixSock.unix = UNIX
datatype MLtonItimer.t = Prof
			 | Real
			 | Virtual
val gcState: cpointer = gcState
val isOn: bool = isOn
datatype MLtonProfile.Data.t = T of {isCurrent: bool ref,
				     isFreed: bool ref,
				     raw: cpointer}
val all: MLtonProfile.Data.t list ref = (ref[MLtonProfile.Data.t list] [])
val rec 'a_4043
   make: ({isCurrent: bool ref, isFreed: bool ref, raw: cpointer} -> 'a_4043)
	 -> MLtonProfile.Data.t -> 'a_4043 = 
      (fn x_1708: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer}
		  -> 'a_4043 =>
       (fn x_1709: MLtonProfile.Data.t =>
	case (x_1708, x_1709) of
	  (f: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer} -> 'a_4043,
	   T r: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer}) =>
	  (f r)))
val raw: MLtonProfile.Data.t -> cpointer =
   (make (cpointer) (fn x_1710: {isCurrent: bool ref,
				 isFreed: bool ref,
				 raw: cpointer} =>
		     case x_1710 of
		       {raw = #: cpointer} => #))
val rec
   make: cpointer -> MLtonProfile.Data.t = 
      (fn x_1711: cpointer =>
       case x_1711 of
	 (raw: cpointer) =>
	 (T {isCurrent = (ref[bool] false),
	     isFreed = (ref[bool] false),
	     raw = raw}))
val rec
   write: MLtonProfile.Data.t * string -> unit = 
      (fn x_1712: MLtonProfile.Data.t * string =>
       case x_1712 of
	 ((T {isFreed = isFreed: bool ref, raw = raw: cpointer}, file: string)) =>
	 case (not isOn) of
	   true => ()
	 | false =>
	   case (!_1 (bool) isFreed) of
	     true => raise (Fail "write of freed profile data")
	   | false => (write (gcState, raw, (fromString (nullTerm file)))))
val r: MLtonProfile.Data.t ref = (ref[MLtonProfile.Data.t] (make dummy))
val rec
   current: unit -> MLtonProfile.Data.t = 
      (fn x_1713: unit =>
       case x_1713 of
	 (()) => (!_1 (MLtonProfile.Data.t) r))
val rec
   setCurrent: MLtonProfile.Data.t -> unit = 
      (fn x_1714: MLtonProfile.Data.t =>
       case x_1714 of
	 (d: MLtonProfile.Data.t as T {isCurrent = isCurrent: bool ref,
				       isFreed = isFreed: bool ref,
				       raw = raw: cpointer}) =>
	 case (not isOn) of
	   true => ()
	 | false =>
	   case (!_1 (bool) isFreed) of
	     true => raise (Fail "setCurrent of freed profile data")
	   | false =>
	     let val T {isCurrent = ic: bool ref} = (current ())
		 val _ = (:=_1 (bool) (ic, false))
		 val _ = (:=_1 (bool) (isCurrent, true))
		 val _ = (:=_1 (MLtonProfile.Data.t) (r, d))
		 val _ = (setCurrent (gcState, raw))
	     in
		()
	     end)
val rec
   init: unit -> unit = 
      (fn x_1715: unit =>
       case x_1715 of
	 (()) => (setCurrent (make (getCurrent gcState))))
val _ =
   case (not isOn) of
     true => ()
   | false =>
     let val _ =
	    (addNew_0 (atExit,
		       (fn x_1717: unit =>
			case x_1717 of
			  () =>
			  (done gcState)
			  ;(write ((current ()), "mlmon.out"))
			  ;((app_0 (MLtonProfile.Data.t) (fn x_1718: MLtonProfile.Data.t =>
							  case x_1718 of
							    d: MLtonProfile.Data.t =>
							    (free (gcState,
								   (raw d))))) (!_1 (MLtonProfile.Data.t list) all)))))
	 val _ =
	    (addNew_0 (atLoadWorld,
		       (fn x_1716: unit =>
			case x_1716 of
			  () =>
			  (:=_1 (MLtonProfile.Data.t list) (all, [])) ;(init ()))))
     in
	(init ())
     end
datatype 'a MLtonFinalizable.t = T of {afters: (unit -> unit) list ref,
				       finalizers: ('a -> unit) list ref,
				       value: 'a ref}
datatype MLtonWorld.status = Clone
			     | Original
val _ =
   (setHandler defaultTopLevelHandler (unit))
   ;(setSuffix defaultTopLevelSuffix (unit))
exception UNKNOWN
datatype SMLofNJ.SysInfo.os_kind = BEOS
				   | MACOS
				   | OS2
				   | UNIX
				   | WIN32
val it: unit = (print "Hello, world
")
