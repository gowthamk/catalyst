(*  User declarations section for helper functions *)
open Spec
open RelLang
structure TypeSpec = RelSpec.TypeSpec
structure RefTy = RefinementType
val defaultCons = Con.default
val symbase = "sp_"
val count = ref 0
val genVar = fn _ => 
  let val id = symbase ^ (Int.toString (!count))
      val _ = count := !count + 1
  in
    Var.fromString id 
  end
fun $ (f,arg) = f arg
infixr 5 $
%%
(* ML Yacc Declarations *)
%name Spec (* tokens signature will be Spec_TOKENS *)
(* 
  The structure Token is defined by LrParser structure provided 
  by ml-yacc-lib  
*)
%header (functor SpecLrValsFun (structure Token : TOKEN
                                structure Spec : SPEC_LANG) : Spec_LRVALS)
%verbose
%eop EOF
%noshift EOF
%pos int
(* 
  Lex functor is constructed to expect TOKENS signature 
  constructed from following declarations
 *)
%term   RELATION
      | TRUE
      | FALSE
      | PLUS
      | MINUS
      | UNION
      | CROSSPRD
      | SUBSETEQ
      | SUBSET
      | EQUALOP
      | IFF
      | CONJ
      | COLON
      | SEMICOLON
      | COMMA
      | STAR
      | LPAREN
      | RPAREN
      | LCURLY
      | RCURLY
      | LBRACE
      | RBRACE
      | ARROW
      | PIPE
      | DOT
      | VAR
      | ID of string
      | INT of int
      | EOF

%nonterm start of RelSpec.t
  | spec of RelSpec.t
  | decsandtys of RelSpec.t
  | reldec of StructuralRelation.t
  | params of RelVar.t list
  | paramseq of RelVar.t list
  | patmatchseq of (Pat.t * term) list
  | patmatch of Pat.t * term
  | pat of Pat.t
  | valpat of Pat.value
  | conargs of Var.t vector
  | idseq of Var.t list
  | iterm of term
  | rterm of term
  | instexpr of instexpr
  | varop of Var.t option
  | ieatoms of ieatom list
  | ieatom of ieatom
  | rexpr of expr
  | ratom of expr
  | elem of elem
  | elemseq of elem list
  | typespec of TypeSpec.t 
  | refty of RefinementType.t
  | reftyatom of RefinementType.t 
  | vartyatom of Var.t * RefinementType.t 
  | vartyseq of (Var.t * RefinementType.t) list
  | varty of Var.t * RefinementType.t 
  | basety of RefinementType.t
  | pred of Predicate.t
  | relpred of Predicate.RelPredicate.t
  | rpatom of Predicate.RelPredicate.t
%verbose
%pure

%%
(* BNF Rules *)
start : spec (spec)

spec:   decsandtys (decsandtys)

decsandtys : reldec SEMICOLON decsandtys 
                (case decsandtys of RelSpec.T ({reldecs,typespecs}) => 
                    RelSpec.T {reldecs = Vector.fromList (reldec ::
                      (Vector.toList reldecs)), typespecs = typespecs})
           | typespec SEMICOLON decsandtys
                (case decsandtys of RelSpec.T {reldecs,typespecs} => 
                    RelSpec.T {reldecs = reldecs, typespecs = 
                    Vector.fromList (typespec :: (Vector.toList typespecs))})
           |  (RelSpec.T {reldecs = Vector.fromList [],
                  typespecs = Vector.fromList []})

reldec : RELATION ID patmatchseq  (* 6 *)
          (StructuralRelation.T {id=RelId.fromString ID,
                params = Vector.new0 (),
                map = Vector.fromList (List.map (patmatchseq,
                  fn (pat,rterm) => (SOME pat,rterm)))})
       | RELATION LPAREN ID params RPAREN patmatchseq 
          (StructuralRelation.T {id=RelId.fromString ID,
                params = Vector.fromList params,
                map = Vector.fromList (List.map (patmatchseq,
                  fn (pat,rterm) => (SOME pat,rterm)))})
       | RELATION ID EQUALOP iterm
          (StructuralRelation.T{id=RelId.fromString ID,
                params = Vector.new0 (),
                map = Vector.fromList [(NONE,iterm)]})
       | RELATION LPAREN ID params RPAREN EQUALOP iterm
          (StructuralRelation.T{id=RelId.fromString ID,
                params = Vector.fromList params,
                map = Vector.fromList [(NONE,iterm)]})

params : ID ([RelVar.fromString ID])
       | ID params ((RelVar.fromString ID)::params)

paramseq : ID ([RelVar.fromString ID])
       | ID COMMA paramseq ((RelVar.fromString ID)::paramseq)

patmatchseq : patmatch PIPE patmatchseq (patmatch :: patmatchseq)
            | patmatch ([patmatch])

patmatch : pat EQUALOP rexpr (pat, Atom (Re rexpr))

(* 
 * Syntactic convention - an Id in isolation is a nullary cons.
 * Unary tuple is interpreted as a variable.
 *)

pat : ID (Pat.Con (Con.fromString ID, NONE))
    | LPAREN ID valpat RPAREN (Pat.Con (Con.fromString ID, SOME valpat))
    | valpat (Pat.Value valpat)

valpat : LPAREN idseq RPAREN (case idseq of 
              [x] => Pat.Var x
            | _ => Pat.Tuple (Vector.fromList idseq))
       | LCURLY idseq RPAREN (Pat.Record (Record.fromVector
          (Vector.fromList (List.map (idseq, fn x => 
            (Field.Symbol (Field.Symbol.fromString (Var.toString x)), x)))) ))

idseq : ID ([Var.fromString ID]) (* 19 *)
      | ID COMMA idseq ((Var.fromString ID)::idseq)

iterm : ieatom (Atom ieatom)
      | instexpr STAR (Star instexpr)

(* All relations parsed as concrete relations *)
instexpr : ID (Relation (RelId.fromString ID))
         | ID ieatoms (Inst {args = 
                Vector.fromList ieatoms, rel = RelId.fromString ID})

ieatoms : LBRACE ieatom RBRACE ([ieatom])
        | LBRACE ieatom RBRACE ieatoms (ieatom :: ieatoms) (* 25 *)

ieatom : instexpr (Ie instexpr) (* 26 *)
       | ratom (Re ratom)

rexpr : ratom CROSSPRD rexpr (X(ratom,rexpr))
      | ratom UNION rexpr (U(ratom,rexpr))
      | ratom (ratom)

ratom : LCURLY LPAREN RPAREN RCURLY (T (Vector.fromList []))
      | LCURLY LPAREN elemseq RPAREN RCURLY 
          (T (Vector.fromList elemseq))
      | instexpr LPAREN varop RPAREN (case (instexpr,varop) of 
            (Relation rid, NONE) => R1 (RelVar.fromString 
                (RelId.toString rid))
          | (_,SOME v) => R2 (instexpr,v)
          | _ => raise (Fail "Missing arguments for an \
            \ instantiated relation\n"))
      | LPAREN rexpr RPAREN (rexpr)

varop : ID (SOME (Var.fromString ID))
      |    (NONE)

elemseq : elem ([elem])
        | elem COMMA elemseq (elem::elemseq)

elem : INT (Int(INT)) 
     | TRUE (Bool(true))
     | FALSE (Bool(false))
     | ID (Var(Var.fromString ID))

typespec : ID COLON refty (TypeSpec.T {name = Var.fromString ID,
                  params = Vector.new0 (), refty = refty})
         | LPAREN paramseq RPAREN ID COLON refty (TypeSpec.T {
                  name = Var.fromString ID,
                  params = Vector.fromList paramseq, refty = refty})

(* alphaRename tyatom to avoid name clashes *)
refty : reftyatom (reftyatom)
      | vartyatom ARROW refty (RefTy.Arrow (vartyatom, refty))

reftyatom : basety (basety)
          | LPAREN vartyseq RPAREN  (case vartyseq of
                          [(v, refty as RefTy.Base _)] => 
                              RefTy.alphaRenameToVar refty v
                        | [(v,refty)] => refty
                        | _ => RefTy.Tuple (Vector.fromList vartyseq))

vartyatom : basety (case basety of 
                      RefTy.Base (v,_,_) => (v,RefTy.alphaRename basety)
                    | _ => Error.bug "Impossible case of basety")
          | LPAREN vartyseq RPAREN  (case vartyseq of
                          [x] => x 
                        | _ => (genVar (), RefTy.Tuple 
                            (Vector.fromList vartyseq)))

vartyseq : varty ([varty])
         | varty COMMA vartyseq (varty :: vartyseq)

varty : refty (let open RefTy in case refty of 
                          Base (v,_,_) => (v,alphaRename refty)
                        | Tuple _ => (genVar (),refty)
                        | Arrow _ => (genVar (),refty)
                        end)

(* Needs extension to specify ML type *)
basety : ID (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), 
                Predicate.truee()))
       | LCURLY ID RCURLY (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), 
                Predicate.truee()))
       | LCURLY ID PIPE pred RCURLY (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), pred))

(* Needs extension for base predicates *)
pred :  TRUE (Predicate.truee()) 
     |  rpatom (Predicate.Rel rpatom)
     |  rpatom CONJ pred (Predicate.conjR (pred,rpatom))

rpatom : rexpr EQUALOP rexpr (Predicate.RelPredicate.Eq(rexpr1,rexpr2))
       | rexpr SUBSET rexpr (Predicate.RelPredicate.Sub(rexpr1,rexpr2))
       | rexpr SUBSETEQ rexpr (Predicate.RelPredicate.SubEq(rexpr1,rexpr2))
