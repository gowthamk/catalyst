(*  User declarations section for helper functions *)
open Spec
open RelLang
structure TypeSpec = RelSpec.TypeSpec
structure RefTy = RefinementType
structure SR = StructuralRelation
val defaultCons = Con.default
val symbase = "sp_"
val count = ref 0
val genVar = fn _ => 
  let val id = symbase ^ (Int.toString (!count))
      val _ = count := !count + 1
  in
    Var.fromString id 
  end
fun $ (f,arg) = f arg
infixr 5 $
%%
(* ML Yacc Declarations *)
%name Spec (* tokens signature will be Spec_TOKENS *)
(* 
  The structure Token is defined by LrParser structure provided 
  by ml-yacc-lib  
*)
%header (functor SpecLrValsFun (structure Token : TOKEN
                                structure Spec : SPEC_LANG) : Spec_LRVALS)
%verbose
%eop EOF
%noshift EOF
%pos int
(* 
  Lex functor is constructed to expect TOKENS signature 
  constructed from following declarations
 *)
%term   RELATION
      | TRUE
      | FALSE
      | PLUS
      | MINUS
      | UNION
      | CROSSPRD
      | SUBSETEQ
      | SUBSET
      | EQUALOP
      | IFF
      | CONJ
      | COLON
      | SEMICOLON
      | COMMA
      | STAR
      | LPAREN
      | RPAREN
      | LCURLY
      | RCURLY
      | LBRACE
      | RBRACE
      | ARROW
      | PIPE
      | DOT
      | VAR
      | ID of string
      | INT of int
      | EOF

%nonterm start of RelSpec.t
  | spec of RelSpec.t
  | decsandtys of RelSpec.t
  | reldec of StructuralRelation.t
  | params of RelId.t list
  | patmatchseq of (StructuralRelation.Pat.t * term) list
  | patmatch of StructuralRelation.Pat.t * term
  | pat of StructuralRelation.Pat.t
  | valpat of StructuralRelation.Pat.value
  | conargs of Var.t vector
  | idseq of Var.t list
  | starterm of term
  | rterm of term
  | instexpr of instexpr
  | ieatoms of ieatom list
  | ieatom of ieatom
  | rexpr of expr
  | ratom of expr
  | elem of elem
  | elemseq of elem list
  | typespec of TypeSpec.t 
  | refty of RefinementType.t
  | reftyseq of RefinementType.t list
  | vartyatom of Var.t * RefinementType.t
  | vartyatomseq of (Var.t * RefTy.t) list
  | tyatom of RefinementType.t
  | basety of RefinementType.t
  | pred of Predicate.t
  | relpred of Predicate.RelPredicate.t
  | rpatom of Predicate.RelPredicate.t
%verbose
%pure

%%
(* BNF Rules *)
start : spec (spec)

spec:   decsandtys (decsandtys)

decsandtys : reldec SEMICOLON decsandtys 
                (case decsandtys of RelSpec.T ({reldecs,typespecs}) => 
                    RelSpec.T {reldecs = Vector.fromList (reldec ::
                      (Vector.toList reldecs)), typespecs = typespecs})
           | typespec SEMICOLON decsandtys
                (case decsandtys of RelSpec.T {reldecs,typespecs} => 
                    RelSpec.T {reldecs = reldecs, typespecs = 
                    Vector.fromList (typespec :: (Vector.toList typespecs))})
           |  (RelSpec.T {reldecs = Vector.fromList [],
                  typespecs = Vector.fromList []})

reldec : RELATION ID patmatchseq  (* 6 *)
          (StructuralRelation.T {id=RelId.fromString ID,
                params = Vector.new0 (),
                map = Vector.fromList (List.map (patmatchseq,
                  fn (pat,rterm) => (SOME pat,rterm)))})
       | RELATION LPAREN ID params RPAREN patmatchseq 
          (StructuralRelation.T {id=RelId.fromString ID,
                params = Vector.fromList params,
                map = Vector.fromList (List.map (patmatchseq,
                  fn (pat,rterm) => (SOME pat,rterm)))})
       | RELATION ID EQUALOP starterm
          (StructuralRelation.T{id=RelId.fromString ID,
                params = Vector.new0 (),
                map = Vector.fromList [(NONE,starterm)]})
       | RELATION LPAREN ID params RPAREN EQUALOP starterm
          (StructuralRelation.T{id=RelId.fromString ID,
                params = Vector.fromList params,
                map = Vector.fromList [(NONE,starterm)]})

params : ID ([RelId.fromString ID])
       | ID params ((RelId.fromString ID)::params)

patmatchseq : patmatch PIPE patmatchseq (patmatch :: patmatchseq)
            | patmatch ([patmatch])

patmatch : LPAREN pat RPAREN EQUALOP rexpr (pat,Expr rexpr)

pat : VAR ID (SR.Pat.Value (SR.Pat.Var (Var.fromString ID)))
    | ID (SR.Pat.Con (Con.fromString ID, NONE))
    | valpat (SR.Pat.Value valpat)

valpat : LPAREN idseq RPAREN (SR.Pat.Tuple (Vector.fromList idseq))
       | LCURLY idseq RPAREN (SR.Pat.Record (Record.fromVector
          (Vector.fromList (List.map (idseq, fn x => 
            (Field.Symbol (Field.Symbol.fromString (Var.toString x)), x)))) ))

idseq : ID ([Var.fromString ID]) (* 19 *)
      | ID COMMA idseq ((Var.fromString ID)::idseq)

starterm : instexpr STAR (Star instexpr)

instexpr : ID (Simple (RelId.fromString ID))
         | ID ieatoms (Inst {params = 
                Vector.fromList ieatoms, rel = RelId.fromString ID})

ieatoms : LBRACE ieatom RBRACE ([ieatom])
        | LBRACE ieatom RBRACE ieatoms (ieatom :: ieatoms) (* 25 *)

ieatom : instexpr (Ie instexpr) (* 26 *)
       | ratom (Re ratom)

rexpr : ratom CROSSPRD rexpr (X(ratom,rexpr))
      | ratom UNION rexpr (U(ratom,rexpr))
      | ratom (ratom)

ratom : LCURLY LPAREN RPAREN RCURLY (T(Vector.fromList []))
      | LCURLY LPAREN elemseq RPAREN RCURLY 
          (T(Vector.fromList elemseq))
      | instexpr LPAREN ID RPAREN (R(instexpr, Var.fromString ID))
      | LPAREN rexpr RPAREN (rexpr)

elemseq : elem ([elem])
        | elem COMMA elemseq (elem::elemseq)

elem : INT (Int(INT)) 
     | TRUE (Bool(true))
     | FALSE (Bool(false))
     | ID (Var(Var.fromString ID))

typespec : ID COLON refty (TypeSpec.T {name = Var.fromString ID,
                  params = Vector.new0 (), refty = refty})
         | LPAREN params RPAREN ID COLON refty (TypeSpec.T {
                  name = Var.fromString ID,
                  params = Vector.fromList params, refty = refty})

(* alphaRename tyatom to avoid name clashes *)
refty : tyatom (case tyatom of RefTy.Base _ => RefTy.alphaRename tyatom
                    | _ => tyatom)
      | vartyatom ARROW refty (RefinementType.Arrow(vartyatom,refty))

vartyatom : tyatom (let open RefTy in case tyatom of 
                      Base (v,_,_) => (v,alphaRename tyatom)
                    | Tuple _ => (genVar (),tyatom)
                    | Arrow _ => (genVar (),tyatom)
                    end)

vartyatomseq : vartyatom ([vartyatom])
             | vartyatom COMMA vartyatomseq (vartyatom ::
                  vartyatomseq)

tyatom : basety (basety) (* 53 *)
       | LPAREN vartyatomseq RPAREN (case vartyatomseq of 
                  [(v,refty)] => refty
                | _ => RefTy.Tuple (Vector.fromList vartyatomseq))

(* Needs extension to specify ML type *)
basety : ID (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), 
                Predicate.truee()))
       | LCURLY ID RCURLY (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), 
                Predicate.truee()))
       | LCURLY ID PIPE pred RCURLY (RefinementType.Base ((Var.fromString ID), 
                TypeDesc.makeTunknown(), pred))

(* Needs extension for base predicates *)
pred :  TRUE (Predicate.truee()) 
     |  rpatom (Predicate.Rel rpatom)
     |  rpatom CONJ pred (Predicate.conjR (pred,rpatom))

rpatom : rexpr EQUALOP rexpr (Predicate.RelPredicate.Eq(rexpr1,rexpr2))
       | rexpr SUBSET rexpr (Predicate.RelPredicate.Sub(rexpr1,rexpr2))
       | rexpr SUBSETEQ rexpr (Predicate.RelPredicate.SubEq(rexpr1,rexpr2))
