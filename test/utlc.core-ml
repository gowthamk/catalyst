MLton 20100608 (built Tue Jun  8 16:05:08 EDT 2010 on zaphod.cs.rit.edu)
  created this file on Fri Feb 14 18:00:56 2014.
Do not edit this file.
Flag settings: 
   align: 8
   atMLtons: (utlc, @MLton, --)
   chunk: chunk per function
   closureConvertGlobalize: true
   closureConvertShrink: true
   codegen: amd64
   contifyIntoMain: false
   debug: false
   defaultChar: char8
   defaultWideChar: widechar32
   defaultInt: int32
   defaultReal: real64
   defaultWord: word32
   diag passes: []
   drop passes: []
   elaborate allowConstant (default): false
   elaborate allowConstant (enabled): true
   elaborate allowFFI (default): false
   elaborate allowFFI (enabled): true
   elaborate allowPrim (default): false
   elaborate allowPrim (enabled): true
   elaborate allowOverload (default): false
   elaborate allowOverload (enabled): true
   elaborate allowRebindEquals (default): false
   elaborate allowRebindEquals (enabled): true
   elaborate deadCode (default): false
   elaborate deadCode (enabled): true
   elaborate forceUsed (default): false
   elaborate forceUsed (enabled): true
   elaborate ffiStr (default): 
   elaborate ffiStr (enabled): true
   elaborate nonexhaustiveExnMatch (default): default
   elaborate nonexhaustiveExnMatch (enabled): true
   elaborate nonexhaustiveMatch (default): warn
   elaborate nonexhaustiveMatch (enabled): true
   elaborate redundantMatch (default): warn
   elaborate redundantMatch (enabled): true
   elaborate sequenceNonUnit (default): ignore
   elaborate sequenceNonUnit (enabled): true
   elaborate warnUnused (default): false
   elaborate warnUnused (enabled): true
   elaborate only: false
   emit main: true
   export header: None
   exn history: false
   generated output format: executable
   gc check: Limit
   indentation: 3
   inlineIntoMain: true
   inlineLeafA: {loops = true, repeat = true, size = Some 20}
   inlineLeafB: {loops = true, repeat = true, size = Some 40}
   inlineNonRec: {small = 60, product = 320}
   input file: utlc.core-ml
   keep CoreML: true
   keep def use: true
   keep dot: false
   keep Machine: false
   keep passes: []
   keep RSSA: false
   keep SSA: false
   keep SSA2: false
   keep SXML: false
   keep XML: false
   extra_: true
   lib dir: /Users/gowtham/git/mlton/newexecs/usr/local/lib/mlton
   lib target dir: /Users/gowtham/git/mlton/newexecs/usr/local/lib/mlton/targets/self
   loop passes: 1
   mark cards: true
   max function size: 10000
   mlb path vars: [{var = MLTON_ROOT, path = $(LIB_MLTON_DIR)/sml}, {var = SML_LIB, path = $(LIB_MLTON_DIR)/sml}]
   native commented: 0
   native live stack: false
   native optimize: 1
   native move hoist: true
   native copy prop: true
   native copy prop cutoff: 1000
   native cutoff: 100
   native live transfer: 8
   native shuffle: true
   native ieee fp: false
   native split: Some 20000
   optimizationPasses: [<ssa2::default>, <ssa::default>, <sxml::default>, <xml::default>]
   polyvariance: Some {hofo = true, rounds = 2, small = 30, product = 300}
   prefer abs paths: false
   prof passes: []
   profile: None
   profile branch: false
   profile C: []
   profile IL: ProfileSource
   profile include/exclude: [(Seq [Star [.], Or [Seq [Seq [[$], [(], [S], [M], [L], [_], [L], [I], [B], [)]]]], Star [.]], false)]
   profile raise: false
   profile stack: false
   profile val: false
   show basis: None
   show def-use: None
   show types: true
   target: self
   target arch: AMD64
   target OS: Darwin
   type check: false
   verbosity: Silent
   warn unrecognized annotation: true
   warn deprecated features: true
   zone cut depth: 100


Decs:
datatype bool = false
		| true
	 'a_0 list = nil
		     | :: of 'a_0 * 'a_0 list
	 'a_1 ref = ref of 'a_1
exception Bind
exception Match
exception Overflow
val rec
   not: bool -> bool = 
      (fn x_0: bool =>
       case x_0 of
	 (b: bool) => case b of true => false | false => true)
val detectOverflow: bool = 0x1
val safe: bool = 0x1
val name: exn -> string = (fn x_1: exn => Exn_name (x_1))
exception Div
exception Domain
exception Fail8 of string
exception Fail16 of char16 vector
exception Fail32 of char32 vector
exception Overflow
exception Size
exception Subscript
val ('b, 'a) wrapOverflow: ('a -> 'b) -> 'a -> 'b =
   (fn x_2: 'a -> 'b =>
    case x_2 of
      f: 'a -> 'b =>
      (fn x_3: 'a =>
       case x_3 of
	 a: 'a => (f a) handle x_4 => case x_4 of Overflow => raise Overflow))
datatype Primitive.Order.t = LESS
			     | EQUAL
			     | GREATER
datatype 'a Primitive.Option.t = NONE
				 | SOME of 'a
val 'a deref: 'a ref -> 'a = (fn x_5: 'a ref => Ref_deref['a] (x_5))
val 'a assign: 'a ref * 'a -> unit =
   (fn x_6: 'a ref * 'a =>
    case x_6 of
      (x_8: 'a ref, x_7: 'a) => Ref_assign['a] (x_8, x_7))
val setHandler: (exn -> unit) -> unit =
   (fn x_9: exn -> unit =>
    TopLevel_setHandler (x_9))
val setSuffix: (unit -> unit) -> unit =
   (fn x_10: unit -> unit =>
    TopLevel_setSuffix (x_10))
val not: bool -> bool = not
val ''a =: ''a * ''a -> bool =
   (fn x_11: ''a * ''a =>
    case x_11 of
      (x_13: ''a, x_12: ''a) => MLton_equal[''a] (x_13, x_12))
val ''a_2 <>: ''a_2 * ''a_2 -> bool =
   (fn x_14: ''a_2 * ''a_2 =>
    case x_14 of
      (x: ''a_2, y: ''a_2) => (not (= (''a_2) (x, y))))
val idFromInt8ToWord8: int8 -> word8 =
   (fn x_15: int8 =>
    WordU8_extdToWord8 (x_15))
val idFromInt16ToWord16: int16 -> word16 =
   (fn x_16: int16 =>
    WordU16_extdToWord16 (x_16))
val idFromInt32ToWord32: int32 -> word32 =
   (fn x_17: int32 =>
    WordU32_extdToWord32 (x_17))
val idFromInt64ToWord64: int64 -> word64 =
   (fn x_18: int64 =>
    WordU64_extdToWord64 (x_18))
val idFromWord8ToInt8: word8 -> int8 =
   (fn x_19: word8 =>
    WordU8_extdToWord8 (x_19))
val idFromWord16ToInt16: word16 -> int16 =
   (fn x_20: word16 =>
    WordU16_extdToWord16 (x_20))
val idFromWord32ToInt32: word32 -> int32 =
   (fn x_21: word32 =>
    WordU32_extdToWord32 (x_21))
val idFromWord64ToInt64: word64 -> int64 =
   (fn x_22: word64 =>
    WordU64_extdToWord64 (x_22))
val zextdFromInt8ToInt8: int8 -> int8 =
   (fn x_23: int8 =>
    WordU8_extdToWord8 (x_23))
val zextdFromInt8ToInt16: int8 -> int16 =
   (fn x_24: int8 =>
    WordU8_extdToWord16 (x_24))
val zextdFromInt8ToInt32: int8 -> int32 =
   (fn x_25: int8 =>
    WordU8_extdToWord32 (x_25))
val zextdFromInt8ToInt64: int8 -> int64 =
   (fn x_26: int8 =>
    WordU8_extdToWord64 (x_26))
val zextdFromInt8ToWord8: int8 -> word8 =
   (fn x_27: int8 =>
    WordU8_extdToWord8 (x_27))
val zextdFromInt8ToWord16: int8 -> word16 =
   (fn x_28: int8 =>
    WordU8_extdToWord16 (x_28))
val zextdFromInt8ToWord32: int8 -> word32 =
   (fn x_29: int8 =>
    WordU8_extdToWord32 (x_29))
val zextdFromInt8ToWord64: int8 -> word64 =
   (fn x_30: int8 =>
    WordU8_extdToWord64 (x_30))
val zextdFromInt16ToInt8: int16 -> int8 =
   (fn x_31: int16 =>
    WordU16_extdToWord8 (x_31))
val zextdFromInt16ToInt16: int16 -> int16 =
   (fn x_32: int16 =>
    WordU16_extdToWord16 (x_32))
val zextdFromInt16ToInt32: int16 -> int32 =
   (fn x_33: int16 =>
    WordU16_extdToWord32 (x_33))
val zextdFromInt16ToInt64: int16 -> int64 =
   (fn x_34: int16 =>
    WordU16_extdToWord64 (x_34))
val zextdFromInt16ToWord8: int16 -> word8 =
   (fn x_35: int16 =>
    WordU16_extdToWord8 (x_35))
val zextdFromInt16ToWord16: int16 -> word16 =
   (fn x_36: int16 =>
    WordU16_extdToWord16 (x_36))
val zextdFromInt16ToWord32: int16 -> word32 =
   (fn x_37: int16 =>
    WordU16_extdToWord32 (x_37))
val zextdFromInt16ToWord64: int16 -> word64 =
   (fn x_38: int16 =>
    WordU16_extdToWord64 (x_38))
val zextdFromInt32ToInt8: int32 -> int8 =
   (fn x_39: int32 =>
    WordU32_extdToWord8 (x_39))
val zextdFromInt32ToInt16: int32 -> int16 =
   (fn x_40: int32 =>
    WordU32_extdToWord16 (x_40))
val zextdFromInt32ToInt32: int32 -> int32 =
   (fn x_41: int32 =>
    WordU32_extdToWord32 (x_41))
val zextdFromInt32ToInt64: int32 -> int64 =
   (fn x_42: int32 =>
    WordU32_extdToWord64 (x_42))
val zextdFromInt32ToWord8: int32 -> word8 =
   (fn x_43: int32 =>
    WordU32_extdToWord8 (x_43))
val zextdFromInt32ToWord16: int32 -> word16 =
   (fn x_44: int32 =>
    WordU32_extdToWord16 (x_44))
val zextdFromInt32ToWord32: int32 -> word32 =
   (fn x_45: int32 =>
    WordU32_extdToWord32 (x_45))
val zextdFromInt32ToWord64: int32 -> word64 =
   (fn x_46: int32 =>
    WordU32_extdToWord64 (x_46))
val zextdFromInt64ToInt8: int64 -> int8 =
   (fn x_47: int64 =>
    WordU64_extdToWord8 (x_47))
val zextdFromInt64ToInt16: int64 -> int16 =
   (fn x_48: int64 =>
    WordU64_extdToWord16 (x_48))
val zextdFromInt64ToInt32: int64 -> int32 =
   (fn x_49: int64 =>
    WordU64_extdToWord32 (x_49))
val zextdFromInt64ToInt64: int64 -> int64 =
   (fn x_50: int64 =>
    WordU64_extdToWord64 (x_50))
val zextdFromInt64ToWord8: int64 -> word8 =
   (fn x_51: int64 =>
    WordU64_extdToWord8 (x_51))
val zextdFromInt64ToWord16: int64 -> word16 =
   (fn x_52: int64 =>
    WordU64_extdToWord16 (x_52))
val zextdFromInt64ToWord32: int64 -> word32 =
   (fn x_53: int64 =>
    WordU64_extdToWord32 (x_53))
val zextdFromInt64ToWord64: int64 -> word64 =
   (fn x_54: int64 =>
    WordU64_extdToWord64 (x_54))
val zextdFromWord8ToInt8: word8 -> int8 =
   (fn x_55: word8 =>
    WordU8_extdToWord8 (x_55))
val zextdFromWord8ToInt16: word8 -> int16 =
   (fn x_56: word8 =>
    WordU8_extdToWord16 (x_56))
val zextdFromWord8ToInt32: word8 -> int32 =
   (fn x_57: word8 =>
    WordU8_extdToWord32 (x_57))
val zextdFromWord8ToInt64: word8 -> int64 =
   (fn x_58: word8 =>
    WordU8_extdToWord64 (x_58))
val zextdFromWord8ToWord8: word8 -> word8 =
   (fn x_59: word8 =>
    WordU8_extdToWord8 (x_59))
val zextdFromWord8ToWord16: word8 -> word16 =
   (fn x_60: word8 =>
    WordU8_extdToWord16 (x_60))
val zextdFromWord8ToWord32: word8 -> word32 =
   (fn x_61: word8 =>
    WordU8_extdToWord32 (x_61))
val zextdFromWord8ToWord64: word8 -> word64 =
   (fn x_62: word8 =>
    WordU8_extdToWord64 (x_62))
val zextdFromWord16ToInt8: word16 -> int8 =
   (fn x_63: word16 =>
    WordU16_extdToWord8 (x_63))
val zextdFromWord16ToInt16: word16 -> int16 =
   (fn x_64: word16 =>
    WordU16_extdToWord16 (x_64))
val zextdFromWord16ToInt32: word16 -> int32 =
   (fn x_65: word16 =>
    WordU16_extdToWord32 (x_65))
val zextdFromWord16ToInt64: word16 -> int64 =
   (fn x_66: word16 =>
    WordU16_extdToWord64 (x_66))
val zextdFromWord16ToWord8: word16 -> word8 =
   (fn x_67: word16 =>
    WordU16_extdToWord8 (x_67))
val zextdFromWord16ToWord16: word16 -> word16 =
   (fn x_68: word16 =>
    WordU16_extdToWord16 (x_68))
val zextdFromWord16ToWord32: word16 -> word32 =
   (fn x_69: word16 =>
    WordU16_extdToWord32 (x_69))
val zextdFromWord16ToWord64: word16 -> word64 =
   (fn x_70: word16 =>
    WordU16_extdToWord64 (x_70))
val zextdFromWord32ToInt8: word32 -> int8 =
   (fn x_71: word32 =>
    WordU32_extdToWord8 (x_71))
val zextdFromWord32ToInt16: word32 -> int16 =
   (fn x_72: word32 =>
    WordU32_extdToWord16 (x_72))
val zextdFromWord32ToInt32: word32 -> int32 =
   (fn x_73: word32 =>
    WordU32_extdToWord32 (x_73))
val zextdFromWord32ToInt64: word32 -> int64 =
   (fn x_74: word32 =>
    WordU32_extdToWord64 (x_74))
val zextdFromWord32ToWord8: word32 -> word8 =
   (fn x_75: word32 =>
    WordU32_extdToWord8 (x_75))
val zextdFromWord32ToWord16: word32 -> word16 =
   (fn x_76: word32 =>
    WordU32_extdToWord16 (x_76))
val zextdFromWord32ToWord32: word32 -> word32 =
   (fn x_77: word32 =>
    WordU32_extdToWord32 (x_77))
val zextdFromWord32ToWord64: word32 -> word64 =
   (fn x_78: word32 =>
    WordU32_extdToWord64 (x_78))
val zextdFromWord64ToInt8: word64 -> int8 =
   (fn x_79: word64 =>
    WordU64_extdToWord8 (x_79))
val zextdFromWord64ToInt16: word64 -> int16 =
   (fn x_80: word64 =>
    WordU64_extdToWord16 (x_80))
val zextdFromWord64ToInt32: word64 -> int32 =
   (fn x_81: word64 =>
    WordU64_extdToWord32 (x_81))
val zextdFromWord64ToInt64: word64 -> int64 =
   (fn x_82: word64 =>
    WordU64_extdToWord64 (x_82))
val zextdFromWord64ToWord8: word64 -> word8 =
   (fn x_83: word64 =>
    WordU64_extdToWord8 (x_83))
val zextdFromWord64ToWord16: word64 -> word16 =
   (fn x_84: word64 =>
    WordU64_extdToWord16 (x_84))
val zextdFromWord64ToWord32: word64 -> word32 =
   (fn x_85: word64 =>
    WordU64_extdToWord32 (x_85))
val zextdFromWord64ToWord64: word64 -> word64 =
   (fn x_86: word64 =>
    WordU64_extdToWord64 (x_86))
val sextdFromInt8ToInt8: int8 -> int8 =
   (fn x_87: int8 =>
    WordS8_extdToWord8 (x_87))
val sextdFromInt8ToInt16: int8 -> int16 =
   (fn x_88: int8 =>
    WordS8_extdToWord16 (x_88))
val sextdFromInt8ToInt32: int8 -> int32 =
   (fn x_89: int8 =>
    WordS8_extdToWord32 (x_89))
val sextdFromInt8ToInt64: int8 -> int64 =
   (fn x_90: int8 =>
    WordS8_extdToWord64 (x_90))
val sextdFromInt8ToWord8: int8 -> word8 =
   (fn x_91: int8 =>
    WordS8_extdToWord8 (x_91))
val sextdFromInt8ToWord16: int8 -> word16 =
   (fn x_92: int8 =>
    WordS8_extdToWord16 (x_92))
val sextdFromInt8ToWord32: int8 -> word32 =
   (fn x_93: int8 =>
    WordS8_extdToWord32 (x_93))
val sextdFromInt8ToWord64: int8 -> word64 =
   (fn x_94: int8 =>
    WordS8_extdToWord64 (x_94))
val sextdFromInt16ToInt8: int16 -> int8 =
   (fn x_95: int16 =>
    WordS16_extdToWord8 (x_95))
val sextdFromInt16ToInt16: int16 -> int16 =
   (fn x_96: int16 =>
    WordS16_extdToWord16 (x_96))
val sextdFromInt16ToInt32: int16 -> int32 =
   (fn x_97: int16 =>
    WordS16_extdToWord32 (x_97))
val sextdFromInt16ToInt64: int16 -> int64 =
   (fn x_98: int16 =>
    WordS16_extdToWord64 (x_98))
val sextdFromInt16ToWord8: int16 -> word8 =
   (fn x_99: int16 =>
    WordS16_extdToWord8 (x_99))
val sextdFromInt16ToWord16: int16 -> word16 =
   (fn x_100: int16 =>
    WordS16_extdToWord16 (x_100))
val sextdFromInt16ToWord32: int16 -> word32 =
   (fn x_101: int16 =>
    WordS16_extdToWord32 (x_101))
val sextdFromInt16ToWord64: int16 -> word64 =
   (fn x_102: int16 =>
    WordS16_extdToWord64 (x_102))
val sextdFromInt32ToInt8: int32 -> int8 =
   (fn x_103: int32 =>
    WordS32_extdToWord8 (x_103))
val sextdFromInt32ToInt16: int32 -> int16 =
   (fn x_104: int32 =>
    WordS32_extdToWord16 (x_104))
val sextdFromInt32ToInt32: int32 -> int32 =
   (fn x_105: int32 =>
    WordS32_extdToWord32 (x_105))
val sextdFromInt32ToInt64: int32 -> int64 =
   (fn x_106: int32 =>
    WordS32_extdToWord64 (x_106))
val sextdFromInt32ToWord8: int32 -> word8 =
   (fn x_107: int32 =>
    WordS32_extdToWord8 (x_107))
val sextdFromInt32ToWord16: int32 -> word16 =
   (fn x_108: int32 =>
    WordS32_extdToWord16 (x_108))
val sextdFromInt32ToWord32: int32 -> word32 =
   (fn x_109: int32 =>
    WordS32_extdToWord32 (x_109))
val sextdFromInt32ToWord64: int32 -> word64 =
   (fn x_110: int32 =>
    WordS32_extdToWord64 (x_110))
val sextdFromInt64ToInt8: int64 -> int8 =
   (fn x_111: int64 =>
    WordS64_extdToWord8 (x_111))
val sextdFromInt64ToInt16: int64 -> int16 =
   (fn x_112: int64 =>
    WordS64_extdToWord16 (x_112))
val sextdFromInt64ToInt32: int64 -> int32 =
   (fn x_113: int64 =>
    WordS64_extdToWord32 (x_113))
val sextdFromInt64ToInt64: int64 -> int64 =
   (fn x_114: int64 =>
    WordS64_extdToWord64 (x_114))
val sextdFromInt64ToWord8: int64 -> word8 =
   (fn x_115: int64 =>
    WordS64_extdToWord8 (x_115))
val sextdFromInt64ToWord16: int64 -> word16 =
   (fn x_116: int64 =>
    WordS64_extdToWord16 (x_116))
val sextdFromInt64ToWord32: int64 -> word32 =
   (fn x_117: int64 =>
    WordS64_extdToWord32 (x_117))
val sextdFromInt64ToWord64: int64 -> word64 =
   (fn x_118: int64 =>
    WordS64_extdToWord64 (x_118))
val sextdFromWord8ToInt8: word8 -> int8 =
   (fn x_119: word8 =>
    WordS8_extdToWord8 (x_119))
val sextdFromWord8ToInt16: word8 -> int16 =
   (fn x_120: word8 =>
    WordS8_extdToWord16 (x_120))
val sextdFromWord8ToInt32: word8 -> int32 =
   (fn x_121: word8 =>
    WordS8_extdToWord32 (x_121))
val sextdFromWord8ToInt64: word8 -> int64 =
   (fn x_122: word8 =>
    WordS8_extdToWord64 (x_122))
val sextdFromWord8ToWord8: word8 -> word8 =
   (fn x_123: word8 =>
    WordS8_extdToWord8 (x_123))
val sextdFromWord8ToWord16: word8 -> word16 =
   (fn x_124: word8 =>
    WordS8_extdToWord16 (x_124))
val sextdFromWord8ToWord32: word8 -> word32 =
   (fn x_125: word8 =>
    WordS8_extdToWord32 (x_125))
val sextdFromWord8ToWord64: word8 -> word64 =
   (fn x_126: word8 =>
    WordS8_extdToWord64 (x_126))
val sextdFromWord16ToInt8: word16 -> int8 =
   (fn x_127: word16 =>
    WordS16_extdToWord8 (x_127))
val sextdFromWord16ToInt16: word16 -> int16 =
   (fn x_128: word16 =>
    WordS16_extdToWord16 (x_128))
val sextdFromWord16ToInt32: word16 -> int32 =
   (fn x_129: word16 =>
    WordS16_extdToWord32 (x_129))
val sextdFromWord16ToInt64: word16 -> int64 =
   (fn x_130: word16 =>
    WordS16_extdToWord64 (x_130))
val sextdFromWord16ToWord8: word16 -> word8 =
   (fn x_131: word16 =>
    WordS16_extdToWord8 (x_131))
val sextdFromWord16ToWord16: word16 -> word16 =
   (fn x_132: word16 =>
    WordS16_extdToWord16 (x_132))
val sextdFromWord16ToWord32: word16 -> word32 =
   (fn x_133: word16 =>
    WordS16_extdToWord32 (x_133))
val sextdFromWord16ToWord64: word16 -> word64 =
   (fn x_134: word16 =>
    WordS16_extdToWord64 (x_134))
val sextdFromWord32ToInt8: word32 -> int8 =
   (fn x_135: word32 =>
    WordS32_extdToWord8 (x_135))
val sextdFromWord32ToInt16: word32 -> int16 =
   (fn x_136: word32 =>
    WordS32_extdToWord16 (x_136))
val sextdFromWord32ToInt32: word32 -> int32 =
   (fn x_137: word32 =>
    WordS32_extdToWord32 (x_137))
val sextdFromWord32ToInt64: word32 -> int64 =
   (fn x_138: word32 =>
    WordS32_extdToWord64 (x_138))
val sextdFromWord32ToWord8: word32 -> word8 =
   (fn x_139: word32 =>
    WordS32_extdToWord8 (x_139))
val sextdFromWord32ToWord16: word32 -> word16 =
   (fn x_140: word32 =>
    WordS32_extdToWord16 (x_140))
val sextdFromWord32ToWord32: word32 -> word32 =
   (fn x_141: word32 =>
    WordS32_extdToWord32 (x_141))
val sextdFromWord32ToWord64: word32 -> word64 =
   (fn x_142: word32 =>
    WordS32_extdToWord64 (x_142))
val sextdFromWord64ToInt8: word64 -> int8 =
   (fn x_143: word64 =>
    WordS64_extdToWord8 (x_143))
val sextdFromWord64ToInt16: word64 -> int16 =
   (fn x_144: word64 =>
    WordS64_extdToWord16 (x_144))
val sextdFromWord64ToInt32: word64 -> int32 =
   (fn x_145: word64 =>
    WordS64_extdToWord32 (x_145))
val sextdFromWord64ToInt64: word64 -> int64 =
   (fn x_146: word64 =>
    WordS64_extdToWord64 (x_146))
val sextdFromWord64ToWord8: word64 -> word8 =
   (fn x_147: word64 =>
    WordS64_extdToWord8 (x_147))
val sextdFromWord64ToWord16: word64 -> word16 =
   (fn x_148: word64 =>
    WordS64_extdToWord16 (x_148))
val sextdFromWord64ToWord32: word64 -> word32 =
   (fn x_149: word64 =>
    WordS64_extdToWord32 (x_149))
val sextdFromWord64ToWord64: word64 -> word64 =
   (fn x_150: word64 =>
    WordS64_extdToWord64 (x_150))
val sizeInBits: int32 = 0x1
val sizeInBits: int32 = 0x2
val sizeInBits: int32 = 0x3
val sizeInBits: int32 = 0x4
val sizeInBits: int32 = 0x5
val sizeInBits: int32 = 0x6
val sizeInBits: int32 = 0x7
val sizeInBits: int32 = 0x8
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val <<?: word8 * word32 -> word8 =
   (fn x_151: word8 * word32 =>
    case x_151 of
      (x_153: word8, x_152: word32) => Word8_lshift (x_153, x_152))
val ~: word8 -> word8 = (fn x_154: word8 => Word8_neg (x_154))
val notb: word8 -> word8 = (fn x_155: word8 => Word8_notb (x_155))
val orb: word8 * word8 -> word8 =
   (fn x_156: word8 * word8 =>
    case x_156 of
      (x_158: word8, x_157: word8) => Word8_orb (x_158, x_157))
val ~>>?: word8 * word32 -> word8 =
   (fn x_159: word8 * word32 =>
    case x_159 of
      (x_161: word8, x_160: word32) => WordS8_rshift (x_161, x_160))
val >>?: word8 * word32 -> word8 =
   (fn x_162: word8 * word32 =>
    case x_162 of
      (x_164: word8, x_163: word32) => WordU8_rshift (x_164, x_163))
val sizeInBits: int32 = 0x9
val sizeInBits: int32 = 0xA
val sizeInBits: int32 = 0xB
val sizeInBits: int32 = 0xC
val sizeInBits: int32 = 0xD
val sizeInBits: int32 = 0xE
val sizeInBits: int32 = 0xF
val sizeInBits: int32 = 0x10
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val <<?: word16 * word32 -> word16 =
   (fn x_165: word16 * word32 =>
    case x_165 of
      (x_167: word16, x_166: word32) => Word16_lshift (x_167, x_166))
val ~: word16 -> word16 = (fn x_168: word16 => Word16_neg (x_168))
val notb: word16 -> word16 = (fn x_169: word16 => Word16_notb (x_169))
val orb: word16 * word16 -> word16 =
   (fn x_170: word16 * word16 =>
    case x_170 of
      (x_172: word16, x_171: word16) => Word16_orb (x_172, x_171))
val ~>>?: word16 * word32 -> word16 =
   (fn x_173: word16 * word32 =>
    case x_173 of
      (x_175: word16, x_174: word32) => WordS16_rshift (x_175, x_174))
val >>?: word16 * word32 -> word16 =
   (fn x_176: word16 * word32 =>
    case x_176 of
      (x_178: word16, x_177: word32) => WordU16_rshift (x_178, x_177))
val sizeInBits: int32 = 0x11
val sizeInBits: int32 = 0x12
val sizeInBits: int32 = 0x13
val sizeInBits: int32 = 0x14
val sizeInBits: int32 = 0x15
val sizeInBits: int32 = 0x16
val sizeInBits: int32 = 0x17
val sizeInBits: int32 = 0x18
val sizeInBits: int32 = 0x19
val sizeInBits: int32 = 0x1A
val sizeInBits: int32 = 0x1B
val sizeInBits: int32 = 0x1C
val sizeInBits: int32 = 0x1D
val sizeInBits: int32 = 0x1E
val sizeInBits: int32 = 0x1F
val sizeInBits: int32 = 0x20
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val +: word32 * word32 -> word32 =
   (fn x_179: word32 * word32 =>
    case x_179 of
      (x_181: word32, x_180: word32) => Word32_add (x_181, x_180))
val andb: word32 * word32 -> word32 =
   (fn x_182: word32 * word32 =>
    case x_182 of
      (x_184: word32, x_183: word32) => Word32_andb (x_184, x_183))
val <<?: word32 * word32 -> word32 =
   (fn x_185: word32 * word32 =>
    case x_185 of
      (x_187: word32, x_186: word32) => Word32_lshift (x_187, x_186))
val ~: word32 -> word32 = (fn x_188: word32 => Word32_neg (x_188))
val notb: word32 -> word32 = (fn x_189: word32 => Word32_notb (x_189))
val orb: word32 * word32 -> word32 =
   (fn x_190: word32 * word32 =>
    case x_190 of
      (x_192: word32, x_191: word32) => Word32_orb (x_192, x_191))
val ~>>?: word32 * word32 -> word32 =
   (fn x_193: word32 * word32 =>
    case x_193 of
      (x_195: word32, x_194: word32) => WordS32_rshift (x_195, x_194))
val >>?: word32 * word32 -> word32 =
   (fn x_196: word32 * word32 =>
    case x_196 of
      (x_198: word32, x_197: word32) => WordU32_rshift (x_198, x_197))
val -: word32 * word32 -> word32 =
   (fn x_199: word32 * word32 =>
    case x_199 of
      (x_201: word32, x_200: word32) => Word32_sub (x_201, x_200))
val xorb: word32 * word32 -> word32 =
   (fn x_202: word32 * word32 =>
    case x_202 of
      (x_204: word32, x_203: word32) => Word32_xorb (x_204, x_203))
val <: word32 * word32 -> bool =
   (fn x_205: word32 * word32 =>
    case x_205 of
      (x_207: word32, x_206: word32) => WordU32_lt (x_207, x_206))
val <: word32 * word32 -> bool = <
val rec
   <=: word32 * word32 -> bool = 
      (fn x_208: word32 * word32 =>
       case x_208 of
	 ((a: word32, b: word32)) => (not (< (b, a))))
val rec
   >=: word32 * word32 -> bool = 
      (fn x_209: word32 * word32 =>
       case x_209 of
	 ((a: word32, b: word32)) => (<= (b, a)))
val sizeInBits: int32 = 0x40
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val +: word64 * word64 -> word64 =
   (fn x_210: word64 * word64 =>
    case x_210 of
      (x_212: word64, x_211: word64) => Word64_add (x_212, x_211))
val andb: word64 * word64 -> word64 =
   (fn x_213: word64 * word64 =>
    case x_213 of
      (x_215: word64, x_214: word64) => Word64_andb (x_215, x_214))
val <<?: word64 * word32 -> word64 =
   (fn x_216: word64 * word32 =>
    case x_216 of
      (x_218: word64, x_217: word32) => Word64_lshift (x_218, x_217))
val *: word64 * word64 -> word64 =
   (fn x_219: word64 * word64 =>
    case x_219 of
      (x_221: word64, x_220: word64) => WordU64_mul (x_221, x_220))
val ~: word64 -> word64 = (fn x_222: word64 => Word64_neg (x_222))
val notb: word64 -> word64 = (fn x_223: word64 => Word64_notb (x_223))
val orb: word64 * word64 -> word64 =
   (fn x_224: word64 * word64 =>
    case x_224 of
      (x_226: word64, x_225: word64) => Word64_orb (x_226, x_225))
val ~>>?: word64 * word32 -> word64 =
   (fn x_227: word64 * word32 =>
    case x_227 of
      (x_229: word64, x_228: word32) => WordS64_rshift (x_229, x_228))
val >>?: word64 * word32 -> word64 =
   (fn x_230: word64 * word32 =>
    case x_230 of
      (x_232: word64, x_231: word32) => WordU64_rshift (x_232, x_231))
val -: word64 * word64 -> word64 =
   (fn x_233: word64 * word64 =>
    case x_233 of
      (x_235: word64, x_234: word64) => Word64_sub (x_235, x_234))
val xorb: word64 * word64 -> word64 =
   (fn x_236: word64 * word64 =>
    case x_236 of
      (x_238: word64, x_237: word64) => Word64_xorb (x_238, x_237))
val <: word64 * word64 -> bool =
   (fn x_239: word64 * word64 =>
    case x_239 of
      (x_241: word64, x_240: word64) => WordU64_lt (x_241, x_240))
val <: word64 * word64 -> bool = <
val sizeInBits: int32 = 0x1
val sizeInBits: int32 = 0x2
val sizeInBits: int32 = 0x3
val sizeInBits: int32 = 0x4
val sizeInBits: int32 = 0x5
val sizeInBits: int32 = 0x6
val sizeInBits: int32 = 0x7
val sizeInBits: int32 = 0x8
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val <: int8 * int8 -> bool =
   (fn x_242: int8 * int8 =>
    case x_242 of
      (x_244: int8, x_243: int8) => WordS8_lt (x_244, x_243))
val <: int8 * int8 -> bool = <
val rec
   >: int8 * int8 -> bool = 
      (fn x_245: int8 * int8 =>
       case x_245 of
	 ((a: int8, b: int8)) => (< (b, a)))
val sizeInBits: int32 = 0x9
val sizeInBits: int32 = 0xA
val sizeInBits: int32 = 0xB
val sizeInBits: int32 = 0xC
val sizeInBits: int32 = 0xD
val sizeInBits: int32 = 0xE
val sizeInBits: int32 = 0xF
val sizeInBits: int32 = 0x10
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val <: int16 * int16 -> bool =
   (fn x_246: int16 * int16 =>
    case x_246 of
      (x_248: int16, x_247: int16) => WordS16_lt (x_248, x_247))
val <: int16 * int16 -> bool = <
val rec
   >: int16 * int16 -> bool = 
      (fn x_249: int16 * int16 =>
       case x_249 of
	 ((a: int16, b: int16)) => (< (b, a)))
val sizeInBits: int32 = 0x11
val sizeInBits: int32 = 0x12
val sizeInBits: int32 = 0x13
val sizeInBits: int32 = 0x14
val sizeInBits: int32 = 0x15
val sizeInBits: int32 = 0x16
val sizeInBits: int32 = 0x17
val sizeInBits: int32 = 0x18
val sizeInBits: int32 = 0x19
val sizeInBits: int32 = 0x1A
val sizeInBits: int32 = 0x1B
val sizeInBits: int32 = 0x1C
val sizeInBits: int32 = 0x1D
val sizeInBits: int32 = 0x1E
val sizeInBits: int32 = 0x1F
val sizeInBits: int32 = 0x20
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val +!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_250: int32 * int32 =>
					 case x_250 of
					   (x_252: int32, x_251: int32) =>
					   WordS32_addCheck (x_252, x_251)))
val +?: int32 * int32 -> int32 =
   (fn x_253: int32 * int32 =>
    case x_253 of
      (x_255: int32, x_254: int32) => Word32_add (x_255, x_254))
val +: int32 * int32 -> int32 = case detectOverflow of true => +! | false => +?
val *!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_256: int32 * int32 =>
					 case x_256 of
					   (x_258: int32, x_257: int32) =>
					   WordS32_mulCheck (x_258, x_257)))
val *?: int32 * int32 -> int32 =
   (fn x_259: int32 * int32 =>
    case x_259 of
      (x_261: int32, x_260: int32) => WordS32_mul (x_261, x_260))
val *: int32 * int32 -> int32 = case detectOverflow of true => *! | false => *?
val ~!: int32 -> int32 =
   (wrapOverflow (int32, int32) (fn x_262: int32 =>
				 Word32_negCheck (x_262)))
val ~?: int32 -> int32 = (fn x_263: int32 => Word32_neg (x_263))
val ~: int32 -> int32 = case detectOverflow of true => ~! | false => ~?
val quotUnsafe: int32 * int32 -> int32 =
   (fn x_264: int32 * int32 =>
    case x_264 of
      (x_266: int32, x_265: int32) => WordS32_quot (x_266, x_265))
val -!: int32 * int32 -> int32 =
   (wrapOverflow (int32, int32 * int32) (fn x_267: int32 * int32 =>
					 case x_267 of
					   (x_269: int32, x_268: int32) =>
					   WordS32_subCheck (x_269, x_268)))
val -?: int32 * int32 -> int32 =
   (fn x_270: int32 * int32 =>
    case x_270 of
      (x_272: int32, x_271: int32) => Word32_sub (x_272, x_271))
val -: int32 * int32 -> int32 = case detectOverflow of true => -! | false => -?
val remUnsafe: int32 * int32 -> int32 =
   (fn x_273: int32 * int32 =>
    case x_273 of
      (x_275: int32, x_274: int32) => WordS32_rem (x_275, x_274))
val <: int32 * int32 -> bool =
   (fn x_276: int32 * int32 =>
    case x_276 of
      (x_278: int32, x_277: int32) => WordS32_lt (x_278, x_277))
val <: int32 * int32 -> bool = <
val rec
   <=: int32 * int32 -> bool = 
      (fn x_279: int32 * int32 =>
       case x_279 of
	 ((a: int32, b: int32)) => (not (< (b, a))))
val rec
   >: int32 * int32 -> bool = 
      (fn x_280: int32 * int32 =>
       case x_280 of
	 ((a: int32, b: int32)) => (< (b, a)))
val rec
   >=: int32 * int32 -> bool = 
      (fn x_281: int32 * int32 =>
       case x_281 of
	 ((a: int32, b: int32)) => (<= (b, a)))
val sizeInBits: int32 = 0x40
val sizeInBitsWord: word32 = (zextdFromInt32ToWord32 sizeInBits)
val precision: int32 Primitive.Option.t = (SOME[int32] sizeInBits)
val +!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_282: int64 * int64 =>
					 case x_282 of
					   (x_284: int64, x_283: int64) =>
					   WordS64_addCheck (x_284, x_283)))
val +?: int64 * int64 -> int64 =
   (fn x_285: int64 * int64 =>
    case x_285 of
      (x_287: int64, x_286: int64) => Word64_add (x_287, x_286))
val +: int64 * int64 -> int64 = case detectOverflow of true => +! | false => +?
val *!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_288: int64 * int64 =>
					 case x_288 of
					   (x_290: int64, x_289: int64) =>
					   WordS64_mulCheck (x_290, x_289)))
val ~!: int64 -> int64 =
   (wrapOverflow (int64, int64) (fn x_291: int64 =>
				 Word64_negCheck (x_291)))
val ~?: int64 -> int64 = (fn x_292: int64 => Word64_neg (x_292))
val ~: int64 -> int64 = case detectOverflow of true => ~! | false => ~?
val quotUnsafe: int64 * int64 -> int64 =
   (fn x_293: int64 * int64 =>
    case x_293 of
      (x_295: int64, x_294: int64) => WordS64_quot (x_295, x_294))
val -!: int64 * int64 -> int64 =
   (wrapOverflow (int64, int64 * int64) (fn x_296: int64 * int64 =>
					 case x_296 of
					   (x_298: int64, x_297: int64) =>
					   WordS64_subCheck (x_298, x_297)))
val -?: int64 * int64 -> int64 =
   (fn x_299: int64 * int64 =>
    case x_299 of
      (x_301: int64, x_300: int64) => Word64_sub (x_301, x_300))
val -: int64 * int64 -> int64 = case detectOverflow of true => -! | false => -?
val remUnsafe: int64 * int64 -> int64 =
   (fn x_302: int64 * int64 =>
    case x_302 of
      (x_304: int64, x_303: int64) => WordS64_rem (x_304, x_303))
val <: int64 * int64 -> bool =
   (fn x_305: int64 * int64 =>
    case x_305 of
      (x_307: int64, x_306: int64) => WordS64_lt (x_307, x_306))
val <: int64 * int64 -> bool = <
val rec
   <=: int64 * int64 -> bool = 
      (fn x_308: int64 * int64 =>
       case x_308 of
	 ((a: int64, b: int64)) => (not (< (b, a))))
val rec
   >: int64 * int64 -> bool = 
      (fn x_309: int64 * int64 =>
       case x_309 of
	 ((a: int64, b: int64)) => (< (b, a)))
val rec
   >=: int64 * int64 -> bool = 
      (fn x_310: int64 * int64 =>
       case x_310 of
	 ((a: int64, b: int64)) => (<= (b, a)))
val rec
   min: int64 * int64 -> int64 = 
      (fn x_311: int64 * int64 =>
       case x_311 of
	 ((x: int64, y: int64)) => case (< (x, y)) of true => x | false => y)
val rec
   max: int64 * int64 -> int64 = 
      (fn x_312: int64 * int64 =>
       case x_312 of
	 ((x: int64, y: int64)) => case (< (x, y)) of true => y | false => x)
val 'a arrayUnsafe: int64 -> 'a array =
   (fn x_313: int64 =>
    Array_array['a] (x_313))
val 'a array0Const: unit -> 'a array =
   (fn x_314: unit =>
    case x_314 of
      () => Array_array0Const['a] ())
val 'a length: 'a array -> int64 =
   (fn x_315: 'a array =>
    Array_length['a] (x_315))
val 'a subUnsafe: 'a array * int64 -> 'a =
   (fn x_316: 'a array * int64 =>
    case x_316 of
      (x_318: 'a array, x_317: int64) => Array_sub['a] (x_318, x_317))
val 'a updateUnsafe: 'a array * int64 * 'a -> unit =
   (fn x_319: 'a array * int64 * 'a =>
    case x_319 of
      (x_322: 'a array, x_321: int64, x_320: 'a) =>
      Array_update['a] (x_322, x_321, x_320))
val 'a fromArrayUnsafe: 'a array -> 'a vector =
   (fn x_323: 'a array =>
    Array_toVector['a] (x_323))
val 'a length: 'a vector -> int64 =
   (fn x_324: 'a vector =>
    Vector_length['a] (x_324))
val 'a subUnsafe: 'a vector * int64 -> 'a =
   (fn x_325: 'a vector * int64 =>
    case x_325 of
      (x_327: 'a vector, x_326: int64) => Vector_sub['a] (x_327, x_326))
val rec
   fromString: string -> string = 
      (fn x_328: string =>
       case x_328 of
	 (s: string) =>
	 case (= (char8) (0x0,
			  (subUnsafe (char8) (s, (- ((length (char8) s), 0x1)))))) of
	   true => s | false => raise (Fail8 "NullString.fromString"))
val +: intInf * intInf * word64 -> intInf =
   (fn x_329: intInf * intInf * word64 =>
    case x_329 of
      (x_332: intInf, x_331: intInf, x_330: word64) =>
      IntInf_add (x_332, x_331, x_330))
val compare: intInf * intInf -> int32 =
   (fn x_333: intInf * intInf =>
    case x_333 of
      (x_335: intInf, x_334: intInf) => IntInf_compare (x_335, x_334))
val fromVector: word64 vector -> intInf =
   (fn x_336: word64 vector =>
    WordVector_toIntInf (x_336))
val fromWord: word64 -> intInf = (fn x_337: word64 => Word_toIntInf (x_337))
val *: intInf * intInf * word64 -> intInf =
   (fn x_338: intInf * intInf * word64 =>
    case x_338 of
      (x_341: intInf, x_340: intInf, x_339: word64) =>
      IntInf_mul (x_341, x_340, x_339))
val ~: intInf * word64 -> intInf =
   (fn x_342: intInf * word64 =>
    case x_342 of
      (x_344: intInf, x_343: word64) => IntInf_neg (x_344, x_343))
val toString: intInf * int32 * word64 -> string =
   (fn x_345: intInf * int32 * word64 =>
    case x_345 of
      (x_348: intInf, x_347: int32, x_346: word64) =>
      IntInf_toString (x_348, x_347, x_346))
val toVector: intInf -> word64 vector =
   (fn x_349: intInf =>
    IntInf_toVector (x_349))
val toWord: intInf -> word64 = (fn x_350: intInf => IntInf_toWord (x_350))
val <: char8 * char8 -> bool =
   (fn x_351: char8 * char8 =>
    case x_351 of
      (x_353: char8, x_352: char8) => WordU8_lt (x_353, x_352))
val idToWord8: char8 -> word8 = (fn x_354: char8 => WordU8_extdToWord8 (x_354))
val idFromWord8: word8 -> char8 =
   (fn x_355: word8 =>
    WordU8_extdToWord8 (x_355))
val <: char8 * char8 -> bool = <
val rec
   <=: char8 * char8 -> bool = 
      (fn x_356: char8 * char8 =>
       case x_356 of
	 ((a: char8, b: char8)) => (not (< (b, a))))
val idToWord16: char16 -> word16 =
   (fn x_357: char16 =>
    WordU16_extdToWord16 (x_357))
val idFromWord16: word16 -> char16 =
   (fn x_358: word16 =>
    WordU16_extdToWord16 (x_358))
val idToWord32: char32 -> word32 =
   (fn x_359: char32 =>
    WordU32_extdToWord32 (x_359))
val idFromWord32: word32 -> char32 =
   (fn x_360: word32 =>
    WordU32_extdToWord32 (x_360))
val realSize: int32 = 0x20
val precision: int32 = 0x18
val acos: real32 -> real32 = (fn x_361: real32 => Real32_Math_acos (x_361))
val asin: real32 -> real32 = (fn x_362: real32 => Real32_Math_asin (x_362))
val atan: real32 -> real32 = (fn x_363: real32 => Real32_Math_atan (x_363))
val atan2: real32 * real32 -> real32 =
   (fn x_364: real32 * real32 =>
    case x_364 of
      (x_366: real32, x_365: real32) => Real32_Math_atan2 (x_366, x_365))
val cos: real32 -> real32 = (fn x_367: real32 => Real32_Math_cos (x_367))
val cosh: real32 -> real32 = (fn x_368: real32 => Real32_Math_cosh (x_368))
val e: real32 =
   (((fn x_369: (unit -> real32) * (real32 -> unit) =>
      case x_369 of
	{1 = #: unit -> real32} => #) ((fn x_371: unit =>
				CPointer_getReal32 (Real32_Math_e (), 0x0)),
			       (fn x_370: real32 =>
				CPointer_setReal32 (Real32_Math_e (), 0x0, x_370)))) ())
val exp: real32 -> real32 = (fn x_372: real32 => Real32_Math_exp (x_372))
val ln: real32 -> real32 = (fn x_373: real32 => Real32_Math_ln (x_373))
val log10: real32 -> real32 = (fn x_374: real32 => Real32_Math_log10 (x_374))
val pi: real32 =
   (((fn x_375: (unit -> real32) * (real32 -> unit) =>
      case x_375 of
	{1 = #: unit -> real32} => #) ((fn x_377: unit =>
				CPointer_getReal32 (Real32_Math_pi (), 0x0)),
			       (fn x_376: real32 =>
				CPointer_setReal32 (Real32_Math_pi (),
						    0x0,
						    x_376)))) ())
val pow: real32 * real32 -> real32 =
   (fn x_378: real32 * real32 =>
    case x_378 of
      (x_380: real32, x_379: real32) => Real32_Math_pow (x_380, x_379))
val sin: real32 -> real32 = (fn x_381: real32 => Real32_Math_sin (x_381))
val sinh: real32 -> real32 = (fn x_382: real32 => Real32_Math_sinh (x_382))
val sqrt: real32 -> real32 = (fn x_383: real32 => Real32_Math_sqrt (x_383))
val tan: real32 -> real32 = (fn x_384: real32 => Real32_Math_tan (x_384))
val tanh: real32 -> real32 = (fn x_385: real32 => Real32_Math_tanh (x_385))
val *: real32 * real32 -> real32 =
   (fn x_386: real32 * real32 =>
    case x_386 of
      (x_388: real32, x_387: real32) => Real32_mul (x_388, x_387))
val *+: real32 * real32 * real32 -> real32 =
   (fn x_389: real32 * real32 * real32 =>
    case x_389 of
      (x_392: real32, x_391: real32, x_390: real32) =>
      Real32_muladd (x_392, x_391, x_390))
val *-: real32 * real32 * real32 -> real32 =
   (fn x_393: real32 * real32 * real32 =>
    case x_393 of
      (x_396: real32, x_395: real32, x_394: real32) =>
      Real32_mulsub (x_396, x_395, x_394))
val +: real32 * real32 -> real32 =
   (fn x_397: real32 * real32 =>
    case x_397 of
      (x_399: real32, x_398: real32) => Real32_add (x_399, x_398))
val -: real32 * real32 -> real32 =
   (fn x_400: real32 * real32 =>
    case x_400 of
      (x_402: real32, x_401: real32) => Real32_sub (x_402, x_401))
val /: real32 * real32 -> real32 =
   (fn x_403: real32 * real32 =>
    case x_403 of
      (x_405: real32, x_404: real32) => Real32_div (x_405, x_404))
val ~: real32 -> real32 = (fn x_406: real32 => Real32_neg (x_406))
val <: real32 * real32 -> bool =
   (fn x_407: real32 * real32 =>
    case x_407 of
      (x_409: real32, x_408: real32) => Real32_lt (x_409, x_408))
val <=: real32 * real32 -> bool =
   (fn x_410: real32 * real32 =>
    case x_410 of
      (x_412: real32, x_411: real32) => Real32_le (x_412, x_411))
val ==: real32 * real32 -> bool =
   (fn x_413: real32 * real32 =>
    case x_413 of
      (x_415: real32, x_414: real32) => Real32_equal (x_415, x_414))
val abs: real32 -> real32 = (fn x_416: real32 => Real32_abs (x_416))
val class: real32 -> int32 = (fn x_417: real32 => Real32_class (x_417))
val frexp: real32 * int32 ref -> real32 =
   (fn x_418: real32 * int32 ref =>
    case x_418 of
      (x_420: real32, x_419: int32 ref) => Real32_frexp (x_420, x_419))
val gdtoa: real32 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_421: real32 * int32 * int32 * int32 * int32 ref =>
    case x_421 of
      (x_426: real32, x_425: int32, x_424: int32, x_423: int32, x_422: int32 ref) =>
      Real32_gdtoa (x_426, x_425, x_424, x_423, x_422))
val ldexp: real32 * int32 -> real32 =
   (fn x_427: real32 * int32 =>
    case x_427 of
      (x_429: real32, x_428: int32) => Real32_ldexp (x_429, x_428))
val maxFinite: real32 =
   (((fn x_430: (unit -> real32) * (real32 -> unit) =>
      case x_430 of
	{1 = #: unit -> real32} => #) ((fn x_432: unit =>
				CPointer_getReal32 (Real32_maxFinite (), 0x0)),
			       (fn x_431: real32 =>
				CPointer_setReal32 (Real32_maxFinite (),
						    0x0,
						    x_431)))) ())
val minNormalPos: real32 =
   (((fn x_433: (unit -> real32) * (real32 -> unit) =>
      case x_433 of
	{1 = #: unit -> real32} => #) ((fn x_435: unit =>
				CPointer_getReal32 (Real32_minNormalPos (), 0x0)),
			       (fn x_434: real32 =>
				CPointer_setReal32 (Real32_minNormalPos (),
						    0x0,
						    x_434)))) ())
val minPos: real32 =
   (((fn x_436: (unit -> real32) * (real32 -> unit) =>
      case x_436 of
	{1 = #: unit -> real32} => #) ((fn x_438: unit =>
				CPointer_getReal32 (Real32_minPos (), 0x0)),
			       (fn x_437: real32 =>
				CPointer_setReal32 (Real32_minPos (), 0x0, x_437)))) ())
val modf: real32 * real32 ref -> real32 =
   (fn x_439: real32 * real32 ref =>
    case x_439 of
      (x_441: real32, x_440: real32 ref) => Real32_modf (x_441, x_440))
val round: real32 -> real32 = (fn x_442: real32 => Real32_round (x_442))
val signBit: real32 -> int32 = (fn x_443: real32 => Real32_signBit (x_443))
val strto: string * int32 -> real32 =
   (fn x_444: string * int32 =>
    case x_444 of
      (x_446: string, x_445: int32) => Real32_strto (x_446, x_445))
val fromInt8Unsafe: int8 -> real32 =
   (fn x_447: int8 =>
    WordS8_rndToReal32 (x_447))
val fromInt16Unsafe: int16 -> real32 =
   (fn x_448: int16 =>
    WordS16_rndToReal32 (x_448))
val fromInt32Unsafe: int32 -> real32 =
   (fn x_449: int32 =>
    WordS32_rndToReal32 (x_449))
val fromInt64Unsafe: int64 -> real32 =
   (fn x_450: int64 =>
    WordS64_rndToReal32 (x_450))
val fromReal32Unsafe: real32 -> real32 =
   (fn x_451: real32 =>
    Real32_rndToReal32 (x_451))
val fromWord8Unsafe: word8 -> real32 =
   (fn x_452: word8 =>
    WordU8_rndToReal32 (x_452))
val fromWord16Unsafe: word16 -> real32 =
   (fn x_453: word16 =>
    WordU16_rndToReal32 (x_453))
val fromWord32Unsafe: word32 -> real32 =
   (fn x_454: word32 =>
    WordU32_rndToReal32 (x_454))
val fromWord64Unsafe: word64 -> real32 =
   (fn x_455: word64 =>
    WordU64_rndToReal32 (x_455))
val toInt8Unsafe: real32 -> int8 =
   (fn x_456: real32 =>
    Real32_rndToWordS8 (x_456))
val toInt16Unsafe: real32 -> int16 =
   (fn x_457: real32 =>
    Real32_rndToWordS16 (x_457))
val toInt32Unsafe: real32 -> int32 =
   (fn x_458: real32 =>
    Real32_rndToWordS32 (x_458))
val toInt64Unsafe: real32 -> int64 =
   (fn x_459: real32 =>
    Real32_rndToWordS64 (x_459))
val toReal32Unsafe: real32 -> real32 =
   (fn x_460: real32 =>
    Real32_rndToReal32 (x_460))
val toWord8Unsafe: real32 -> word8 =
   (fn x_461: real32 =>
    Real32_rndToWordU8 (x_461))
val toWord16Unsafe: real32 -> word16 =
   (fn x_462: real32 =>
    Real32_rndToWordU16 (x_462))
val toWord32Unsafe: real32 -> word32 =
   (fn x_463: real32 =>
    Real32_rndToWordU32 (x_463))
val toWord64Unsafe: real32 -> word64 =
   (fn x_464: real32 =>
    Real32_rndToWordU64 (x_464))
val rec
   >: real32 * real32 -> bool = 
      (fn x_465: real32 * real32 =>
       case x_465 of
	 ((a: real32, b: real32)) => (< (b, a)))
val rec
   >=: real32 * real32 -> bool = 
      (fn x_466: real32 * real32 =>
       case x_466 of
	 ((a: real32, b: real32)) => (<= (b, a)))
val precision: int32 = 0x35
val acos: real64 -> real64 = (fn x_467: real64 => Real64_Math_acos (x_467))
val asin: real64 -> real64 = (fn x_468: real64 => Real64_Math_asin (x_468))
val atan: real64 -> real64 = (fn x_469: real64 => Real64_Math_atan (x_469))
val atan2: real64 * real64 -> real64 =
   (fn x_470: real64 * real64 =>
    case x_470 of
      (x_472: real64, x_471: real64) => Real64_Math_atan2 (x_472, x_471))
val cos: real64 -> real64 = (fn x_473: real64 => Real64_Math_cos (x_473))
val cosh: real64 -> real64 = (fn x_474: real64 => Real64_Math_cosh (x_474))
val e: real64 =
   (((fn x_475: (unit -> real64) * (real64 -> unit) =>
      case x_475 of
	{1 = #: unit -> real64} => #) ((fn x_477: unit =>
				CPointer_getReal64 (Real64_Math_e (), 0x0)),
			       (fn x_476: real64 =>
				CPointer_setReal64 (Real64_Math_e (), 0x0, x_476)))) ())
val exp: real64 -> real64 = (fn x_478: real64 => Real64_Math_exp (x_478))
val ln: real64 -> real64 = (fn x_479: real64 => Real64_Math_ln (x_479))
val log10: real64 -> real64 = (fn x_480: real64 => Real64_Math_log10 (x_480))
val pi: real64 =
   (((fn x_481: (unit -> real64) * (real64 -> unit) =>
      case x_481 of
	{1 = #: unit -> real64} => #) ((fn x_483: unit =>
				CPointer_getReal64 (Real64_Math_pi (), 0x0)),
			       (fn x_482: real64 =>
				CPointer_setReal64 (Real64_Math_pi (),
						    0x0,
						    x_482)))) ())
val pow: real64 * real64 -> real64 =
   (fn x_484: real64 * real64 =>
    case x_484 of
      (x_486: real64, x_485: real64) => Real64_Math_pow (x_486, x_485))
val sin: real64 -> real64 = (fn x_487: real64 => Real64_Math_sin (x_487))
val sinh: real64 -> real64 = (fn x_488: real64 => Real64_Math_sinh (x_488))
val sqrt: real64 -> real64 = (fn x_489: real64 => Real64_Math_sqrt (x_489))
val tan: real64 -> real64 = (fn x_490: real64 => Real64_Math_tan (x_490))
val tanh: real64 -> real64 = (fn x_491: real64 => Real64_Math_tanh (x_491))
val *: real64 * real64 -> real64 =
   (fn x_492: real64 * real64 =>
    case x_492 of
      (x_494: real64, x_493: real64) => Real64_mul (x_494, x_493))
val *+: real64 * real64 * real64 -> real64 =
   (fn x_495: real64 * real64 * real64 =>
    case x_495 of
      (x_498: real64, x_497: real64, x_496: real64) =>
      Real64_muladd (x_498, x_497, x_496))
val *-: real64 * real64 * real64 -> real64 =
   (fn x_499: real64 * real64 * real64 =>
    case x_499 of
      (x_502: real64, x_501: real64, x_500: real64) =>
      Real64_mulsub (x_502, x_501, x_500))
val +: real64 * real64 -> real64 =
   (fn x_503: real64 * real64 =>
    case x_503 of
      (x_505: real64, x_504: real64) => Real64_add (x_505, x_504))
val -: real64 * real64 -> real64 =
   (fn x_506: real64 * real64 =>
    case x_506 of
      (x_508: real64, x_507: real64) => Real64_sub (x_508, x_507))
val /: real64 * real64 -> real64 =
   (fn x_509: real64 * real64 =>
    case x_509 of
      (x_511: real64, x_510: real64) => Real64_div (x_511, x_510))
val ~: real64 -> real64 = (fn x_512: real64 => Real64_neg (x_512))
val <: real64 * real64 -> bool =
   (fn x_513: real64 * real64 =>
    case x_513 of
      (x_515: real64, x_514: real64) => Real64_lt (x_515, x_514))
val <=: real64 * real64 -> bool =
   (fn x_516: real64 * real64 =>
    case x_516 of
      (x_518: real64, x_517: real64) => Real64_le (x_518, x_517))
val ==: real64 * real64 -> bool =
   (fn x_519: real64 * real64 =>
    case x_519 of
      (x_521: real64, x_520: real64) => Real64_equal (x_521, x_520))
val abs: real64 -> real64 = (fn x_522: real64 => Real64_abs (x_522))
val class: real64 -> int32 = (fn x_523: real64 => Real64_class (x_523))
val frexp: real64 * int32 ref -> real64 =
   (fn x_524: real64 * int32 ref =>
    case x_524 of
      (x_526: real64, x_525: int32 ref) => Real64_frexp (x_526, x_525))
val gdtoa: real64 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_527: real64 * int32 * int32 * int32 * int32 ref =>
    case x_527 of
      (x_532: real64, x_531: int32, x_530: int32, x_529: int32, x_528: int32 ref) =>
      Real64_gdtoa (x_532, x_531, x_530, x_529, x_528))
val ldexp: real64 * int32 -> real64 =
   (fn x_533: real64 * int32 =>
    case x_533 of
      (x_535: real64, x_534: int32) => Real64_ldexp (x_535, x_534))
val maxFinite: real64 =
   (((fn x_536: (unit -> real64) * (real64 -> unit) =>
      case x_536 of
	{1 = #: unit -> real64} => #) ((fn x_538: unit =>
				CPointer_getReal64 (Real64_maxFinite (), 0x0)),
			       (fn x_537: real64 =>
				CPointer_setReal64 (Real64_maxFinite (),
						    0x0,
						    x_537)))) ())
val minNormalPos: real64 =
   (((fn x_539: (unit -> real64) * (real64 -> unit) =>
      case x_539 of
	{1 = #: unit -> real64} => #) ((fn x_541: unit =>
				CPointer_getReal64 (Real64_minNormalPos (), 0x0)),
			       (fn x_540: real64 =>
				CPointer_setReal64 (Real64_minNormalPos (),
						    0x0,
						    x_540)))) ())
val minPos: real64 =
   (((fn x_542: (unit -> real64) * (real64 -> unit) =>
      case x_542 of
	{1 = #: unit -> real64} => #) ((fn x_544: unit =>
				CPointer_getReal64 (Real64_minPos (), 0x0)),
			       (fn x_543: real64 =>
				CPointer_setReal64 (Real64_minPos (), 0x0, x_543)))) ())
val modf: real64 * real64 ref -> real64 =
   (fn x_545: real64 * real64 ref =>
    case x_545 of
      (x_547: real64, x_546: real64 ref) => Real64_modf (x_547, x_546))
val round: real64 -> real64 = (fn x_548: real64 => Real64_round (x_548))
val signBit: real64 -> int32 = (fn x_549: real64 => Real64_signBit (x_549))
val strto: string * int32 -> real64 =
   (fn x_550: string * int32 =>
    case x_550 of
      (x_552: string, x_551: int32) => Real64_strto (x_552, x_551))
val fromInt8Unsafe: int8 -> real64 =
   (fn x_553: int8 =>
    WordS8_rndToReal64 (x_553))
val fromInt16Unsafe: int16 -> real64 =
   (fn x_554: int16 =>
    WordS16_rndToReal64 (x_554))
val fromInt32Unsafe: int32 -> real64 =
   (fn x_555: int32 =>
    WordS32_rndToReal64 (x_555))
val fromInt64Unsafe: int64 -> real64 =
   (fn x_556: int64 =>
    WordS64_rndToReal64 (x_556))
val fromReal32Unsafe: real32 -> real64 =
   (fn x_557: real32 =>
    Real32_rndToReal64 (x_557))
val fromWord8Unsafe: word8 -> real64 =
   (fn x_558: word8 =>
    WordU8_rndToReal64 (x_558))
val fromWord16Unsafe: word16 -> real64 =
   (fn x_559: word16 =>
    WordU16_rndToReal64 (x_559))
val fromWord32Unsafe: word32 -> real64 =
   (fn x_560: word32 =>
    WordU32_rndToReal64 (x_560))
val fromWord64Unsafe: word64 -> real64 =
   (fn x_561: word64 =>
    WordU64_rndToReal64 (x_561))
val toInt8Unsafe: real64 -> int8 =
   (fn x_562: real64 =>
    Real64_rndToWordS8 (x_562))
val toInt16Unsafe: real64 -> int16 =
   (fn x_563: real64 =>
    Real64_rndToWordS16 (x_563))
val toInt32Unsafe: real64 -> int32 =
   (fn x_564: real64 =>
    Real64_rndToWordS32 (x_564))
val toInt64Unsafe: real64 -> int64 =
   (fn x_565: real64 =>
    Real64_rndToWordS64 (x_565))
val toReal32Unsafe: real64 -> real32 =
   (fn x_566: real64 =>
    Real64_rndToReal32 (x_566))
val toWord8Unsafe: real64 -> word8 =
   (fn x_567: real64 =>
    Real64_rndToWordU8 (x_567))
val toWord16Unsafe: real64 -> word16 =
   (fn x_568: real64 =>
    Real64_rndToWordU16 (x_568))
val toWord32Unsafe: real64 -> word32 =
   (fn x_569: real64 =>
    Real64_rndToWordU32 (x_569))
val toWord64Unsafe: real64 -> word64 =
   (fn x_570: real64 =>
    Real64_rndToWordU64 (x_570))
val rec
   >: real64 * real64 -> bool = 
      (fn x_571: real64 * real64 =>
       case x_571 of
	 ((a: real64, b: real64)) => (< (b, a)))
val rec
   >=: real64 * real64 -> bool = 
      (fn x_572: real64 * real64 =>
       case x_572 of
	 ((a: real64, b: real64)) => (<= (b, a)))
val subArr: word8 array * int64 -> word8 =
   (fn x_573: word8 array * int64 =>
    case x_573 of
      (x_575: word8 array, x_574: int64) => Word8Array_subWord8 (x_575, x_574))
val subVec: word8 vector * int64 -> word8 =
   (fn x_576: word8 vector * int64 =>
    case x_576 of
      (x_578: word8 vector, x_577: int64) => Word8Vector_subWord8 (x_578, x_577))
val update: word8 array * int64 * word8 -> unit =
   (fn x_579: word8 array * int64 * word8 =>
    case x_579 of
      (x_582: word8 array, x_581: int64, x_580: word8) =>
      Word8Array_updateWord8 (x_582, x_581, x_580))
val subArr: word8 array * int64 -> word16 =
   (fn x_583: word8 array * int64 =>
    case x_583 of
      (x_585: word8 array, x_584: int64) => Word8Array_subWord16 (x_585, x_584))
val subVec: word8 vector * int64 -> word16 =
   (fn x_586: word8 vector * int64 =>
    case x_586 of
      (x_588: word8 vector, x_587: int64) =>
      Word8Vector_subWord16 (x_588, x_587))
val update: word8 array * int64 * word16 -> unit =
   (fn x_589: word8 array * int64 * word16 =>
    case x_589 of
      (x_592: word8 array, x_591: int64, x_590: word16) =>
      Word8Array_updateWord16 (x_592, x_591, x_590))
val subArr: word8 array * int64 -> word32 =
   (fn x_593: word8 array * int64 =>
    case x_593 of
      (x_595: word8 array, x_594: int64) => Word8Array_subWord32 (x_595, x_594))
val subVec: word8 vector * int64 -> word32 =
   (fn x_596: word8 vector * int64 =>
    case x_596 of
      (x_598: word8 vector, x_597: int64) =>
      Word8Vector_subWord32 (x_598, x_597))
val update: word8 array * int64 * word32 -> unit =
   (fn x_599: word8 array * int64 * word32 =>
    case x_599 of
      (x_602: word8 array, x_601: int64, x_600: word32) =>
      Word8Array_updateWord32 (x_602, x_601, x_600))
val subArr: word8 array * int64 -> word64 =
   (fn x_603: word8 array * int64 =>
    case x_603 of
      (x_605: word8 array, x_604: int64) => Word8Array_subWord64 (x_605, x_604))
val subVec: word8 vector * int64 -> word64 =
   (fn x_606: word8 vector * int64 =>
    case x_606 of
      (x_608: word8 vector, x_607: int64) =>
      Word8Vector_subWord64 (x_608, x_607))
val update: word8 array * int64 * word64 -> unit =
   (fn x_609: word8 array * int64 * word64 =>
    case x_609 of
      (x_612: word8 array, x_611: int64, x_610: word64) =>
      Word8Array_updateWord64 (x_612, x_611, x_610))
val castFromWord: word32 -> real32 =
   (fn x_613: word32 =>
    Word32_castToReal32 (x_613))
val castToWord: real32 -> word32 =
   (fn x_614: real32 =>
    Real32_castToWord32 (x_614))
val halt: int32 -> unit = (fn x_615: int32 => MLton_halt (x_615))
val gcState: cpointer =
   (((fn x_616: (unit -> cpointer) * (cpointer -> unit) =>
      case x_616 of
	{1 = #: unit -> cpointer} => #) ((fn x_618: unit =>
				  CPointer_getCPointer (gcStateAddress (), 0x0)),
				 (fn x_617: cpointer =>
				  CPointer_setCPointer (gcStateAddress (),
							0x0,
							x_617)))) ())
datatype Primitive.MLton.Align.t = Align4
				   | Align8
val align: Primitive.MLton.Align.t =
   case 0x8 of
     0x4 => Align4 | 0x8 => Align8 | _ => raise (Fail8 "MLton_Align_align")
datatype Primitive.MLton.CallStack.t = T of word32 array
val callStack: cpointer * word32 array -> unit =
   (fn x_619: cpointer * word32 array =>
    case x_619 of
      (x_621: cpointer, x_620: word32 array) => GC_callStack (x_621, x_620))
val frameIndexSourceSeq: cpointer * word32 -> cpointer =
   (fn x_622: cpointer * word32 =>
    case x_622 of
      (x_624: cpointer, x_623: word32) => GC_frameIndexSourceSeq (x_624, x_623))
val keep: bool = 0x0
val numStackFrames: cpointer -> word32 =
   (fn x_625: cpointer =>
    GC_numStackFrames (x_625))
val sourceName: cpointer * word32 -> word64 =
   (fn x_626: cpointer * word32 =>
    case x_626 of
      (x_628: cpointer, x_627: word32) => GC_sourceName (x_628, x_627))
datatype Primitive.MLton.Codegen.t = Bytecode
				     | C
				     | x86
				     | amd64
val 'a extra: exn -> 'a = (fn x_629: exn => Exn_extra['a] (x_629))
val extra: exn -> Primitive.MLton.CallStack.t Primitive.Option.t =
   extra (Primitive.MLton.CallStack.t Primitive.Option.t)
val keepHistory: bool = 0x0
val 'a setExtendExtra: ('a -> 'a) -> unit =
   (fn x_630: 'a -> 'a =>
    Exn_setExtendExtra['a] (x_630))
val setExtendExtra: (Primitive.MLton.CallStack.t Primitive.Option.t
		     -> Primitive.MLton.CallStack.t Primitive.Option.t)
		    -> unit =
   setExtendExtra (Primitive.MLton.CallStack.t Primitive.Option.t)
val setExtendExtra: (Primitive.MLton.CallStack.t Primitive.Option.t
		     -> Primitive.MLton.CallStack.t Primitive.Option.t)
		    -> unit =
   case keepHistory of
     true =>
     (setExtendExtra (fn x_631: Primitive.MLton.CallStack.t Primitive.Option.t =>
		      case x_631 of
			_ => NONE[Primitive.MLton.CallStack.t]))
     ;setExtendExtra
   | false =>
     (fn x_632: Primitive.MLton.CallStack.t Primitive.Option.t
		-> Primitive.MLton.CallStack.t Primitive.Option.t =>
      case x_632 of
	_ => ())
datatype Primitive.MLton.Platform.Arch.t = Alpha
					   | AMD64
					   | ARM
					   | HPPA
					   | IA64
					   | m68k
					   | MIPS
					   | PowerPC
					   | PowerPC64
					   | S390
					   | Sparc
					   | X86
datatype Primitive.MLton.Platform.Format.t = Archive
					     | Executable
					     | LibArchive
					     | Library
val host: Primitive.MLton.Platform.Format.t =
   case "executable" of
     "archive" => Archive
   | "executable" => Executable
   | "libarchive" => LibArchive
   | "library" => Library
   | _ => raise (Fail8 "strange MLton_Platform_Format")
datatype Primitive.MLton.Platform.OS.t = AIX
					 | Cygwin
					 | Darwin
					 | FreeBSD
					 | Hurd
					 | HPUX
					 | Linux
					 | MinGW
					 | NetBSD
					 | OpenBSD
					 | Solaris
val fromWord: word64 -> cpointer =
   (fn x_633: word64 =>
    CPointer_fromWord (x_633))
val null: cpointer = (fromWord 0x0)
val rec
   isNull: cpointer -> bool = 
      (fn x_634: cpointer =>
       case x_634 of
	 (p: cpointer) => (= (cpointer) (p, null)))
val getInt32: cpointer * int64 -> int32 =
   (fn x_635: cpointer * int64 =>
    case x_635 of
      (x_637: cpointer, x_636: int64) => CPointer_getWord32 (x_637, x_636))
val getWord8: cpointer * int64 -> word8 =
   (fn x_638: cpointer * int64 =>
    case x_638 of
      (x_640: cpointer, x_639: int64) => CPointer_getWord8 (x_640, x_639))
val getWord32: cpointer * int64 -> word32 =
   (fn x_641: cpointer * int64 =>
    case x_641 of
      (x_643: cpointer, x_642: int64) => CPointer_getWord32 (x_643, x_642))
val isOn: bool = 0x0
val dummy: cpointer = null
val free: cpointer * cpointer -> unit =
   (fn x_644: cpointer * cpointer =>
    case x_644 of
      (x_646: cpointer, x_645: cpointer) => GC_profileFree (x_646, x_645))
val write: cpointer * cpointer * string -> unit =
   (fn x_647: cpointer * cpointer * string =>
    case x_647 of
      (x_650: cpointer, x_649: cpointer, x_648: string) =>
      GC_profileWrite (x_650, x_649, x_648))
val done: cpointer -> unit = (fn x_651: cpointer => GC_profileDone (x_651))
val getCurrent: cpointer -> cpointer =
   (fn x_652: cpointer =>
    GC_getProfileCurrent (x_652))
val setCurrent: cpointer * cpointer -> unit =
   (fn x_653: cpointer * cpointer =>
    case x_653 of
      (x_655: cpointer, x_654: cpointer) => GC_setProfileCurrent (x_655, x_654))
val atomicState: unit -> word32 =
   (fn x_656: unit =>
    case x_656 of
      () => Thread_atomicState ())
val atomicBegin: unit -> unit =
   (fn x_657: unit =>
    case x_657 of
      () => Thread_atomicBegin ())
val rec
   atomicEnd: unit -> unit = 
      (fn x_658: unit =>
       case x_658 of
	 (()) =>
	 case (= (word32) ((atomicState ()), 0x0)) of
	   true => raise (Fail8 "Thread.atomicEnd")
	 | false =>
	   ((fn x_659: unit =>
	     case x_659 of
	       () => Thread_atomicEnd ()) ()))
val returnToC: unit -> unit =
   (fn x_660: unit =>
    case x_660 of
      () => Thread_returnToC ())
val FP_INFINITE: int32 = 0x2
val FP_NAN: int32 = 0x1
val FP_NORMAL: int32 = 0x4
val FP_SUBNORMAL: int32 = 0x5
val FP_ZERO: int32 = 0x3
val getRoundingMode: unit -> int32 =
   (fn x_661: unit =>
    case x_661 of
      () => IEEEReal_getRoundingMode ())
val FE_DOWNWARD: int32 = 0x400
val FE_NOSUPPORT: int32 = 0xFFFFFFFF
val FE_TONEAREST: int32 = 0x0
val FE_TOWARDZERO: int32 = 0xC00
val FE_UPWARD: int32 = 0x800
val setRoundingMode: int32 -> int32 =
   (fn x_662: int32 =>
    IEEEReal_setRoundingMode (x_662))
val bug: string -> unit = (fn x_663: string => MLton_bug (x_663))
val htons: word16 -> word16 = (fn x_664: word16 => Net_htons (x_664))
val ntohs: word16 -> word16 = (fn x_665: word16 => Net_ntohs (x_665))
val E2BIG: int32 = 0x7
val EACCES: int32 = 0xD
val EADDRINUSE: int32 = 0x30
val EADDRNOTAVAIL: int32 = 0x31
val EAFNOSUPPORT: int32 = 0x2F
val EAGAIN: int32 = 0x23
val EALREADY: int32 = 0x25
val EBADF: int32 = 0x9
val EBADMSG: int32 = 0x5E
val EBUSY: int32 = 0x10
val ECANCELED: int32 = 0x59
val ECHILD: int32 = 0xA
val ECONNABORTED: int32 = 0x35
val ECONNREFUSED: int32 = 0x3D
val ECONNRESET: int32 = 0x36
val EDEADLK: int32 = 0xB
val EDESTADDRREQ: int32 = 0x27
val EDOM: int32 = 0x21
val EDQUOT: int32 = 0x45
val EEXIST: int32 = 0x11
val EFAULT: int32 = 0xE
val EFBIG: int32 = 0x1B
val EHOSTUNREACH: int32 = 0x41
val EIDRM: int32 = 0x5A
val EILSEQ: int32 = 0x5C
val EINPROGRESS: int32 = 0x24
val EINTR: int32 = 0x4
val EINVAL: int32 = 0x16
val EIO: int32 = 0x5
val EISCONN: int32 = 0x38
val EISDIR: int32 = 0x15
val ELOOP: int32 = 0x3E
val EMFILE: int32 = 0x18
val EMLINK: int32 = 0x1F
val EMSGSIZE: int32 = 0x28
val EMULTIHOP: int32 = 0x5F
val ENAMETOOLONG: int32 = 0x3F
val ENETDOWN: int32 = 0x32
val ENETRESET: int32 = 0x34
val ENETUNREACH: int32 = 0x33
val ENFILE: int32 = 0x17
val ENOBUFS: int32 = 0x37
val ENODATA: int32 = 0x60
val ENODEV: int32 = 0x13
val ENOENT: int32 = 0x2
val ENOEXEC: int32 = 0x8
val ENOLCK: int32 = 0x4D
val ENOLINK: int32 = 0x61
val ENOMEM: int32 = 0xC
val ENOMSG: int32 = 0x5B
val ENOPROTOOPT: int32 = 0x2A
val ENOSPC: int32 = 0x1C
val ENOSR: int32 = 0x62
val ENOSTR: int32 = 0x63
val ENOSYS: int32 = 0x4E
val ENOTCONN: int32 = 0x39
val ENOTDIR: int32 = 0x14
val ENOTEMPTY: int32 = 0x42
val ENOTSOCK: int32 = 0x26
val ENOTSUP: int32 = 0x2D
val ENOTTY: int32 = 0x19
val ENXIO: int32 = 0x6
val EOPNOTSUPP: int32 = 0x66
val EOVERFLOW: int32 = 0x54
val EPERM: int32 = 0x1
val EPIPE: int32 = 0x20
val EPROTO: int32 = 0x64
val EPROTONOSUPPORT: int32 = 0x2B
val EPROTOTYPE: int32 = 0x29
val ERANGE: int32 = 0x22
val EROFS: int32 = 0x1E
val ESPIPE: int32 = 0x1D
val ESRCH: int32 = 0x3
val ESTALE: int32 = 0x46
val ETIME: int32 = 0x65
val ETIMEDOUT: int32 = 0x3C
val ETXTBSY: int32 = 0x1A
val EWOULDBLOCK: int32 = 0x23
val EXDEV: int32 = 0x12
val strError: int32 -> word64 =
   (fn x_666: int32 =>
    Posix_Error_strError (x_666))
val abs: real32 -> real32 = (fn x_667: real32 => Real32_abs (x_667))
val add: real32 * real32 -> real32 =
   (fn x_668: real32 * real32 =>
    case x_668 of
      (x_670: real32, x_669: real32) => Real32_add (x_670, x_669))
val class: real32 -> int32 = (fn x_671: real32 => Real32_class (x_671))
val div: real32 * real32 -> real32 =
   (fn x_672: real32 * real32 =>
    case x_672 of
      (x_674: real32, x_673: real32) => Real32_div (x_674, x_673))
val equal: real32 * real32 -> bool =
   (fn x_675: real32 * real32 =>
    case x_675 of
      (x_677: real32, x_676: real32) => Real32_equal (x_677, x_676))
val frexp: real32 * int32 ref -> real32 =
   (fn x_678: real32 * int32 ref =>
    case x_678 of
      (x_680: real32, x_679: int32 ref) => Real32_frexp (x_680, x_679))
val gdtoa: real32 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_681: real32 * int32 * int32 * int32 * int32 ref =>
    case x_681 of
      (x_686: real32, x_685: int32, x_684: int32, x_683: int32, x_682: int32 ref) =>
      Real32_gdtoa (x_686, x_685, x_684, x_683, x_682))
val ldexp: real32 * int32 -> real32 =
   (fn x_687: real32 * int32 =>
    case x_687 of
      (x_689: real32, x_688: int32) => Real32_ldexp (x_689, x_688))
val le: real32 * real32 -> bool =
   (fn x_690: real32 * real32 =>
    case x_690 of
      (x_692: real32, x_691: real32) => Real32_le (x_692, x_691))
val lt: real32 * real32 -> bool =
   (fn x_693: real32 * real32 =>
    case x_693 of
      (x_695: real32, x_694: real32) => Real32_lt (x_695, x_694))
val acos: real32 -> real32 = (fn x_696: real32 => Real32_Math_acos (x_696))
val asin: real32 -> real32 = (fn x_697: real32 => Real32_Math_asin (x_697))
val atan: real32 -> real32 = (fn x_698: real32 => Real32_Math_atan (x_698))
val atan2: real32 * real32 -> real32 =
   (fn x_699: real32 * real32 =>
    case x_699 of
      (x_701: real32, x_700: real32) => Real32_Math_atan2 (x_701, x_700))
val cos: real32 -> real32 = (fn x_702: real32 => Real32_Math_cos (x_702))
val cosh: real32 -> real32 = (fn x_703: real32 => Real32_Math_cosh (x_703))
val (eGet: unit -> real32, eSet: real32 -> unit) =
   ((fn x_705: unit =>
     CPointer_getReal32 (Real32_Math_e (), 0x0)),
    (fn x_704: real32 =>
     CPointer_setReal32 (Real32_Math_e (), 0x0, x_704)))
val exp: real32 -> real32 = (fn x_706: real32 => Real32_Math_exp (x_706))
val ln: real32 -> real32 = (fn x_707: real32 => Real32_Math_ln (x_707))
val log10: real32 -> real32 = (fn x_708: real32 => Real32_Math_log10 (x_708))
val (piGet: unit -> real32, piSet: real32 -> unit) =
   ((fn x_710: unit =>
     CPointer_getReal32 (Real32_Math_pi (), 0x0)),
    (fn x_709: real32 =>
     CPointer_setReal32 (Real32_Math_pi (), 0x0, x_709)))
val pow: real32 * real32 -> real32 =
   (fn x_711: real32 * real32 =>
    case x_711 of
      (x_713: real32, x_712: real32) => Real32_Math_pow (x_713, x_712))
val sin: real32 -> real32 = (fn x_714: real32 => Real32_Math_sin (x_714))
val sinh: real32 -> real32 = (fn x_715: real32 => Real32_Math_sinh (x_715))
val sqrt: real32 -> real32 = (fn x_716: real32 => Real32_Math_sqrt (x_716))
val tan: real32 -> real32 = (fn x_717: real32 => Real32_Math_tan (x_717))
val tanh: real32 -> real32 = (fn x_718: real32 => Real32_Math_tanh (x_718))
val (maxFiniteGet: unit -> real32, maxFiniteSet: real32 -> unit) =
   ((fn x_720: unit =>
     CPointer_getReal32 (Real32_maxFinite (), 0x0)),
    (fn x_719: real32 =>
     CPointer_setReal32 (Real32_maxFinite (), 0x0, x_719)))
val (minNormalPosGet: unit -> real32, minNormalPosSet: real32 -> unit) =
   ((fn x_722: unit =>
     CPointer_getReal32 (Real32_minNormalPos (), 0x0)),
    (fn x_721: real32 =>
     CPointer_setReal32 (Real32_minNormalPos (), 0x0, x_721)))
val (minPosGet: unit -> real32, minPosSet: real32 -> unit) =
   ((fn x_724: unit =>
     CPointer_getReal32 (Real32_minPos (), 0x0)),
    (fn x_723: real32 =>
     CPointer_setReal32 (Real32_minPos (), 0x0, x_723)))
val modf: real32 * real32 ref -> real32 =
   (fn x_725: real32 * real32 ref =>
    case x_725 of
      (x_727: real32, x_726: real32 ref) => Real32_modf (x_727, x_726))
val mul: real32 * real32 -> real32 =
   (fn x_728: real32 * real32 =>
    case x_728 of
      (x_730: real32, x_729: real32) => Real32_mul (x_730, x_729))
val muladd: real32 * real32 * real32 -> real32 =
   (fn x_731: real32 * real32 * real32 =>
    case x_731 of
      (x_734: real32, x_733: real32, x_732: real32) =>
      Real32_muladd (x_734, x_733, x_732))
val mulsub: real32 * real32 * real32 -> real32 =
   (fn x_735: real32 * real32 * real32 =>
    case x_735 of
      (x_738: real32, x_737: real32, x_736: real32) =>
      Real32_mulsub (x_738, x_737, x_736))
val neg: real32 -> real32 = (fn x_739: real32 => Real32_neg (x_739))
val round: real32 -> real32 = (fn x_740: real32 => Real32_round (x_740))
val signBit: real32 -> int32 = (fn x_741: real32 => Real32_signBit (x_741))
val strto: string * int32 -> real32 =
   (fn x_742: string * int32 =>
    case x_742 of
      (x_744: string, x_743: int32) => Real32_strto (x_744, x_743))
val sub: real32 * real32 -> real32 =
   (fn x_745: real32 * real32 =>
    case x_745 of
      (x_747: real32, x_746: real32) => Real32_sub (x_747, x_746))
val abs: real64 -> real64 = (fn x_748: real64 => Real64_abs (x_748))
val add: real64 * real64 -> real64 =
   (fn x_749: real64 * real64 =>
    case x_749 of
      (x_751: real64, x_750: real64) => Real64_add (x_751, x_750))
val class: real64 -> int32 = (fn x_752: real64 => Real64_class (x_752))
val div: real64 * real64 -> real64 =
   (fn x_753: real64 * real64 =>
    case x_753 of
      (x_755: real64, x_754: real64) => Real64_div (x_755, x_754))
val equal: real64 * real64 -> bool =
   (fn x_756: real64 * real64 =>
    case x_756 of
      (x_758: real64, x_757: real64) => Real64_equal (x_758, x_757))
val frexp: real64 * int32 ref -> real64 =
   (fn x_759: real64 * int32 ref =>
    case x_759 of
      (x_761: real64, x_760: int32 ref) => Real64_frexp (x_761, x_760))
val gdtoa: real64 * int32 * int32 * int32 * int32 ref -> word64 =
   (fn x_762: real64 * int32 * int32 * int32 * int32 ref =>
    case x_762 of
      (x_767: real64, x_766: int32, x_765: int32, x_764: int32, x_763: int32 ref) =>
      Real64_gdtoa (x_767, x_766, x_765, x_764, x_763))
val ldexp: real64 * int32 -> real64 =
   (fn x_768: real64 * int32 =>
    case x_768 of
      (x_770: real64, x_769: int32) => Real64_ldexp (x_770, x_769))
val le: real64 * real64 -> bool =
   (fn x_771: real64 * real64 =>
    case x_771 of
      (x_773: real64, x_772: real64) => Real64_le (x_773, x_772))
val lt: real64 * real64 -> bool =
   (fn x_774: real64 * real64 =>
    case x_774 of
      (x_776: real64, x_775: real64) => Real64_lt (x_776, x_775))
val acos: real64 -> real64 = (fn x_777: real64 => Real64_Math_acos (x_777))
val asin: real64 -> real64 = (fn x_778: real64 => Real64_Math_asin (x_778))
val atan: real64 -> real64 = (fn x_779: real64 => Real64_Math_atan (x_779))
val atan2: real64 * real64 -> real64 =
   (fn x_780: real64 * real64 =>
    case x_780 of
      (x_782: real64, x_781: real64) => Real64_Math_atan2 (x_782, x_781))
val cos: real64 -> real64 = (fn x_783: real64 => Real64_Math_cos (x_783))
val cosh: real64 -> real64 = (fn x_784: real64 => Real64_Math_cosh (x_784))
val (eGet: unit -> real64, eSet: real64 -> unit) =
   ((fn x_786: unit =>
     CPointer_getReal64 (Real64_Math_e (), 0x0)),
    (fn x_785: real64 =>
     CPointer_setReal64 (Real64_Math_e (), 0x0, x_785)))
val exp: real64 -> real64 = (fn x_787: real64 => Real64_Math_exp (x_787))
val ln: real64 -> real64 = (fn x_788: real64 => Real64_Math_ln (x_788))
val log10: real64 -> real64 = (fn x_789: real64 => Real64_Math_log10 (x_789))
val (piGet: unit -> real64, piSet: real64 -> unit) =
   ((fn x_791: unit =>
     CPointer_getReal64 (Real64_Math_pi (), 0x0)),
    (fn x_790: real64 =>
     CPointer_setReal64 (Real64_Math_pi (), 0x0, x_790)))
val pow: real64 * real64 -> real64 =
   (fn x_792: real64 * real64 =>
    case x_792 of
      (x_794: real64, x_793: real64) => Real64_Math_pow (x_794, x_793))
val sin: real64 -> real64 = (fn x_795: real64 => Real64_Math_sin (x_795))
val sinh: real64 -> real64 = (fn x_796: real64 => Real64_Math_sinh (x_796))
val sqrt: real64 -> real64 = (fn x_797: real64 => Real64_Math_sqrt (x_797))
val tan: real64 -> real64 = (fn x_798: real64 => Real64_Math_tan (x_798))
val tanh: real64 -> real64 = (fn x_799: real64 => Real64_Math_tanh (x_799))
val (maxFiniteGet: unit -> real64, maxFiniteSet: real64 -> unit) =
   ((fn x_801: unit =>
     CPointer_getReal64 (Real64_maxFinite (), 0x0)),
    (fn x_800: real64 =>
     CPointer_setReal64 (Real64_maxFinite (), 0x0, x_800)))
val (minNormalPosGet: unit -> real64, minNormalPosSet: real64 -> unit) =
   ((fn x_803: unit =>
     CPointer_getReal64 (Real64_minNormalPos (), 0x0)),
    (fn x_802: real64 =>
     CPointer_setReal64 (Real64_minNormalPos (), 0x0, x_802)))
val (minPosGet: unit -> real64, minPosSet: real64 -> unit) =
   ((fn x_805: unit =>
     CPointer_getReal64 (Real64_minPos (), 0x0)),
    (fn x_804: real64 =>
     CPointer_setReal64 (Real64_minPos (), 0x0, x_804)))
val modf: real64 * real64 ref -> real64 =
   (fn x_806: real64 * real64 ref =>
    case x_806 of
      (x_808: real64, x_807: real64 ref) => Real64_modf (x_808, x_807))
val mul: real64 * real64 -> real64 =
   (fn x_809: real64 * real64 =>
    case x_809 of
      (x_811: real64, x_810: real64) => Real64_mul (x_811, x_810))
val muladd: real64 * real64 * real64 -> real64 =
   (fn x_812: real64 * real64 * real64 =>
    case x_812 of
      (x_815: real64, x_814: real64, x_813: real64) =>
      Real64_muladd (x_815, x_814, x_813))
val mulsub: real64 * real64 * real64 -> real64 =
   (fn x_816: real64 * real64 * real64 =>
    case x_816 of
      (x_819: real64, x_818: real64, x_817: real64) =>
      Real64_mulsub (x_819, x_818, x_817))
val neg: real64 -> real64 = (fn x_820: real64 => Real64_neg (x_820))
val round: real64 -> real64 = (fn x_821: real64 => Real64_round (x_821))
val signBit: real64 -> int32 = (fn x_822: real64 => Real64_signBit (x_822))
val strto: string * int32 -> real64 =
   (fn x_823: string * int32 =>
    case x_823 of
      (x_825: string, x_824: int32) => Real64_strto (x_825, x_824))
val sub: real64 * real64 -> real64 =
   (fn x_826: real64 * real64 =>
    case x_826 of
      (x_828: real64, x_827: real64) => Real64_sub (x_828, x_827))
val print: string -> unit = (fn x_829: string => Stdio_print (x_829))
val bug: string -> unit = bug
val _ =
   (setHandler (fn x_830: exn =>
		case x_830 of
		  exn: exn =>
		  (print "unhandled exception: ")
		  ;case exn of
		     Fail8 msg: string => (print "Fail ") ;(print msg)
		   | _ => (print (name exn))
		  ;(print "
")
		  ;(bug "unhandled exception in Basis Library")))
val _ =
   (setSuffix (fn x_831: unit =>
	       case x_831 of
		 () => (halt 0x0) ;(bug "missing suffix in Basis Library")))
val rec 'a
   check: 'a * 'a -> unit = 
      (fn x_832: 'a * 'a =>
       case x_832 of
	 ((_, _)) => ())
val () = (check (real32 -> real32) (acos, acos))
val () = (check (real32 -> real32) (asin, asin))
val () = (check (real32 -> real32) (atan, atan))
val () = (check (real32 * real32 -> real32) (atan2, atan2))
val () = (check (real32 -> real32) (cos, cos))
val () = (check (real32 -> real32) (cosh, cosh))
val () =
   (check (unit -> real32) ((fn x_833: unit => case x_833 of () => e), eGet))
val () = (check (real32 -> real32) (exp, exp))
val () = (check (real32 -> real32) (ln, ln))
val () = (check (real32 -> real32) (log10, log10))
val () =
   (check (unit -> real32) ((fn x_834: unit => case x_834 of () => pi), piGet))
val () = (check (real32 * real32 -> real32) (pow, pow))
val () = (check (real32 -> real32) (sin, sin))
val () = (check (real32 -> real32) (sinh, sinh))
val () = (check (real32 -> real32) (sqrt, sqrt))
val () = (check (real32 -> real32) (tan, tan))
val () = (check (real32 -> real32) (tanh, tanh))
val () = (check (real32 -> real32) (abs, abs))
val () = (check (real32 * real32 -> real32) (+, add))
val () = (check (real32 -> int32) (class, class))
val () = (check (real32 * real32 -> real32) (/, div))
val () = (check (real32 * real32 -> bool) (==, equal))
val () = (check (real32 * int32 ref -> real32) (frexp, frexp))
val () =
   (check (real32 * int32 * int32 * int32 * int32 ref -> word64) (gdtoa, gdtoa))
val () = (check (real32 * int32 -> real32) (ldexp, ldexp))
val () = (check (real32 * real32 -> bool) (<=, le))
val () = (check (real32 * real32 -> bool) (<, lt))
val () =
   (check (unit -> real32) ((fn x_835: unit =>
			     case x_835 of
			       () => maxFinite),
			    maxFiniteGet))
val () =
   (check (unit -> real32) ((fn x_836: unit =>
			     case x_836 of
			       () => minNormalPos),
			    minNormalPosGet))
val () =
   (check (unit -> real32) ((fn x_837: unit =>
			     case x_837 of
			       () => minPos),
			    minPosGet))
val () = (check (real32 * real32 ref -> real32) (modf, modf))
val () = (check (real32 * real32 -> real32) (*, mul))
val () = (check (real32 * real32 * real32 -> real32) (*+, muladd))
val () = (check (real32 * real32 * real32 -> real32) (*-, mulsub))
val () = (check (real32 -> real32) (~, neg))
val () = (check (real32 -> real32) (round, round))
val () = (check (real32 -> int32) (signBit, signBit))
val () = (check (string * int32 -> real32) (strto, strto))
val () = (check (real32 * real32 -> real32) (-, sub))
val () = (check (real64 -> real64) (acos, acos))
val () = (check (real64 -> real64) (asin, asin))
val () = (check (real64 -> real64) (atan, atan))
val () = (check (real64 * real64 -> real64) (atan2, atan2))
val () = (check (real64 -> real64) (cos, cos))
val () = (check (real64 -> real64) (cosh, cosh))
val () =
   (check (unit -> real64) ((fn x_838: unit => case x_838 of () => e), eGet))
val () = (check (real64 -> real64) (exp, exp))
val () = (check (real64 -> real64) (ln, ln))
val () = (check (real64 -> real64) (log10, log10))
val () =
   (check (unit -> real64) ((fn x_839: unit => case x_839 of () => pi), piGet))
val () = (check (real64 * real64 -> real64) (pow, pow))
val () = (check (real64 -> real64) (sin, sin))
val () = (check (real64 -> real64) (sinh, sinh))
val () = (check (real64 -> real64) (sqrt, sqrt))
val () = (check (real64 -> real64) (tan, tan))
val () = (check (real64 -> real64) (tanh, tanh))
val () = (check (real64 -> real64) (abs, abs))
val () = (check (real64 * real64 -> real64) (+, add))
val () = (check (real64 -> int32) (class, class))
val () = (check (real64 * real64 -> real64) (/, div))
val () = (check (real64 * real64 -> bool) (==, equal))
val () = (check (real64 * int32 ref -> real64) (frexp, frexp))
val () =
   (check (real64 * int32 * int32 * int32 * int32 ref -> word64) (gdtoa, gdtoa))
val () = (check (real64 * int32 -> real64) (ldexp, ldexp))
val () = (check (real64 * real64 -> bool) (<=, le))
val () = (check (real64 * real64 -> bool) (<, lt))
val () =
   (check (unit -> real64) ((fn x_840: unit =>
			     case x_840 of
			       () => maxFinite),
			    maxFiniteGet))
val () =
   (check (unit -> real64) ((fn x_841: unit =>
			     case x_841 of
			       () => minNormalPos),
			    minNormalPosGet))
val () =
   (check (unit -> real64) ((fn x_842: unit =>
			     case x_842 of
			       () => minPos),
			    minPosGet))
val () = (check (real64 * real64 ref -> real64) (modf, modf))
val () = (check (real64 * real64 -> real64) (*, mul))
val () = (check (real64 * real64 * real64 -> real64) (*+, muladd))
val () = (check (real64 * real64 * real64 -> real64) (*-, mulsub))
val () = (check (real64 -> real64) (~, neg))
val () = (check (real64 -> real64) (round, round))
val () = (check (real64 -> int32) (signBit, signBit))
val () = (check (string * int32 -> real64) (strto, strto))
val () = (check (real64 * real64 -> real64) (-, sub))
val rec ('a, 'b)
   try: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) -> 'b = 
      (fn x_843: (unit -> 'a) * ('a -> 'b) * (exn -> 'b) =>
       case x_843 of
	 ((f: unit -> 'a, k: 'a -> 'b, h: exn -> 'b)) =>
	 let datatype DynamicWind.try.t = A of 'a
					  | E of exn
	 in
	    case (A (f ()))
		 handle x_844 => case x_844 of
				   e: exn => (E e) of
	      A a: 'a => (k a) | E e: exn => (h e)
	 end)
val rec 'a_174
   wind: (unit -> 'a_174) * (unit -> unit) -> 'a_174 = 
      (fn x_845: (unit -> 'a_174) * (unit -> unit) =>
       case x_845 of
	 ((thunk: unit -> 'a_174, cleanup: unit -> unit)) =>
	 (try ('a_174, 'a_174) (thunk,
				(fn x_847: 'a_174 =>
				 case x_847 of
				   a: 'a_174 => (cleanup ()) ;a),
				(fn x_846: exn =>
				 case x_846 of
				   e: exn => (cleanup ()) ;raise e))))
val 'a wind_0: (unit -> 'a) * (unit -> unit) -> 'a = wind ('a)
val castFromInt8ToInt8: int8 -> int8 = sextdFromInt8ToInt8
val castFromInt8ToInt16: int8 -> int16 = sextdFromInt8ToInt16
val castFromInt8ToInt32: int8 -> int32 = sextdFromInt8ToInt32
val castFromInt8ToInt64: int8 -> int64 = sextdFromInt8ToInt64
val castFromInt8ToWord8: int8 -> word8 = sextdFromInt8ToWord8
val castFromInt8ToWord16: int8 -> word16 = sextdFromInt8ToWord16
val castFromInt8ToWord32: int8 -> word32 = sextdFromInt8ToWord32
val castFromInt8ToWord64: int8 -> word64 = sextdFromInt8ToWord64
val castFromInt16ToInt8: int16 -> int8 = sextdFromInt16ToInt8
val castFromInt16ToInt16: int16 -> int16 = sextdFromInt16ToInt16
val castFromInt16ToInt32: int16 -> int32 = sextdFromInt16ToInt32
val castFromInt16ToInt64: int16 -> int64 = sextdFromInt16ToInt64
val castFromInt16ToWord8: int16 -> word8 = sextdFromInt16ToWord8
val castFromInt16ToWord16: int16 -> word16 = sextdFromInt16ToWord16
val castFromInt16ToWord32: int16 -> word32 = sextdFromInt16ToWord32
val castFromInt16ToWord64: int16 -> word64 = sextdFromInt16ToWord64
val castFromInt32ToInt8: int32 -> int8 = sextdFromInt32ToInt8
val castFromInt32ToInt16: int32 -> int16 = sextdFromInt32ToInt16
val castFromInt32ToInt32: int32 -> int32 = sextdFromInt32ToInt32
val castFromInt32ToInt64: int32 -> int64 = sextdFromInt32ToInt64
val castFromInt32ToWord8: int32 -> word8 = sextdFromInt32ToWord8
val castFromInt32ToWord16: int32 -> word16 = sextdFromInt32ToWord16
val castFromInt32ToWord32: int32 -> word32 = sextdFromInt32ToWord32
val castFromInt32ToWord64: int32 -> word64 = sextdFromInt32ToWord64
val castFromInt64ToInt8: int64 -> int8 = sextdFromInt64ToInt8
val castFromInt64ToInt16: int64 -> int16 = sextdFromInt64ToInt16
val castFromInt64ToInt32: int64 -> int32 = sextdFromInt64ToInt32
val castFromInt64ToInt64: int64 -> int64 = sextdFromInt64ToInt64
val castFromInt64ToWord8: int64 -> word8 = sextdFromInt64ToWord8
val castFromInt64ToWord16: int64 -> word16 = sextdFromInt64ToWord16
val castFromInt64ToWord32: int64 -> word32 = sextdFromInt64ToWord32
val castFromInt64ToWord64: int64 -> word64 = sextdFromInt64ToWord64
val castFromWord8ToInt8: word8 -> int8 = zextdFromWord8ToInt8
val castFromWord8ToInt16: word8 -> int16 = zextdFromWord8ToInt16
val castFromWord8ToInt32: word8 -> int32 = zextdFromWord8ToInt32
val castFromWord8ToInt64: word8 -> int64 = zextdFromWord8ToInt64
val castFromWord8ToWord8: word8 -> word8 = zextdFromWord8ToWord8
val castFromWord8ToWord16: word8 -> word16 = zextdFromWord8ToWord16
val castFromWord8ToWord32: word8 -> word32 = zextdFromWord8ToWord32
val castFromWord8ToWord64: word8 -> word64 = zextdFromWord8ToWord64
val castFromWord16ToInt8: word16 -> int8 = zextdFromWord16ToInt8
val castFromWord16ToInt16: word16 -> int16 = zextdFromWord16ToInt16
val castFromWord16ToInt32: word16 -> int32 = zextdFromWord16ToInt32
val castFromWord16ToInt64: word16 -> int64 = zextdFromWord16ToInt64
val castFromWord16ToWord8: word16 -> word8 = zextdFromWord16ToWord8
val castFromWord16ToWord16: word16 -> word16 = zextdFromWord16ToWord16
val castFromWord16ToWord32: word16 -> word32 = zextdFromWord16ToWord32
val castFromWord16ToWord64: word16 -> word64 = zextdFromWord16ToWord64
val castFromWord32ToInt8: word32 -> int8 = zextdFromWord32ToInt8
val castFromWord32ToInt16: word32 -> int16 = zextdFromWord32ToInt16
val castFromWord32ToInt32: word32 -> int32 = zextdFromWord32ToInt32
val castFromWord32ToInt64: word32 -> int64 = zextdFromWord32ToInt64
val castFromWord32ToWord8: word32 -> word8 = zextdFromWord32ToWord8
val castFromWord32ToWord16: word32 -> word16 = zextdFromWord32ToWord16
val castFromWord32ToWord32: word32 -> word32 = zextdFromWord32ToWord32
val castFromWord32ToWord64: word32 -> word64 = zextdFromWord32ToWord64
val castFromWord64ToInt8: word64 -> int8 = zextdFromWord64ToInt8
val castFromWord64ToInt16: word64 -> int16 = zextdFromWord64ToInt16
val castFromWord64ToInt32: word64 -> int32 = zextdFromWord64ToInt32
val castFromWord64ToInt64: word64 -> int64 = zextdFromWord64ToInt64
val castFromWord64ToWord8: word64 -> word8 = zextdFromWord64ToWord8
val castFromWord64ToWord16: word64 -> word16 = zextdFromWord64ToWord16
val castFromWord64ToWord32: word64 -> word32 = zextdFromWord64ToWord32
val castFromWord64ToWord64: word64 -> word64 = zextdFromWord64ToWord64
val rec (''s, ''l)
   make: {zextdFromLargeToSmall: ''l -> ''s, zextdFromSmallToLarge: ''s -> ''l}
	 -> ''l -> ''s = 
      (fn x_848: {zextdFromLargeToSmall: ''l -> ''s,
		  zextdFromSmallToLarge: ''s -> ''l} =>
       case x_848 of
	 ({zextdFromLargeToSmall = zextdFromLargeToSmall: ''l -> ''s,
	   zextdFromSmallToLarge = zextdFromSmallToLarge: ''s -> ''l}) =>
	 case detectOverflow of
	   true =>
	   (fn x_849: ''l =>
	    case x_849 of
	      x: ''l =>
	      let val res: ''s = (zextdFromLargeToSmall x)
	      in
		 case (= (''l) (x, (zextdFromSmallToLarge res))) of
		   true => res | false => raise Overflow
	      end)
	 | false => zextdFromLargeToSmall)
val zchckFromInt8ToInt8: int8 -> int8 = zextdFromInt8ToInt8
val zchckFromInt8ToInt16: int8 -> int16 = zextdFromInt8ToInt16
val zchckFromInt8ToInt32: int8 -> int32 = zextdFromInt8ToInt32
val zchckFromInt8ToInt64: int8 -> int64 = zextdFromInt8ToInt64
val zchckFromInt8ToWord8: int8 -> word8 = zextdFromInt8ToWord8
val zchckFromInt8ToWord16: int8 -> word16 = zextdFromInt8ToWord16
val zchckFromInt8ToWord32: int8 -> word32 = zextdFromInt8ToWord32
val zchckFromInt8ToWord64: int8 -> word64 = zextdFromInt8ToWord64
val zchckFromInt16ToInt8: int16 -> int8 =
   (make (int8, int16) {zextdFromLargeToSmall = zextdFromInt16ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt16})
val zchckFromInt16ToInt16: int16 -> int16 = zextdFromInt16ToInt16
val zchckFromInt16ToInt32: int16 -> int32 = zextdFromInt16ToInt32
val zchckFromInt16ToInt64: int16 -> int64 = zextdFromInt16ToInt64
val zchckFromInt16ToWord8: int16 -> word8 =
   (make (word8, int16) {zextdFromLargeToSmall = zextdFromInt16ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt16})
val zchckFromInt16ToWord16: int16 -> word16 = zextdFromInt16ToWord16
val zchckFromInt16ToWord32: int16 -> word32 = zextdFromInt16ToWord32
val zchckFromInt16ToWord64: int16 -> word64 = zextdFromInt16ToWord64
val zchckFromInt32ToInt8: int32 -> int8 =
   (make (int8, int32) {zextdFromLargeToSmall = zextdFromInt32ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt32})
val zchckFromInt32ToInt16: int32 -> int16 =
   (make (int16, int32) {zextdFromLargeToSmall = zextdFromInt32ToInt16,
			 zextdFromSmallToLarge = zextdFromInt16ToInt32})
val zchckFromInt32ToInt32: int32 -> int32 = zextdFromInt32ToInt32
val zchckFromInt32ToInt64: int32 -> int64 = zextdFromInt32ToInt64
val zchckFromInt32ToWord8: int32 -> word8 =
   (make (word8, int32) {zextdFromLargeToSmall = zextdFromInt32ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt32})
val zchckFromInt32ToWord16: int32 -> word16 =
   (make (word16, int32) {zextdFromLargeToSmall = zextdFromInt32ToWord16,
			  zextdFromSmallToLarge = zextdFromWord16ToInt32})
val zchckFromInt32ToWord32: int32 -> word32 = zextdFromInt32ToWord32
val zchckFromInt32ToWord64: int32 -> word64 = zextdFromInt32ToWord64
val zchckFromInt64ToInt8: int64 -> int8 =
   (make (int8, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt8,
			zextdFromSmallToLarge = zextdFromInt8ToInt64})
val zchckFromInt64ToInt16: int64 -> int16 =
   (make (int16, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt16,
			 zextdFromSmallToLarge = zextdFromInt16ToInt64})
val zchckFromInt64ToInt32: int64 -> int32 =
   (make (int32, int64) {zextdFromLargeToSmall = zextdFromInt64ToInt32,
			 zextdFromSmallToLarge = zextdFromInt32ToInt64})
val zchckFromInt64ToInt64: int64 -> int64 = zextdFromInt64ToInt64
val zchckFromInt64ToWord8: int64 -> word8 =
   (make (word8, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord8,
			 zextdFromSmallToLarge = zextdFromWord8ToInt64})
val zchckFromInt64ToWord16: int64 -> word16 =
   (make (word16, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord16,
			  zextdFromSmallToLarge = zextdFromWord16ToInt64})
val zchckFromInt64ToWord32: int64 -> word32 =
   (make (word32, int64) {zextdFromLargeToSmall = zextdFromInt64ToWord32,
			  zextdFromSmallToLarge = zextdFromWord32ToInt64})
val zchckFromInt64ToWord64: int64 -> word64 = zextdFromInt64ToWord64
val zchckFromWord8ToInt8: word8 -> int8 = zextdFromWord8ToInt8
val zchckFromWord8ToInt16: word8 -> int16 = zextdFromWord8ToInt16
val zchckFromWord8ToInt32: word8 -> int32 = zextdFromWord8ToInt32
val zchckFromWord8ToInt64: word8 -> int64 = zextdFromWord8ToInt64
val zchckFromWord8ToWord8: word8 -> word8 = zextdFromWord8ToWord8
val zchckFromWord8ToWord16: word8 -> word16 = zextdFromWord8ToWord16
val zchckFromWord8ToWord32: word8 -> word32 = zextdFromWord8ToWord32
val zchckFromWord8ToWord64: word8 -> word64 = zextdFromWord8ToWord64
val zchckFromWord16ToInt8: word16 -> int8 =
   (make (int8, word16) {zextdFromLargeToSmall = zextdFromWord16ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord16})
val zchckFromWord16ToInt16: word16 -> int16 = zextdFromWord16ToInt16
val zchckFromWord16ToInt32: word16 -> int32 = zextdFromWord16ToInt32
val zchckFromWord16ToInt64: word16 -> int64 = zextdFromWord16ToInt64
val zchckFromWord16ToWord8: word16 -> word8 =
   (make (word8, word16) {zextdFromLargeToSmall = zextdFromWord16ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord16})
val zchckFromWord16ToWord16: word16 -> word16 = zextdFromWord16ToWord16
val zchckFromWord16ToWord32: word16 -> word32 = zextdFromWord16ToWord32
val zchckFromWord16ToWord64: word16 -> word64 = zextdFromWord16ToWord64
val zchckFromWord32ToInt8: word32 -> int8 =
   (make (int8, word32) {zextdFromLargeToSmall = zextdFromWord32ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord32})
val zchckFromWord32ToInt16: word32 -> int16 =
   (make (int16, word32) {zextdFromLargeToSmall = zextdFromWord32ToInt16,
			  zextdFromSmallToLarge = zextdFromInt16ToWord32})
val zchckFromWord32ToInt32: word32 -> int32 = zextdFromWord32ToInt32
val zchckFromWord32ToInt64: word32 -> int64 = zextdFromWord32ToInt64
val zchckFromWord32ToWord8: word32 -> word8 =
   (make (word8, word32) {zextdFromLargeToSmall = zextdFromWord32ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord32})
val zchckFromWord32ToWord16: word32 -> word16 =
   (make (word16, word32) {zextdFromLargeToSmall = zextdFromWord32ToWord16,
			   zextdFromSmallToLarge = zextdFromWord16ToWord32})
val zchckFromWord32ToWord32: word32 -> word32 = zextdFromWord32ToWord32
val zchckFromWord32ToWord64: word32 -> word64 = zextdFromWord32ToWord64
val zchckFromWord64ToInt8: word64 -> int8 =
   (make (int8, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt8,
			 zextdFromSmallToLarge = zextdFromInt8ToWord64})
val zchckFromWord64ToInt16: word64 -> int16 =
   (make (int16, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt16,
			  zextdFromSmallToLarge = zextdFromInt16ToWord64})
val zchckFromWord64ToInt32: word64 -> int32 =
   (make (int32, word64) {zextdFromLargeToSmall = zextdFromWord64ToInt32,
			  zextdFromSmallToLarge = zextdFromInt32ToWord64})
val zchckFromWord64ToInt64: word64 -> int64 = zextdFromWord64ToInt64
val zchckFromWord64ToWord8: word64 -> word8 =
   (make (word8, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord8,
			  zextdFromSmallToLarge = zextdFromWord8ToWord64})
val zchckFromWord64ToWord16: word64 -> word16 =
   (make (word16, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord16,
			   zextdFromSmallToLarge = zextdFromWord16ToWord64})
val zchckFromWord64ToWord32: word64 -> word32 =
   (make (word32, word64) {zextdFromLargeToSmall = zextdFromWord64ToWord32,
			   zextdFromSmallToLarge = zextdFromWord32ToWord64})
val zchckFromWord64ToWord64: word64 -> word64 = zextdFromWord64ToWord64
val rec (''s, ''l)
   make: {sextdFromLargeToSmall: ''l -> ''s, sextdFromSmallToLarge: ''s -> ''l}
	 -> ''l -> ''s = 
      (fn x_850: {sextdFromLargeToSmall: ''l -> ''s,
		  sextdFromSmallToLarge: ''s -> ''l} =>
       case x_850 of
	 ({sextdFromLargeToSmall = sextdFromLargeToSmall: ''l -> ''s,
	   sextdFromSmallToLarge = sextdFromSmallToLarge: ''s -> ''l}) =>
	 case detectOverflow of
	   true =>
	   (fn x_851: ''l =>
	    case x_851 of
	      x: ''l =>
	      let val res: ''s = (sextdFromLargeToSmall x)
	      in
		 case (= (''l) (x, (sextdFromSmallToLarge res))) of
		   true => res | false => raise Overflow
	      end)
	 | false => sextdFromLargeToSmall)
val schckFromInt8ToInt8: int8 -> int8 = sextdFromInt8ToInt8
val schckFromInt8ToInt16: int8 -> int16 = sextdFromInt8ToInt16
val schckFromInt8ToInt32: int8 -> int32 = sextdFromInt8ToInt32
val schckFromInt8ToInt64: int8 -> int64 = sextdFromInt8ToInt64
val schckFromInt8ToWord8: int8 -> word8 = sextdFromInt8ToWord8
val schckFromInt8ToWord16: int8 -> word16 = sextdFromInt8ToWord16
val schckFromInt8ToWord32: int8 -> word32 = sextdFromInt8ToWord32
val schckFromInt8ToWord64: int8 -> word64 = sextdFromInt8ToWord64
val schckFromInt16ToInt8: int16 -> int8 =
   (make (int8, int16) {sextdFromLargeToSmall = sextdFromInt16ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt16})
val schckFromInt16ToInt16: int16 -> int16 = sextdFromInt16ToInt16
val schckFromInt16ToInt32: int16 -> int32 = sextdFromInt16ToInt32
val schckFromInt16ToInt64: int16 -> int64 = sextdFromInt16ToInt64
val schckFromInt16ToWord8: int16 -> word8 =
   (make (word8, int16) {sextdFromLargeToSmall = sextdFromInt16ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt16})
val schckFromInt16ToWord16: int16 -> word16 = sextdFromInt16ToWord16
val schckFromInt16ToWord32: int16 -> word32 = sextdFromInt16ToWord32
val schckFromInt16ToWord64: int16 -> word64 = sextdFromInt16ToWord64
val schckFromInt32ToInt8: int32 -> int8 =
   (make (int8, int32) {sextdFromLargeToSmall = sextdFromInt32ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt32})
val schckFromInt32ToInt16: int32 -> int16 =
   (make (int16, int32) {sextdFromLargeToSmall = sextdFromInt32ToInt16,
			 sextdFromSmallToLarge = sextdFromInt16ToInt32})
val schckFromInt32ToInt32: int32 -> int32 = sextdFromInt32ToInt32
val schckFromInt32ToInt64: int32 -> int64 = sextdFromInt32ToInt64
val schckFromInt32ToWord8: int32 -> word8 =
   (make (word8, int32) {sextdFromLargeToSmall = sextdFromInt32ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt32})
val schckFromInt32ToWord16: int32 -> word16 =
   (make (word16, int32) {sextdFromLargeToSmall = sextdFromInt32ToWord16,
			  sextdFromSmallToLarge = sextdFromWord16ToInt32})
val schckFromInt32ToWord32: int32 -> word32 = sextdFromInt32ToWord32
val schckFromInt32ToWord64: int32 -> word64 = sextdFromInt32ToWord64
val schckFromInt64ToInt8: int64 -> int8 =
   (make (int8, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt8,
			sextdFromSmallToLarge = sextdFromInt8ToInt64})
val schckFromInt64ToInt16: int64 -> int16 =
   (make (int16, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt16,
			 sextdFromSmallToLarge = sextdFromInt16ToInt64})
val schckFromInt64ToInt32: int64 -> int32 =
   (make (int32, int64) {sextdFromLargeToSmall = sextdFromInt64ToInt32,
			 sextdFromSmallToLarge = sextdFromInt32ToInt64})
val schckFromInt64ToInt64: int64 -> int64 = sextdFromInt64ToInt64
val schckFromInt64ToWord8: int64 -> word8 =
   (make (word8, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord8,
			 sextdFromSmallToLarge = sextdFromWord8ToInt64})
val schckFromInt64ToWord16: int64 -> word16 =
   (make (word16, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord16,
			  sextdFromSmallToLarge = sextdFromWord16ToInt64})
val schckFromInt64ToWord32: int64 -> word32 =
   (make (word32, int64) {sextdFromLargeToSmall = sextdFromInt64ToWord32,
			  sextdFromSmallToLarge = sextdFromWord32ToInt64})
val schckFromInt64ToWord64: int64 -> word64 = sextdFromInt64ToWord64
val schckFromWord8ToInt8: word8 -> int8 = sextdFromWord8ToInt8
val schckFromWord8ToInt16: word8 -> int16 = sextdFromWord8ToInt16
val schckFromWord8ToInt32: word8 -> int32 = sextdFromWord8ToInt32
val schckFromWord8ToInt64: word8 -> int64 = sextdFromWord8ToInt64
val schckFromWord8ToWord8: word8 -> word8 = sextdFromWord8ToWord8
val schckFromWord8ToWord16: word8 -> word16 = sextdFromWord8ToWord16
val schckFromWord8ToWord32: word8 -> word32 = sextdFromWord8ToWord32
val schckFromWord8ToWord64: word8 -> word64 = sextdFromWord8ToWord64
val schckFromWord16ToInt8: word16 -> int8 =
   (make (int8, word16) {sextdFromLargeToSmall = sextdFromWord16ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord16})
val schckFromWord16ToInt16: word16 -> int16 = sextdFromWord16ToInt16
val schckFromWord16ToInt32: word16 -> int32 = sextdFromWord16ToInt32
val schckFromWord16ToInt64: word16 -> int64 = sextdFromWord16ToInt64
val schckFromWord16ToWord8: word16 -> word8 =
   (make (word8, word16) {sextdFromLargeToSmall = sextdFromWord16ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord16})
val schckFromWord16ToWord16: word16 -> word16 = sextdFromWord16ToWord16
val schckFromWord16ToWord32: word16 -> word32 = sextdFromWord16ToWord32
val schckFromWord16ToWord64: word16 -> word64 = sextdFromWord16ToWord64
val schckFromWord32ToInt8: word32 -> int8 =
   (make (int8, word32) {sextdFromLargeToSmall = sextdFromWord32ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord32})
val schckFromWord32ToInt16: word32 -> int16 =
   (make (int16, word32) {sextdFromLargeToSmall = sextdFromWord32ToInt16,
			  sextdFromSmallToLarge = sextdFromInt16ToWord32})
val schckFromWord32ToInt32: word32 -> int32 = sextdFromWord32ToInt32
val schckFromWord32ToInt64: word32 -> int64 = sextdFromWord32ToInt64
val schckFromWord32ToWord8: word32 -> word8 =
   (make (word8, word32) {sextdFromLargeToSmall = sextdFromWord32ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord32})
val schckFromWord32ToWord16: word32 -> word16 =
   (make (word16, word32) {sextdFromLargeToSmall = sextdFromWord32ToWord16,
			   sextdFromSmallToLarge = sextdFromWord16ToWord32})
val schckFromWord32ToWord32: word32 -> word32 = sextdFromWord32ToWord32
val schckFromWord32ToWord64: word32 -> word64 = sextdFromWord32ToWord64
val schckFromWord64ToInt8: word64 -> int8 =
   (make (int8, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt8,
			 sextdFromSmallToLarge = sextdFromInt8ToWord64})
val schckFromWord64ToInt16: word64 -> int16 =
   (make (int16, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt16,
			  sextdFromSmallToLarge = sextdFromInt16ToWord64})
val schckFromWord64ToInt32: word64 -> int32 =
   (make (int32, word64) {sextdFromLargeToSmall = sextdFromWord64ToInt32,
			  sextdFromSmallToLarge = sextdFromInt32ToWord64})
val schckFromWord64ToInt64: word64 -> int64 = sextdFromWord64ToInt64
val schckFromWord64ToWord8: word64 -> word8 =
   (make (word8, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord8,
			  sextdFromSmallToLarge = sextdFromWord8ToWord64})
val schckFromWord64ToWord16: word64 -> word16 =
   (make (word16, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord16,
			   sextdFromSmallToLarge = sextdFromWord16ToWord64})
val schckFromWord64ToWord32: word64 -> word32 =
   (make (word32, word64) {sextdFromLargeToSmall = sextdFromWord64ToWord32,
			   sextdFromSmallToLarge = sextdFromWord32ToWord64})
val schckFromWord64ToWord64: word64 -> word64 = sextdFromWord64ToWord64
val zextdFromInt8: int8 -> int8 = zextdFromInt8ToInt8
val zextdFromInt16: int16 -> int8 = zextdFromInt16ToInt8
val zextdFromInt32: int32 -> int8 = zextdFromInt32ToInt8
val zextdFromInt64: int64 -> int8 = zextdFromInt64ToInt8
val zextdFromWord8: word8 -> int8 = zextdFromWord8ToInt8
val zextdFromWord16: word16 -> int8 = zextdFromWord16ToInt8
val zextdFromWord32: word32 -> int8 = zextdFromWord32ToInt8
val zextdFromWord64: word64 -> int8 = zextdFromWord64ToInt8
val zextdToInt8: int8 -> int8 = zextdFromInt8ToInt8
val zextdToInt16: int8 -> int16 = zextdFromInt8ToInt16
val zextdToInt32: int8 -> int32 = zextdFromInt8ToInt32
val zextdToInt64: int8 -> int64 = zextdFromInt8ToInt64
val zextdToWord8: int8 -> word8 = zextdFromInt8ToWord8
val zextdToWord16: int8 -> word16 = zextdFromInt8ToWord16
val zextdToWord32: int8 -> word32 = zextdFromInt8ToWord32
val zextdToWord64: int8 -> word64 = zextdFromInt8ToWord64
val sextdFromInt8: int8 -> int8 = sextdFromInt8ToInt8
val sextdFromInt16: int16 -> int8 = sextdFromInt16ToInt8
val sextdFromInt32: int32 -> int8 = sextdFromInt32ToInt8
val sextdFromInt64: int64 -> int8 = sextdFromInt64ToInt8
val sextdFromWord8: word8 -> int8 = sextdFromWord8ToInt8
val sextdFromWord16: word16 -> int8 = sextdFromWord16ToInt8
val sextdFromWord32: word32 -> int8 = sextdFromWord32ToInt8
val sextdFromWord64: word64 -> int8 = sextdFromWord64ToInt8
val sextdToInt8: int8 -> int8 = sextdFromInt8ToInt8
val sextdToInt16: int8 -> int16 = sextdFromInt8ToInt16
val sextdToInt32: int8 -> int32 = sextdFromInt8ToInt32
val sextdToInt64: int8 -> int64 = sextdFromInt8ToInt64
val sextdToWord8: int8 -> word8 = sextdFromInt8ToWord8
val sextdToWord16: int8 -> word16 = sextdFromInt8ToWord16
val sextdToWord32: int8 -> word32 = sextdFromInt8ToWord32
val sextdToWord64: int8 -> word64 = sextdFromInt8ToWord64
val castFromInt8: int8 -> int8 = castFromInt8ToInt8
val castFromInt16: int16 -> int8 = castFromInt16ToInt8
val castFromInt32: int32 -> int8 = castFromInt32ToInt8
val castFromInt64: int64 -> int8 = castFromInt64ToInt8
val castFromWord8: word8 -> int8 = castFromWord8ToInt8
val castFromWord16: word16 -> int8 = castFromWord16ToInt8
val castFromWord32: word32 -> int8 = castFromWord32ToInt8
val castFromWord64: word64 -> int8 = castFromWord64ToInt8
val castToInt8: int8 -> int8 = castFromInt8ToInt8
val castToInt16: int8 -> int16 = castFromInt8ToInt16
val castToInt32: int8 -> int32 = castFromInt8ToInt32
val castToInt64: int8 -> int64 = castFromInt8ToInt64
val castToWord8: int8 -> word8 = castFromInt8ToWord8
val castToWord16: int8 -> word16 = castFromInt8ToWord16
val castToWord32: int8 -> word32 = castFromInt8ToWord32
val castToWord64: int8 -> word64 = castFromInt8ToWord64
val zchckFromInt8: int8 -> int8 = zchckFromInt8ToInt8
val zchckFromInt16: int16 -> int8 = zchckFromInt16ToInt8
val zchckFromInt32: int32 -> int8 = zchckFromInt32ToInt8
val zchckFromInt64: int64 -> int8 = zchckFromInt64ToInt8
val zchckFromWord8: word8 -> int8 = zchckFromWord8ToInt8
val zchckFromWord16: word16 -> int8 = zchckFromWord16ToInt8
val zchckFromWord32: word32 -> int8 = zchckFromWord32ToInt8
val zchckFromWord64: word64 -> int8 = zchckFromWord64ToInt8
val zchckToInt8: int8 -> int8 = zchckFromInt8ToInt8
val zchckToInt16: int8 -> int16 = zchckFromInt8ToInt16
val zchckToInt32: int8 -> int32 = zchckFromInt8ToInt32
val zchckToInt64: int8 -> int64 = zchckFromInt8ToInt64
val zchckToWord8: int8 -> word8 = zchckFromInt8ToWord8
val zchckToWord16: int8 -> word16 = zchckFromInt8ToWord16
val zchckToWord32: int8 -> word32 = zchckFromInt8ToWord32
val zchckToWord64: int8 -> word64 = zchckFromInt8ToWord64
val schckFromInt8: int8 -> int8 = schckFromInt8ToInt8
val schckFromInt16: int16 -> int8 = schckFromInt16ToInt8
val schckFromInt32: int32 -> int8 = schckFromInt32ToInt8
val schckFromInt64: int64 -> int8 = schckFromInt64ToInt8
val schckFromWord8: word8 -> int8 = schckFromWord8ToInt8
val schckFromWord16: word16 -> int8 = schckFromWord16ToInt8
val schckFromWord32: word32 -> int8 = schckFromWord32ToInt8
val schckFromWord64: word64 -> int8 = schckFromWord64ToInt8
val schckToInt8: int8 -> int8 = schckFromInt8ToInt8
val schckToInt16: int8 -> int16 = schckFromInt8ToInt16
val schckToInt32: int8 -> int32 = schckFromInt8ToInt32
val schckToInt64: int8 -> int64 = schckFromInt8ToInt64
val schckToWord8: int8 -> word8 = schckFromInt8ToWord8
val schckToWord16: int8 -> word16 = schckFromInt8ToWord16
val schckToWord32: int8 -> word32 = schckFromInt8ToWord32
val schckToWord64: int8 -> word64 = schckFromInt8ToWord64
val zextdFromInt8: int8 -> int16 = zextdFromInt8ToInt16
val zextdFromInt16: int16 -> int16 = zextdFromInt16ToInt16
val zextdFromInt32: int32 -> int16 = zextdFromInt32ToInt16
val zextdFromInt64: int64 -> int16 = zextdFromInt64ToInt16
val zextdFromWord8: word8 -> int16 = zextdFromWord8ToInt16
val zextdFromWord16: word16 -> int16 = zextdFromWord16ToInt16
val zextdFromWord32: word32 -> int16 = zextdFromWord32ToInt16
val zextdFromWord64: word64 -> int16 = zextdFromWord64ToInt16
val zextdToInt8: int16 -> int8 = zextdFromInt16ToInt8
val zextdToInt16: int16 -> int16 = zextdFromInt16ToInt16
val zextdToInt32: int16 -> int32 = zextdFromInt16ToInt32
val zextdToInt64: int16 -> int64 = zextdFromInt16ToInt64
val zextdToWord8: int16 -> word8 = zextdFromInt16ToWord8
val zextdToWord16: int16 -> word16 = zextdFromInt16ToWord16
val zextdToWord32: int16 -> word32 = zextdFromInt16ToWord32
val zextdToWord64: int16 -> word64 = zextdFromInt16ToWord64
val sextdFromInt8: int8 -> int16 = sextdFromInt8ToInt16
val sextdFromInt16: int16 -> int16 = sextdFromInt16ToInt16
val sextdFromInt32: int32 -> int16 = sextdFromInt32ToInt16
val sextdFromInt64: int64 -> int16 = sextdFromInt64ToInt16
val sextdFromWord8: word8 -> int16 = sextdFromWord8ToInt16
val sextdFromWord16: word16 -> int16 = sextdFromWord16ToInt16
val sextdFromWord32: word32 -> int16 = sextdFromWord32ToInt16
val sextdFromWord64: word64 -> int16 = sextdFromWord64ToInt16
val sextdToInt8: int16 -> int8 = sextdFromInt16ToInt8
val sextdToInt16: int16 -> int16 = sextdFromInt16ToInt16
val sextdToInt32: int16 -> int32 = sextdFromInt16ToInt32
val sextdToInt64: int16 -> int64 = sextdFromInt16ToInt64
val sextdToWord8: int16 -> word8 = sextdFromInt16ToWord8
val sextdToWord16: int16 -> word16 = sextdFromInt16ToWord16
val sextdToWord32: int16 -> word32 = sextdFromInt16ToWord32
val sextdToWord64: int16 -> word64 = sextdFromInt16ToWord64
val castFromInt8: int8 -> int16 = castFromInt8ToInt16
val castFromInt16: int16 -> int16 = castFromInt16ToInt16
val castFromInt32: int32 -> int16 = castFromInt32ToInt16
val castFromInt64: int64 -> int16 = castFromInt64ToInt16
val castFromWord8: word8 -> int16 = castFromWord8ToInt16
val castFromWord16: word16 -> int16 = castFromWord16ToInt16
val castFromWord32: word32 -> int16 = castFromWord32ToInt16
val castFromWord64: word64 -> int16 = castFromWord64ToInt16
val castToInt8: int16 -> int8 = castFromInt16ToInt8
val castToInt16: int16 -> int16 = castFromInt16ToInt16
val castToInt32: int16 -> int32 = castFromInt16ToInt32
val castToInt64: int16 -> int64 = castFromInt16ToInt64
val castToWord8: int16 -> word8 = castFromInt16ToWord8
val castToWord16: int16 -> word16 = castFromInt16ToWord16
val castToWord32: int16 -> word32 = castFromInt16ToWord32
val castToWord64: int16 -> word64 = castFromInt16ToWord64
val zchckFromInt8: int8 -> int16 = zchckFromInt8ToInt16
val zchckFromInt16: int16 -> int16 = zchckFromInt16ToInt16
val zchckFromInt32: int32 -> int16 = zchckFromInt32ToInt16
val zchckFromInt64: int64 -> int16 = zchckFromInt64ToInt16
val zchckFromWord8: word8 -> int16 = zchckFromWord8ToInt16
val zchckFromWord16: word16 -> int16 = zchckFromWord16ToInt16
val zchckFromWord32: word32 -> int16 = zchckFromWord32ToInt16
val zchckFromWord64: word64 -> int16 = zchckFromWord64ToInt16
val zchckToInt8: int16 -> int8 = zchckFromInt16ToInt8
val zchckToInt16: int16 -> int16 = zchckFromInt16ToInt16
val zchckToInt32: int16 -> int32 = zchckFromInt16ToInt32
val zchckToInt64: int16 -> int64 = zchckFromInt16ToInt64
val zchckToWord8: int16 -> word8 = zchckFromInt16ToWord8
val zchckToWord16: int16 -> word16 = zchckFromInt16ToWord16
val zchckToWord32: int16 -> word32 = zchckFromInt16ToWord32
val zchckToWord64: int16 -> word64 = zchckFromInt16ToWord64
val schckFromInt8: int8 -> int16 = schckFromInt8ToInt16
val schckFromInt16: int16 -> int16 = schckFromInt16ToInt16
val schckFromInt32: int32 -> int16 = schckFromInt32ToInt16
val schckFromInt64: int64 -> int16 = schckFromInt64ToInt16
val schckFromWord8: word8 -> int16 = schckFromWord8ToInt16
val schckFromWord16: word16 -> int16 = schckFromWord16ToInt16
val schckFromWord32: word32 -> int16 = schckFromWord32ToInt16
val schckFromWord64: word64 -> int16 = schckFromWord64ToInt16
val schckToInt8: int16 -> int8 = schckFromInt16ToInt8
val schckToInt16: int16 -> int16 = schckFromInt16ToInt16
val schckToInt32: int16 -> int32 = schckFromInt16ToInt32
val schckToInt64: int16 -> int64 = schckFromInt16ToInt64
val schckToWord8: int16 -> word8 = schckFromInt16ToWord8
val schckToWord16: int16 -> word16 = schckFromInt16ToWord16
val schckToWord32: int16 -> word32 = schckFromInt16ToWord32
val schckToWord64: int16 -> word64 = schckFromInt16ToWord64
val zextdFromInt8: int8 -> int32 = zextdFromInt8ToInt32
val zextdFromInt16: int16 -> int32 = zextdFromInt16ToInt32
val zextdFromInt32: int32 -> int32 = zextdFromInt32ToInt32
val zextdFromInt64: int64 -> int32 = zextdFromInt64ToInt32
val zextdFromWord8: word8 -> int32 = zextdFromWord8ToInt32
val zextdFromWord16: word16 -> int32 = zextdFromWord16ToInt32
val zextdFromWord32: word32 -> int32 = zextdFromWord32ToInt32
val zextdFromWord64: word64 -> int32 = zextdFromWord64ToInt32
val zextdToInt8: int32 -> int8 = zextdFromInt32ToInt8
val zextdToInt16: int32 -> int16 = zextdFromInt32ToInt16
val zextdToInt32: int32 -> int32 = zextdFromInt32ToInt32
val zextdToInt64: int32 -> int64 = zextdFromInt32ToInt64
val zextdToWord8: int32 -> word8 = zextdFromInt32ToWord8
val zextdToWord16: int32 -> word16 = zextdFromInt32ToWord16
val zextdToWord32: int32 -> word32 = zextdFromInt32ToWord32
val zextdToWord64: int32 -> word64 = zextdFromInt32ToWord64
val sextdFromInt8: int8 -> int32 = sextdFromInt8ToInt32
val sextdFromInt16: int16 -> int32 = sextdFromInt16ToInt32
val sextdFromInt32: int32 -> int32 = sextdFromInt32ToInt32
val sextdFromInt64: int64 -> int32 = sextdFromInt64ToInt32
val sextdFromWord8: word8 -> int32 = sextdFromWord8ToInt32
val sextdFromWord16: word16 -> int32 = sextdFromWord16ToInt32
val sextdFromWord32: word32 -> int32 = sextdFromWord32ToInt32
val sextdFromWord64: word64 -> int32 = sextdFromWord64ToInt32
val sextdToInt8: int32 -> int8 = sextdFromInt32ToInt8
val sextdToInt16: int32 -> int16 = sextdFromInt32ToInt16
val sextdToInt32: int32 -> int32 = sextdFromInt32ToInt32
val sextdToInt64: int32 -> int64 = sextdFromInt32ToInt64
val sextdToWord8: int32 -> word8 = sextdFromInt32ToWord8
val sextdToWord16: int32 -> word16 = sextdFromInt32ToWord16
val sextdToWord32: int32 -> word32 = sextdFromInt32ToWord32
val sextdToWord64: int32 -> word64 = sextdFromInt32ToWord64
val castFromInt8: int8 -> int32 = castFromInt8ToInt32
val castFromInt16: int16 -> int32 = castFromInt16ToInt32
val castFromInt32: int32 -> int32 = castFromInt32ToInt32
val castFromInt64: int64 -> int32 = castFromInt64ToInt32
val castFromWord8: word8 -> int32 = castFromWord8ToInt32
val castFromWord16: word16 -> int32 = castFromWord16ToInt32
val castFromWord32: word32 -> int32 = castFromWord32ToInt32
val castFromWord64: word64 -> int32 = castFromWord64ToInt32
val castToInt8: int32 -> int8 = castFromInt32ToInt8
val castToInt16: int32 -> int16 = castFromInt32ToInt16
val castToInt32: int32 -> int32 = castFromInt32ToInt32
val castToInt64: int32 -> int64 = castFromInt32ToInt64
val castToWord8: int32 -> word8 = castFromInt32ToWord8
val castToWord16: int32 -> word16 = castFromInt32ToWord16
val castToWord32: int32 -> word32 = castFromInt32ToWord32
val castToWord64: int32 -> word64 = castFromInt32ToWord64
val zchckFromInt8: int8 -> int32 = zchckFromInt8ToInt32
val zchckFromInt16: int16 -> int32 = zchckFromInt16ToInt32
val zchckFromInt32: int32 -> int32 = zchckFromInt32ToInt32
val zchckFromInt64: int64 -> int32 = zchckFromInt64ToInt32
val zchckFromWord8: word8 -> int32 = zchckFromWord8ToInt32
val zchckFromWord16: word16 -> int32 = zchckFromWord16ToInt32
val zchckFromWord32: word32 -> int32 = zchckFromWord32ToInt32
val zchckFromWord64: word64 -> int32 = zchckFromWord64ToInt32
val zchckToInt8: int32 -> int8 = zchckFromInt32ToInt8
val zchckToInt16: int32 -> int16 = zchckFromInt32ToInt16
val zchckToInt32: int32 -> int32 = zchckFromInt32ToInt32
val zchckToInt64: int32 -> int64 = zchckFromInt32ToInt64
val zchckToWord8: int32 -> word8 = zchckFromInt32ToWord8
val zchckToWord16: int32 -> word16 = zchckFromInt32ToWord16
val zchckToWord32: int32 -> word32 = zchckFromInt32ToWord32
val zchckToWord64: int32 -> word64 = zchckFromInt32ToWord64
val schckFromInt8: int8 -> int32 = schckFromInt8ToInt32
val schckFromInt16: int16 -> int32 = schckFromInt16ToInt32
val schckFromInt32: int32 -> int32 = schckFromInt32ToInt32
val schckFromInt64: int64 -> int32 = schckFromInt64ToInt32
val schckFromWord8: word8 -> int32 = schckFromWord8ToInt32
val schckFromWord16: word16 -> int32 = schckFromWord16ToInt32
val schckFromWord32: word32 -> int32 = schckFromWord32ToInt32
val schckFromWord64: word64 -> int32 = schckFromWord64ToInt32
val schckToInt8: int32 -> int8 = schckFromInt32ToInt8
val schckToInt16: int32 -> int16 = schckFromInt32ToInt16
val schckToInt32: int32 -> int32 = schckFromInt32ToInt32
val schckToInt64: int32 -> int64 = schckFromInt32ToInt64
val schckToWord8: int32 -> word8 = schckFromInt32ToWord8
val schckToWord16: int32 -> word16 = schckFromInt32ToWord16
val schckToWord32: int32 -> word32 = schckFromInt32ToWord32
val schckToWord64: int32 -> word64 = schckFromInt32ToWord64
val zextdFromInt8: int8 -> int64 = zextdFromInt8ToInt64
val zextdFromInt16: int16 -> int64 = zextdFromInt16ToInt64
val zextdFromInt32: int32 -> int64 = zextdFromInt32ToInt64
val zextdFromInt64: int64 -> int64 = zextdFromInt64ToInt64
val zextdFromWord8: word8 -> int64 = zextdFromWord8ToInt64
val zextdFromWord16: word16 -> int64 = zextdFromWord16ToInt64
val zextdFromWord32: word32 -> int64 = zextdFromWord32ToInt64
val zextdFromWord64: word64 -> int64 = zextdFromWord64ToInt64
val zextdToInt8: int64 -> int8 = zextdFromInt64ToInt8
val zextdToInt16: int64 -> int16 = zextdFromInt64ToInt16
val zextdToInt32: int64 -> int32 = zextdFromInt64ToInt32
val zextdToInt64: int64 -> int64 = zextdFromInt64ToInt64
val zextdToWord8: int64 -> word8 = zextdFromInt64ToWord8
val zextdToWord16: int64 -> word16 = zextdFromInt64ToWord16
val zextdToWord32: int64 -> word32 = zextdFromInt64ToWord32
val zextdToWord64: int64 -> word64 = zextdFromInt64ToWord64
val sextdFromInt8: int8 -> int64 = sextdFromInt8ToInt64
val sextdFromInt16: int16 -> int64 = sextdFromInt16ToInt64
val sextdFromInt32: int32 -> int64 = sextdFromInt32ToInt64
val sextdFromInt64: int64 -> int64 = sextdFromInt64ToInt64
val sextdFromWord8: word8 -> int64 = sextdFromWord8ToInt64
val sextdFromWord16: word16 -> int64 = sextdFromWord16ToInt64
val sextdFromWord32: word32 -> int64 = sextdFromWord32ToInt64
val sextdFromWord64: word64 -> int64 = sextdFromWord64ToInt64
val sextdToInt8: int64 -> int8 = sextdFromInt64ToInt8
val sextdToInt16: int64 -> int16 = sextdFromInt64ToInt16
val sextdToInt32: int64 -> int32 = sextdFromInt64ToInt32
val sextdToInt64: int64 -> int64 = sextdFromInt64ToInt64
val sextdToWord8: int64 -> word8 = sextdFromInt64ToWord8
val sextdToWord16: int64 -> word16 = sextdFromInt64ToWord16
val sextdToWord32: int64 -> word32 = sextdFromInt64ToWord32
val sextdToWord64: int64 -> word64 = sextdFromInt64ToWord64
val castFromInt8: int8 -> int64 = castFromInt8ToInt64
val castFromInt16: int16 -> int64 = castFromInt16ToInt64
val castFromInt32: int32 -> int64 = castFromInt32ToInt64
val castFromInt64: int64 -> int64 = castFromInt64ToInt64
val castFromWord8: word8 -> int64 = castFromWord8ToInt64
val castFromWord16: word16 -> int64 = castFromWord16ToInt64
val castFromWord32: word32 -> int64 = castFromWord32ToInt64
val castFromWord64: word64 -> int64 = castFromWord64ToInt64
val castToInt8: int64 -> int8 = castFromInt64ToInt8
val castToInt16: int64 -> int16 = castFromInt64ToInt16
val castToInt32: int64 -> int32 = castFromInt64ToInt32
val castToInt64: int64 -> int64 = castFromInt64ToInt64
val castToWord8: int64 -> word8 = castFromInt64ToWord8
val castToWord16: int64 -> word16 = castFromInt64ToWord16
val castToWord32: int64 -> word32 = castFromInt64ToWord32
val castToWord64: int64 -> word64 = castFromInt64ToWord64
val zchckFromInt8: int8 -> int64 = zchckFromInt8ToInt64
val zchckFromInt16: int16 -> int64 = zchckFromInt16ToInt64
val zchckFromInt32: int32 -> int64 = zchckFromInt32ToInt64
val zchckFromInt64: int64 -> int64 = zchckFromInt64ToInt64
val zchckFromWord8: word8 -> int64 = zchckFromWord8ToInt64
val zchckFromWord16: word16 -> int64 = zchckFromWord16ToInt64
val zchckFromWord32: word32 -> int64 = zchckFromWord32ToInt64
val zchckFromWord64: word64 -> int64 = zchckFromWord64ToInt64
val zchckToInt8: int64 -> int8 = zchckFromInt64ToInt8
val zchckToInt16: int64 -> int16 = zchckFromInt64ToInt16
val zchckToInt32: int64 -> int32 = zchckFromInt64ToInt32
val zchckToInt64: int64 -> int64 = zchckFromInt64ToInt64
val zchckToWord8: int64 -> word8 = zchckFromInt64ToWord8
val zchckToWord16: int64 -> word16 = zchckFromInt64ToWord16
val zchckToWord32: int64 -> word32 = zchckFromInt64ToWord32
val zchckToWord64: int64 -> word64 = zchckFromInt64ToWord64
val schckFromInt8: int8 -> int64 = schckFromInt8ToInt64
val schckFromInt16: int16 -> int64 = schckFromInt16ToInt64
val schckFromInt32: int32 -> int64 = schckFromInt32ToInt64
val schckFromInt64: int64 -> int64 = schckFromInt64ToInt64
val schckFromWord8: word8 -> int64 = schckFromWord8ToInt64
val schckFromWord16: word16 -> int64 = schckFromWord16ToInt64
val schckFromWord32: word32 -> int64 = schckFromWord32ToInt64
val schckFromWord64: word64 -> int64 = schckFromWord64ToInt64
val schckToInt8: int64 -> int8 = schckFromInt64ToInt8
val schckToInt16: int64 -> int16 = schckFromInt64ToInt16
val schckToInt32: int64 -> int32 = schckFromInt64ToInt32
val schckToInt64: int64 -> int64 = schckFromInt64ToInt64
val schckToWord8: int64 -> word8 = schckFromInt64ToWord8
val schckToWord16: int64 -> word16 = schckFromInt64ToWord16
val schckToWord32: int64 -> word32 = schckFromInt64ToWord32
val schckToWord64: int64 -> word64 = schckFromInt64ToWord64
val zextdFromInt8: int8 -> word8 = zextdFromInt8ToWord8
val zextdFromInt16: int16 -> word8 = zextdFromInt16ToWord8
val zextdFromInt32: int32 -> word8 = zextdFromInt32ToWord8
val zextdFromInt64: int64 -> word8 = zextdFromInt64ToWord8
val zextdFromWord8: word8 -> word8 = zextdFromWord8ToWord8
val zextdFromWord16: word16 -> word8 = zextdFromWord16ToWord8
val zextdFromWord32: word32 -> word8 = zextdFromWord32ToWord8
val zextdFromWord64: word64 -> word8 = zextdFromWord64ToWord8
val zextdToInt8: word8 -> int8 = zextdFromWord8ToInt8
val zextdToInt16: word8 -> int16 = zextdFromWord8ToInt16
val zextdToInt32: word8 -> int32 = zextdFromWord8ToInt32
val zextdToInt64: word8 -> int64 = zextdFromWord8ToInt64
val zextdToWord8: word8 -> word8 = zextdFromWord8ToWord8
val zextdToWord16: word8 -> word16 = zextdFromWord8ToWord16
val zextdToWord32: word8 -> word32 = zextdFromWord8ToWord32
val zextdToWord64: word8 -> word64 = zextdFromWord8ToWord64
val sextdFromInt8: int8 -> word8 = sextdFromInt8ToWord8
val sextdFromInt16: int16 -> word8 = sextdFromInt16ToWord8
val sextdFromInt32: int32 -> word8 = sextdFromInt32ToWord8
val sextdFromInt64: int64 -> word8 = sextdFromInt64ToWord8
val sextdFromWord8: word8 -> word8 = sextdFromWord8ToWord8
val sextdFromWord16: word16 -> word8 = sextdFromWord16ToWord8
val sextdFromWord32: word32 -> word8 = sextdFromWord32ToWord8
val sextdFromWord64: word64 -> word8 = sextdFromWord64ToWord8
val sextdToInt8: word8 -> int8 = sextdFromWord8ToInt8
val sextdToInt16: word8 -> int16 = sextdFromWord8ToInt16
val sextdToInt32: word8 -> int32 = sextdFromWord8ToInt32
val sextdToInt64: word8 -> int64 = sextdFromWord8ToInt64
val sextdToWord8: word8 -> word8 = sextdFromWord8ToWord8
val sextdToWord16: word8 -> word16 = sextdFromWord8ToWord16
val sextdToWord32: word8 -> word32 = sextdFromWord8ToWord32
val sextdToWord64: word8 -> word64 = sextdFromWord8ToWord64
val castFromInt8: int8 -> word8 = castFromInt8ToWord8
val castFromInt16: int16 -> word8 = castFromInt16ToWord8
val castFromInt32: int32 -> word8 = castFromInt32ToWord8
val castFromInt64: int64 -> word8 = castFromInt64ToWord8
val castFromWord8: word8 -> word8 = castFromWord8ToWord8
val castFromWord16: word16 -> word8 = castFromWord16ToWord8
val castFromWord32: word32 -> word8 = castFromWord32ToWord8
val castFromWord64: word64 -> word8 = castFromWord64ToWord8
val castToInt8: word8 -> int8 = castFromWord8ToInt8
val castToInt16: word8 -> int16 = castFromWord8ToInt16
val castToInt32: word8 -> int32 = castFromWord8ToInt32
val castToInt64: word8 -> int64 = castFromWord8ToInt64
val castToWord8: word8 -> word8 = castFromWord8ToWord8
val castToWord16: word8 -> word16 = castFromWord8ToWord16
val castToWord32: word8 -> word32 = castFromWord8ToWord32
val castToWord64: word8 -> word64 = castFromWord8ToWord64
val zchckFromInt8: int8 -> word8 = zchckFromInt8ToWord8
val zchckFromInt16: int16 -> word8 = zchckFromInt16ToWord8
val zchckFromInt32: int32 -> word8 = zchckFromInt32ToWord8
val zchckFromInt64: int64 -> word8 = zchckFromInt64ToWord8
val zchckFromWord8: word8 -> word8 = zchckFromWord8ToWord8
val zchckFromWord16: word16 -> word8 = zchckFromWord16ToWord8
val zchckFromWord32: word32 -> word8 = zchckFromWord32ToWord8
val zchckFromWord64: word64 -> word8 = zchckFromWord64ToWord8
val zchckToInt8: word8 -> int8 = zchckFromWord8ToInt8
val zchckToInt16: word8 -> int16 = zchckFromWord8ToInt16
val zchckToInt32: word8 -> int32 = zchckFromWord8ToInt32
val zchckToInt64: word8 -> int64 = zchckFromWord8ToInt64
val zchckToWord8: word8 -> word8 = zchckFromWord8ToWord8
val zchckToWord16: word8 -> word16 = zchckFromWord8ToWord16
val zchckToWord32: word8 -> word32 = zchckFromWord8ToWord32
val zchckToWord64: word8 -> word64 = zchckFromWord8ToWord64
val schckFromInt8: int8 -> word8 = schckFromInt8ToWord8
val schckFromInt16: int16 -> word8 = schckFromInt16ToWord8
val schckFromInt32: int32 -> word8 = schckFromInt32ToWord8
val schckFromInt64: int64 -> word8 = schckFromInt64ToWord8
val schckFromWord8: word8 -> word8 = schckFromWord8ToWord8
val schckFromWord16: word16 -> word8 = schckFromWord16ToWord8
val schckFromWord32: word32 -> word8 = schckFromWord32ToWord8
val schckFromWord64: word64 -> word8 = schckFromWord64ToWord8
val schckToInt8: word8 -> int8 = schckFromWord8ToInt8
val schckToInt16: word8 -> int16 = schckFromWord8ToInt16
val schckToInt32: word8 -> int32 = schckFromWord8ToInt32
val schckToInt64: word8 -> int64 = schckFromWord8ToInt64
val schckToWord8: word8 -> word8 = schckFromWord8ToWord8
val schckToWord16: word8 -> word16 = schckFromWord8ToWord16
val schckToWord32: word8 -> word32 = schckFromWord8ToWord32
val schckToWord64: word8 -> word64 = schckFromWord8ToWord64
val zextdFromInt8: int8 -> word16 = zextdFromInt8ToWord16
val zextdFromInt16: int16 -> word16 = zextdFromInt16ToWord16
val zextdFromInt32: int32 -> word16 = zextdFromInt32ToWord16
val zextdFromInt64: int64 -> word16 = zextdFromInt64ToWord16
val zextdFromWord8: word8 -> word16 = zextdFromWord8ToWord16
val zextdFromWord16: word16 -> word16 = zextdFromWord16ToWord16
val zextdFromWord32: word32 -> word16 = zextdFromWord32ToWord16
val zextdFromWord64: word64 -> word16 = zextdFromWord64ToWord16
val zextdToInt8: word16 -> int8 = zextdFromWord16ToInt8
val zextdToInt16: word16 -> int16 = zextdFromWord16ToInt16
val zextdToInt32: word16 -> int32 = zextdFromWord16ToInt32
val zextdToInt64: word16 -> int64 = zextdFromWord16ToInt64
val zextdToWord8: word16 -> word8 = zextdFromWord16ToWord8
val zextdToWord16: word16 -> word16 = zextdFromWord16ToWord16
val zextdToWord32: word16 -> word32 = zextdFromWord16ToWord32
val zextdToWord64: word16 -> word64 = zextdFromWord16ToWord64
val sextdFromInt8: int8 -> word16 = sextdFromInt8ToWord16
val sextdFromInt16: int16 -> word16 = sextdFromInt16ToWord16
val sextdFromInt32: int32 -> word16 = sextdFromInt32ToWord16
val sextdFromInt64: int64 -> word16 = sextdFromInt64ToWord16
val sextdFromWord8: word8 -> word16 = sextdFromWord8ToWord16
val sextdFromWord16: word16 -> word16 = sextdFromWord16ToWord16
val sextdFromWord32: word32 -> word16 = sextdFromWord32ToWord16
val sextdFromWord64: word64 -> word16 = sextdFromWord64ToWord16
val sextdToInt8: word16 -> int8 = sextdFromWord16ToInt8
val sextdToInt16: word16 -> int16 = sextdFromWord16ToInt16
val sextdToInt32: word16 -> int32 = sextdFromWord16ToInt32
val sextdToInt64: word16 -> int64 = sextdFromWord16ToInt64
val sextdToWord8: word16 -> word8 = sextdFromWord16ToWord8
val sextdToWord16: word16 -> word16 = sextdFromWord16ToWord16
val sextdToWord32: word16 -> word32 = sextdFromWord16ToWord32
val sextdToWord64: word16 -> word64 = sextdFromWord16ToWord64
val castFromInt8: int8 -> word16 = castFromInt8ToWord16
val castFromInt16: int16 -> word16 = castFromInt16ToWord16
val castFromInt32: int32 -> word16 = castFromInt32ToWord16
val castFromInt64: int64 -> word16 = castFromInt64ToWord16
val castFromWord8: word8 -> word16 = castFromWord8ToWord16
val castFromWord16: word16 -> word16 = castFromWord16ToWord16
val castFromWord32: word32 -> word16 = castFromWord32ToWord16
val castFromWord64: word64 -> word16 = castFromWord64ToWord16
val castToInt8: word16 -> int8 = castFromWord16ToInt8
val castToInt16: word16 -> int16 = castFromWord16ToInt16
val castToInt32: word16 -> int32 = castFromWord16ToInt32
val castToInt64: word16 -> int64 = castFromWord16ToInt64
val castToWord8: word16 -> word8 = castFromWord16ToWord8
val castToWord16: word16 -> word16 = castFromWord16ToWord16
val castToWord32: word16 -> word32 = castFromWord16ToWord32
val castToWord64: word16 -> word64 = castFromWord16ToWord64
val zchckFromInt8: int8 -> word16 = zchckFromInt8ToWord16
val zchckFromInt16: int16 -> word16 = zchckFromInt16ToWord16
val zchckFromInt32: int32 -> word16 = zchckFromInt32ToWord16
val zchckFromInt64: int64 -> word16 = zchckFromInt64ToWord16
val zchckFromWord8: word8 -> word16 = zchckFromWord8ToWord16
val zchckFromWord16: word16 -> word16 = zchckFromWord16ToWord16
val zchckFromWord32: word32 -> word16 = zchckFromWord32ToWord16
val zchckFromWord64: word64 -> word16 = zchckFromWord64ToWord16
val zchckToInt8: word16 -> int8 = zchckFromWord16ToInt8
val zchckToInt16: word16 -> int16 = zchckFromWord16ToInt16
val zchckToInt32: word16 -> int32 = zchckFromWord16ToInt32
val zchckToInt64: word16 -> int64 = zchckFromWord16ToInt64
val zchckToWord8: word16 -> word8 = zchckFromWord16ToWord8
val zchckToWord16: word16 -> word16 = zchckFromWord16ToWord16
val zchckToWord32: word16 -> word32 = zchckFromWord16ToWord32
val zchckToWord64: word16 -> word64 = zchckFromWord16ToWord64
val schckFromInt8: int8 -> word16 = schckFromInt8ToWord16
val schckFromInt16: int16 -> word16 = schckFromInt16ToWord16
val schckFromInt32: int32 -> word16 = schckFromInt32ToWord16
val schckFromInt64: int64 -> word16 = schckFromInt64ToWord16
val schckFromWord8: word8 -> word16 = schckFromWord8ToWord16
val schckFromWord16: word16 -> word16 = schckFromWord16ToWord16
val schckFromWord32: word32 -> word16 = schckFromWord32ToWord16
val schckFromWord64: word64 -> word16 = schckFromWord64ToWord16
val schckToInt8: word16 -> int8 = schckFromWord16ToInt8
val schckToInt16: word16 -> int16 = schckFromWord16ToInt16
val schckToInt32: word16 -> int32 = schckFromWord16ToInt32
val schckToInt64: word16 -> int64 = schckFromWord16ToInt64
val schckToWord8: word16 -> word8 = schckFromWord16ToWord8
val schckToWord16: word16 -> word16 = schckFromWord16ToWord16
val schckToWord32: word16 -> word32 = schckFromWord16ToWord32
val schckToWord64: word16 -> word64 = schckFromWord16ToWord64
val zextdFromInt8: int8 -> word32 = zextdFromInt8ToWord32
val zextdFromInt16: int16 -> word32 = zextdFromInt16ToWord32
val zextdFromInt32: int32 -> word32 = zextdFromInt32ToWord32
val zextdFromInt64: int64 -> word32 = zextdFromInt64ToWord32
val zextdFromWord8: word8 -> word32 = zextdFromWord8ToWord32
val zextdFromWord16: word16 -> word32 = zextdFromWord16ToWord32
val zextdFromWord32: word32 -> word32 = zextdFromWord32ToWord32
val zextdFromWord64: word64 -> word32 = zextdFromWord64ToWord32
val zextdToInt8: word32 -> int8 = zextdFromWord32ToInt8
val zextdToInt16: word32 -> int16 = zextdFromWord32ToInt16
val zextdToInt32: word32 -> int32 = zextdFromWord32ToInt32
val zextdToInt64: word32 -> int64 = zextdFromWord32ToInt64
val zextdToWord8: word32 -> word8 = zextdFromWord32ToWord8
val zextdToWord16: word32 -> word16 = zextdFromWord32ToWord16
val zextdToWord32: word32 -> word32 = zextdFromWord32ToWord32
val zextdToWord64: word32 -> word64 = zextdFromWord32ToWord64
val sextdFromInt8: int8 -> word32 = sextdFromInt8ToWord32
val sextdFromInt16: int16 -> word32 = sextdFromInt16ToWord32
val sextdFromInt32: int32 -> word32 = sextdFromInt32ToWord32
val sextdFromInt64: int64 -> word32 = sextdFromInt64ToWord32
val sextdFromWord8: word8 -> word32 = sextdFromWord8ToWord32
val sextdFromWord16: word16 -> word32 = sextdFromWord16ToWord32
val sextdFromWord32: word32 -> word32 = sextdFromWord32ToWord32
val sextdFromWord64: word64 -> word32 = sextdFromWord64ToWord32
val sextdToInt8: word32 -> int8 = sextdFromWord32ToInt8
val sextdToInt16: word32 -> int16 = sextdFromWord32ToInt16
val sextdToInt32: word32 -> int32 = sextdFromWord32ToInt32
val sextdToInt64: word32 -> int64 = sextdFromWord32ToInt64
val sextdToWord8: word32 -> word8 = sextdFromWord32ToWord8
val sextdToWord16: word32 -> word16 = sextdFromWord32ToWord16
val sextdToWord32: word32 -> word32 = sextdFromWord32ToWord32
val sextdToWord64: word32 -> word64 = sextdFromWord32ToWord64
val castFromInt8: int8 -> word32 = castFromInt8ToWord32
val castFromInt16: int16 -> word32 = castFromInt16ToWord32
val castFromInt32: int32 -> word32 = castFromInt32ToWord32
val castFromInt64: int64 -> word32 = castFromInt64ToWord32
val castFromWord8: word8 -> word32 = castFromWord8ToWord32
val castFromWord16: word16 -> word32 = castFromWord16ToWord32
val castFromWord32: word32 -> word32 = castFromWord32ToWord32
val castFromWord64: word64 -> word32 = castFromWord64ToWord32
val castToInt8: word32 -> int8 = castFromWord32ToInt8
val castToInt16: word32 -> int16 = castFromWord32ToInt16
val castToInt32: word32 -> int32 = castFromWord32ToInt32
val castToInt64: word32 -> int64 = castFromWord32ToInt64
val castToWord8: word32 -> word8 = castFromWord32ToWord8
val castToWord16: word32 -> word16 = castFromWord32ToWord16
val castToWord32: word32 -> word32 = castFromWord32ToWord32
val castToWord64: word32 -> word64 = castFromWord32ToWord64
val zchckFromInt8: int8 -> word32 = zchckFromInt8ToWord32
val zchckFromInt16: int16 -> word32 = zchckFromInt16ToWord32
val zchckFromInt32: int32 -> word32 = zchckFromInt32ToWord32
val zchckFromInt64: int64 -> word32 = zchckFromInt64ToWord32
val zchckFromWord8: word8 -> word32 = zchckFromWord8ToWord32
val zchckFromWord16: word16 -> word32 = zchckFromWord16ToWord32
val zchckFromWord32: word32 -> word32 = zchckFromWord32ToWord32
val zchckFromWord64: word64 -> word32 = zchckFromWord64ToWord32
val zchckToInt8: word32 -> int8 = zchckFromWord32ToInt8
val zchckToInt16: word32 -> int16 = zchckFromWord32ToInt16
val zchckToInt32: word32 -> int32 = zchckFromWord32ToInt32
val zchckToInt64: word32 -> int64 = zchckFromWord32ToInt64
val zchckToWord8: word32 -> word8 = zchckFromWord32ToWord8
val zchckToWord16: word32 -> word16 = zchckFromWord32ToWord16
val zchckToWord32: word32 -> word32 = zchckFromWord32ToWord32
val zchckToWord64: word32 -> word64 = zchckFromWord32ToWord64
val schckFromInt8: int8 -> word32 = schckFromInt8ToWord32
val schckFromInt16: int16 -> word32 = schckFromInt16ToWord32
val schckFromInt32: int32 -> word32 = schckFromInt32ToWord32
val schckFromInt64: int64 -> word32 = schckFromInt64ToWord32
val schckFromWord8: word8 -> word32 = schckFromWord8ToWord32
val schckFromWord16: word16 -> word32 = schckFromWord16ToWord32
val schckFromWord32: word32 -> word32 = schckFromWord32ToWord32
val schckFromWord64: word64 -> word32 = schckFromWord64ToWord32
val schckToInt8: word32 -> int8 = schckFromWord32ToInt8
val schckToInt16: word32 -> int16 = schckFromWord32ToInt16
val schckToInt32: word32 -> int32 = schckFromWord32ToInt32
val schckToInt64: word32 -> int64 = schckFromWord32ToInt64
val schckToWord8: word32 -> word8 = schckFromWord32ToWord8
val schckToWord16: word32 -> word16 = schckFromWord32ToWord16
val schckToWord32: word32 -> word32 = schckFromWord32ToWord32
val schckToWord64: word32 -> word64 = schckFromWord32ToWord64
val zextdFromInt8: int8 -> word64 = zextdFromInt8ToWord64
val zextdFromInt16: int16 -> word64 = zextdFromInt16ToWord64
val zextdFromInt32: int32 -> word64 = zextdFromInt32ToWord64
val zextdFromInt64: int64 -> word64 = zextdFromInt64ToWord64
val zextdFromWord8: word8 -> word64 = zextdFromWord8ToWord64
val zextdFromWord16: word16 -> word64 = zextdFromWord16ToWord64
val zextdFromWord32: word32 -> word64 = zextdFromWord32ToWord64
val zextdFromWord64: word64 -> word64 = zextdFromWord64ToWord64
val zextdToInt8: word64 -> int8 = zextdFromWord64ToInt8
val zextdToInt16: word64 -> int16 = zextdFromWord64ToInt16
val zextdToInt32: word64 -> int32 = zextdFromWord64ToInt32
val zextdToInt64: word64 -> int64 = zextdFromWord64ToInt64
val zextdToWord8: word64 -> word8 = zextdFromWord64ToWord8
val zextdToWord16: word64 -> word16 = zextdFromWord64ToWord16
val zextdToWord32: word64 -> word32 = zextdFromWord64ToWord32
val zextdToWord64: word64 -> word64 = zextdFromWord64ToWord64
val sextdFromInt8: int8 -> word64 = sextdFromInt8ToWord64
val sextdFromInt16: int16 -> word64 = sextdFromInt16ToWord64
val sextdFromInt32: int32 -> word64 = sextdFromInt32ToWord64
val sextdFromInt64: int64 -> word64 = sextdFromInt64ToWord64
val sextdFromWord8: word8 -> word64 = sextdFromWord8ToWord64
val sextdFromWord16: word16 -> word64 = sextdFromWord16ToWord64
val sextdFromWord32: word32 -> word64 = sextdFromWord32ToWord64
val sextdFromWord64: word64 -> word64 = sextdFromWord64ToWord64
val sextdToInt8: word64 -> int8 = sextdFromWord64ToInt8
val sextdToInt16: word64 -> int16 = sextdFromWord64ToInt16
val sextdToInt32: word64 -> int32 = sextdFromWord64ToInt32
val sextdToInt64: word64 -> int64 = sextdFromWord64ToInt64
val sextdToWord8: word64 -> word8 = sextdFromWord64ToWord8
val sextdToWord16: word64 -> word16 = sextdFromWord64ToWord16
val sextdToWord32: word64 -> word32 = sextdFromWord64ToWord32
val sextdToWord64: word64 -> word64 = sextdFromWord64ToWord64
val castFromInt8: int8 -> word64 = castFromInt8ToWord64
val castFromInt16: int16 -> word64 = castFromInt16ToWord64
val castFromInt32: int32 -> word64 = castFromInt32ToWord64
val castFromInt64: int64 -> word64 = castFromInt64ToWord64
val castFromWord8: word8 -> word64 = castFromWord8ToWord64
val castFromWord16: word16 -> word64 = castFromWord16ToWord64
val castFromWord32: word32 -> word64 = castFromWord32ToWord64
val castFromWord64: word64 -> word64 = castFromWord64ToWord64
val castToInt8: word64 -> int8 = castFromWord64ToInt8
val castToInt16: word64 -> int16 = castFromWord64ToInt16
val castToInt32: word64 -> int32 = castFromWord64ToInt32
val castToInt64: word64 -> int64 = castFromWord64ToInt64
val castToWord8: word64 -> word8 = castFromWord64ToWord8
val castToWord16: word64 -> word16 = castFromWord64ToWord16
val castToWord32: word64 -> word32 = castFromWord64ToWord32
val castToWord64: word64 -> word64 = castFromWord64ToWord64
val zchckFromInt8: int8 -> word64 = zchckFromInt8ToWord64
val zchckFromInt16: int16 -> word64 = zchckFromInt16ToWord64
val zchckFromInt32: int32 -> word64 = zchckFromInt32ToWord64
val zchckFromInt64: int64 -> word64 = zchckFromInt64ToWord64
val zchckFromWord8: word8 -> word64 = zchckFromWord8ToWord64
val zchckFromWord16: word16 -> word64 = zchckFromWord16ToWord64
val zchckFromWord32: word32 -> word64 = zchckFromWord32ToWord64
val zchckFromWord64: word64 -> word64 = zchckFromWord64ToWord64
val zchckToInt8: word64 -> int8 = zchckFromWord64ToInt8
val zchckToInt16: word64 -> int16 = zchckFromWord64ToInt16
val zchckToInt32: word64 -> int32 = zchckFromWord64ToInt32
val zchckToInt64: word64 -> int64 = zchckFromWord64ToInt64
val zchckToWord8: word64 -> word8 = zchckFromWord64ToWord8
val zchckToWord16: word64 -> word16 = zchckFromWord64ToWord16
val zchckToWord32: word64 -> word32 = zchckFromWord64ToWord32
val zchckToWord64: word64 -> word64 = zchckFromWord64ToWord64
val schckFromInt8: int8 -> word64 = schckFromInt8ToWord64
val schckFromInt16: int16 -> word64 = schckFromInt16ToWord64
val schckFromInt32: int32 -> word64 = schckFromInt32ToWord64
val schckFromInt64: int64 -> word64 = schckFromInt64ToWord64
val schckFromWord8: word8 -> word64 = schckFromWord8ToWord64
val schckFromWord16: word16 -> word64 = schckFromWord16ToWord64
val schckFromWord32: word32 -> word64 = schckFromWord32ToWord64
val schckFromWord64: word64 -> word64 = schckFromWord64ToWord64
val schckToInt8: word64 -> int8 = schckFromWord64ToInt8
val schckToInt16: word64 -> int16 = schckFromWord64ToInt16
val schckToInt32: word64 -> int32 = schckFromWord64ToInt32
val schckToInt64: word64 -> int64 = schckFromWord64ToInt64
val schckToWord8: word64 -> word8 = schckFromWord64ToWord8
val schckToWord16: word64 -> word16 = schckFromWord64ToWord16
val schckToWord32: word64 -> word32 = schckFromWord64ToWord32
val schckToWord64: word64 -> word64 = schckFromWord64ToWord64
val idFromIntToWord: int8 -> word8 = idFromInt8ToWord8
val idFromWordToInt: word8 -> int8 = idFromWord8ToInt8
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word8 = (zextdFromWord32 0x0)
val maxWord': word8 = (notb zero)
val zero: int8 = (zextdFromInt32 0x0)
val one: int8 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word8 -> word8) -> int8 -> int8 = 
      (fn x_852: word8 -> word8 =>
       case x_852 of
	 (f: word8 -> word8) =>
	 (fn x_853: int8 =>
	  case x_853 of
	    x: int8 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word8 * word32 -> word8) -> int8 * word32 -> int8 = 
      (fn x_854: word8 * word32 -> word8 =>
       case x_854 of
	 (f: word8 * word32 -> word8) =>
	 (fn x_855: int8 * word32 =>
	  case x_855 of
	    (x: int8, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int8 * word32 -> int8 = (makeShop <<?)
val notb: int8 -> int8 = (makeUnop notb)
val >>?: int8 * word32 -> int8 = (makeShop >>?)
val minInt': int8 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int8 = (>>? ((notb zero), 0x1))
val idFromIntToWord: int16 -> word16 = idFromInt16ToWord16
val idFromWordToInt: word16 -> int16 = idFromWord16ToInt16
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word16 = (zextdFromWord32 0x0)
val maxWord': word16 = (notb zero)
val zero: int16 = (zextdFromInt32 0x0)
val one: int16 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word16 -> word16) -> int16 -> int16 = 
      (fn x_856: word16 -> word16 =>
       case x_856 of
	 (f: word16 -> word16) =>
	 (fn x_857: int16 =>
	  case x_857 of
	    x: int16 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word16 * word32 -> word16) -> int16 * word32 -> int16 = 
      (fn x_858: word16 * word32 -> word16 =>
       case x_858 of
	 (f: word16 * word32 -> word16) =>
	 (fn x_859: int16 * word32 =>
	  case x_859 of
	    (x: int16, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int16 * word32 -> int16 = (makeShop <<?)
val notb: int16 -> int16 = (makeUnop notb)
val >>?: int16 * word32 -> int16 = (makeShop >>?)
val minInt': int16 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int16 = (>>? ((notb zero), 0x1))
val idFromIntToWord: int32 -> word32 = idFromInt32ToWord32
val idFromWordToInt: word32 -> int32 = idFromWord32ToInt32
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word32 = (zextdFromWord32 0x0)
val one: word32 = (zextdFromWord32 0x1)
val maxWord': word32 = (notb zero)
val rec
   log2Word: word32 -> word32 = 
      (fn x_860: word32 =>
       case x_860 of
	 (w: word32) =>
	 let val rec
		loop: word32 * word32 * word32 -> word32 = 
		   (fn x_861: word32 * word32 * word32 =>
		    case x_861 of
		      ((n: word32, s: word32, acc: word32)) =>
		      case (= (word32) (n, one)) of
			true => acc
		      | false =>
			let val (n: word32, acc: word32) =
			       case (>= (n, (<<? (one, s)))) of
				 true => ((>>? (n, s)), (+ (acc, s)))
			       | false => (n, acc)
			in
			   (loop (n, (>>? (s, 0x1)), acc))
			end)
	 in
	    case case safe of
		   true => (= (word32) (w, zero)) | false => false of
	      true => raise Domain
	    | false => (loop (w, (>>? (sizeInBitsWord, 0x1)), 0x0))
	 end)
val rec
   log2: word32 -> int32 = 
      (fn x_862: word32 =>
       case x_862 of
	 (w: word32) => (zextdFromWord32ToInt32 (log2Word w)))
val zero: int32 = (zextdFromInt32 0x0)
val one: int32 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word32 -> word32) -> int32 -> int32 = 
      (fn x_863: word32 -> word32 =>
       case x_863 of
	 (f: word32 -> word32) =>
	 (fn x_864: int32 =>
	  case x_864 of
	    x: int32 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word32 * word32 -> word32) -> int32 * word32 -> int32 = 
      (fn x_865: word32 * word32 -> word32 =>
       case x_865 of
	 (f: word32 * word32 -> word32) =>
	 (fn x_866: int32 * word32 =>
	  case x_866 of
	    (x: int32, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int32 * word32 -> int32 = (makeShop <<?)
val notb: int32 -> int32 = (makeUnop notb)
val >>?: int32 * word32 -> int32 = (makeShop >>?)
val rec
   log2: int32 -> int32 = 
      (fn x_867: int32 =>
       case x_867 of
	 (i: int32) => (log2 (idFromIntToWord i)))
val minInt': int32 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int32 = (>>? ((notb zero), 0x1))
val rec
   quot: int32 * int32 -> int32 = 
      (fn x_868: int32 * int32 =>
       case x_868 of
	 ((x: int32, y: int32)) =>
	 case case safe of
		true => (= (int32) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case case case detectOverflow of
			    true => true | false => safe of
		       true => (= (int32) (x, minInt')) | false => false of
		  true => (= (int32) (y, (~ one))) | false => false of
	     true =>
	     case detectOverflow of
	       true => raise Overflow | false => minInt'
	   | false => (quotUnsafe (x, y)))
val rec
   rem: int32 * int32 -> int32 = 
      (fn x_869: int32 * int32 =>
       case x_869 of
	 ((x: int32, y: int32)) =>
	 case case safe of
		true => (= (int32) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case (= (int32) (x, minInt')) of
		  true => (= (int32) (y, (~ one))) | false => false of
	     true => zero | false => (remUnsafe (x, y)))
val rec
   mod: int32 * int32 -> int32 = 
      (fn x_870: int32 * int32 =>
       case x_870 of
	 ((x: int32, y: int32)) =>
	 case (>= (x, zero)) of
	   true =>
	   case (> (y, zero)) of
	     true => (remUnsafe (x, y))
	   | false =>
	     case (< (y, zero)) of
	       true =>
	       case (= (int32) (x, zero)) of
		 true => zero
	       | false => (+? ((remUnsafe ((-? (x, one)), y)), (+ (y, one))))
	     | false => raise Div
	 | false =>
	   case (< (y, zero)) of
	     true =>
	     case case (= (int32) (x, minInt')) of
		    true => (= (int32) (y, (~ one))) | false => false of
	       true => zero | false => (remUnsafe (x, y))
	   | false =>
	     case (> (y, zero)) of
	       true => (+? ((remUnsafe ((+? (x, one)), y)), (-? (y, one))))
	     | false => raise Div)
val idFromIntToWord: int32 -> word32 = idFromIntToWord
val <: word32 * word32 -> bool = <
val rec
   ltu: int32 * int32 -> bool = 
      (fn x_871: int32 * int32 =>
       case x_871 of
	 ((i: int32, i': int32)) =>
	 (< ((idFromIntToWord i), (idFromIntToWord i'))))
val <: int32 * int32 -> bool = ltu
val <: int32 * int32 -> bool = <
val rec
   >: int32 * int32 -> bool = 
      (fn x_872: int32 * int32 =>
       case x_872 of
	 ((a: int32, b: int32)) => (< (b, a)))
val gtu: int32 * int32 -> bool = >
val idFromIntToWord: int64 -> word64 = idFromInt64ToWord64
val idFromWordToInt: word64 -> int64 = idFromWord64ToInt64
val _ =
   case case (<> (int32) (sizeInBits, sizeInBits)) of
	  true => true | false => (<> (word32) (sizeInBitsWord, sizeInBitsWord)) of
     true => raise (Fail8 "MkNum0: Int.sizeInBits <> Word.sizeInBits")
   | false => ()
val zero: word64 = (zextdFromWord32 0x0)
val maxWord': word64 = (notb zero)
val zero: int64 = (zextdFromInt32 0x0)
val one: int64 = (zextdFromInt32 0x1)
val rec
   makeUnop: (word64 -> word64) -> int64 -> int64 = 
      (fn x_873: word64 -> word64 =>
       case x_873 of
	 (f: word64 -> word64) =>
	 (fn x_874: int64 =>
	  case x_874 of
	    x: int64 => (idFromWordToInt (f (idFromIntToWord x)))))
val rec
   makeShop: (word64 * word32 -> word64) -> int64 * word32 -> int64 = 
      (fn x_875: word64 * word32 -> word64 =>
       case x_875 of
	 (f: word64 * word32 -> word64) =>
	 (fn x_876: int64 * word32 =>
	  case x_876 of
	    (x: int64, w: word32) =>
	    (idFromWordToInt (f ((idFromIntToWord x), w)))))
val <<?: int64 * word32 -> int64 = (makeShop <<?)
val notb: int64 -> int64 = (makeUnop notb)
val ~>>?: int64 * word32 -> int64 = (makeShop ~>>?)
val >>?: int64 * word32 -> int64 = (makeShop >>?)
val minInt': int64 = (<<? (one, (- (sizeInBitsWord, 0x1))))
val maxInt': int64 = (>>? ((notb zero), 0x1))
val rec
   quot: int64 * int64 -> int64 = 
      (fn x_877: int64 * int64 =>
       case x_877 of
	 ((x: int64, y: int64)) =>
	 case case safe of
		true => (= (int64) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case case case detectOverflow of
			    true => true | false => safe of
		       true => (= (int64) (x, minInt')) | false => false of
		  true => (= (int64) (y, (~ one))) | false => false of
	     true =>
	     case detectOverflow of
	       true => raise Overflow | false => minInt'
	   | false => (quotUnsafe (x, y)))
val rec
   rem: int64 * int64 -> int64 = 
      (fn x_878: int64 * int64 =>
       case x_878 of
	 ((x: int64, y: int64)) =>
	 case case safe of
		true => (= (int64) (y, zero)) | false => false of
	   true => raise Div
	 | false =>
	   case case (= (int64) (x, minInt')) of
		  true => (= (int64) (y, (~ one))) | false => false of
	     true => zero | false => (remUnsafe (x, y)))
val idFromIntToWord: int64 -> word64 = idFromIntToWord
val <: word64 * word64 -> bool = <
val rec
   ltu: int64 * int64 -> bool = 
      (fn x_879: int64 * int64 =>
       case x_879 of
	 ((i: int64, i': int64)) =>
	 (< ((idFromIntToWord i), (idFromIntToWord i'))))
val <: int64 * int64 -> bool = ltu
val <: int64 * int64 -> bool = <
val rec
   <=: int64 * int64 -> bool = 
      (fn x_880: int64 * int64 =>
       case x_880 of
	 ((a: int64, b: int64)) => (not (< (b, a))))
val rec
   >: int64 * int64 -> bool = 
      (fn x_881: int64 * int64 =>
       case x_881 of
	 ((a: int64, b: int64)) => (< (b, a)))
val rec
   >=: int64 * int64 -> bool = 
      (fn x_882: int64 * int64 =>
       case x_882 of
	 ((a: int64, b: int64)) => (<= (b, a)))
val gtu: int64 * int64 -> bool = >
val geu: int64 * int64 -> bool = >=
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> word64 = fInt64
val idFromObjptrInt: int64 -> word64 = f
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val fInt64: word64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: word64 -> int64 = fInt64
val idToObjptrInt: word64 -> int64 = f
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> word64 = fInt64
val zextdFromSeqIndex: int64 -> word64 = f
datatype Primitive.IntInf.rep = Big of word64 vector
				| Small of int64
val zero: intInf = 0
val rec
   isSmall: intInf -> bool = 
      (fn x_883: intInf =>
       case x_883 of
	 (i: intInf) => (<> (word64) (0x0, (andb ((toWord i), 0x1)))))
val rec
   areSmall: intInf * intInf -> bool = 
      (fn x_884: intInf * intInf =>
       case x_884 of
	 ((i: intInf, i': intInf)) =>
	 (<> (word64) (0x0, (andb ((andb ((toWord i), (toWord i'))), 0x1)))))
val rec
   bigNumLimbs: intInf -> int64 = 
      (fn x_885: intInf =>
       case x_885 of
	 (i: intInf) => (- ((length (word64) (toVector i)), 0x1)))
val rec
   numLimbs: intInf -> int64 = 
      (fn x_886: intInf =>
       case x_886 of
	 (i: intInf) =>
	 case (isSmall i) of
	   true => 0x1 | false => (bigNumLimbs i))
val rec
   dropTag: word64 -> word64 = 
      (fn x_887: word64 =>
       case x_887 of
	 (w: word64) => (~>>? (w, 0x1)))
val rec
   dropTagCoerce: intInf -> word64 = 
      (fn x_888: intInf =>
       case x_888 of
	 (i: intInf) => (dropTag (toWord i)))
val rec
   dropTagCoerceInt: intInf -> int64 = 
      (fn x_889: intInf =>
       case x_889 of
	 (i: intInf) => (idToObjptrInt (dropTagCoerce i)))
val rec
   addTag: word64 -> word64 = 
      (fn x_890: word64 =>
       case x_890 of
	 (w: word64) => (orb ((<<? (w, 0x1)), 0x1)))
val rec
   addTagCoerce: word64 -> intInf = 
      (fn x_891: word64 =>
       case x_891 of
	 (w: word64) => (fromWord (addTag w)))
val rec 'a
   make: {other: {eq: 'a * 'a -> bool,
		  isNeg: 'a -> bool,
		  neg: 'a -> 'a,
		  notb: 'a -> 'a,
		  rashift: 'a * word32 -> 'a,
		  rshift: 'a * word32 -> 'a,
		  sizeInBits: int32,
		  zero: 'a},
	  sextdToObjptrWord: 'a -> word64,
	  zextdToMPLimb: 'a -> word64,
	  zextdToObjptrWord: 'a -> word64}
	 -> bool * 'a -> intInf = 
      (fn x_892: {other: {eq: 'a * 'a -> bool,
			  isNeg: 'a -> bool,
			  neg: 'a -> 'a,
			  notb: 'a -> 'a,
			  rashift: 'a * word32 -> 'a,
			  rshift: 'a * word32 -> 'a,
			  sizeInBits: int32,
			  zero: 'a},
		  sextdToObjptrWord: 'a -> word64,
		  zextdToMPLimb: 'a -> word64,
		  zextdToObjptrWord: 'a -> word64} =>
       (fn x_893: bool * 'a =>
	case (x_892, x_893) of
	  ({zextdToMPLimb = zextdToMPLimb: 'a -> word64,
	    zextdToObjptrWord = zextdToObjptrWord: 'a -> word64,
	    sextdToObjptrWord = sextdToObjptrWord: 'a -> word64,
	    other = other: {eq: 'a * 'a -> bool,
			    isNeg: 'a -> bool,
			    neg: 'a -> 'a,
			    notb: 'a -> 'a,
			    rashift: 'a * word32 -> 'a,
			    rshift: 'a * word32 -> 'a,
			    sizeInBits: int32,
			    zero: 'a}},
	   (sextd: bool, w: 'a)) =>
	  case case (> (sizeInBits,
			((fn x_906: {eq: 'a * 'a -> bool,
				     isNeg: 'a -> bool,
				     neg: 'a -> 'a,
				     notb: 'a -> 'a,
				     rashift: 'a * word32 -> 'a,
				     rshift: 'a * word32 -> 'a,
				     sizeInBits: int32,
				     zero: 'a} =>
			  case x_906 of
			    {sizeInBits = #: int32} => #) other))) of
		 true => true
	       | false =>
		 let val shift: word32 = (- (sizeInBitsWord, 0x2))
		     val upperBits: 'a =
			(((fn x_903: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			   case x_903 of
			     {rashift = #: 'a * word32 -> 'a} => #) other) (w, shift))
		     val zeroBits: 'a =
			((fn x_902: {eq: 'a * 'a -> bool,
				     isNeg: 'a -> bool,
				     neg: 'a -> 'a,
				     notb: 'a -> 'a,
				     rashift: 'a * word32 -> 'a,
				     rshift: 'a * word32 -> 'a,
				     sizeInBits: int32,
				     zero: 'a} =>
			  case x_902 of
			    {zero = #: 'a} => #) other)
		     val oneBits: 'a =
			(((fn x_901: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			   case x_901 of
			     {notb = #: 'a -> 'a} => #) other) zeroBits)
		 in
		    case (((fn x_905: {eq: 'a * 'a -> bool,
				       isNeg: 'a -> bool,
				       neg: 'a -> 'a,
				       notb: 'a -> 'a,
				       rashift: 'a * word32 -> 'a,
				       rshift: 'a * word32 -> 'a,
				       sizeInBits: int32,
				       zero: 'a} =>
			    case x_905 of
			      {eq = #: 'a * 'a -> bool} => #) other) (upperBits, zeroBits)) of
		      true => true
		    | false =>
		      case sextd of
			true =>
			(((fn x_904: {eq: 'a * 'a -> bool,
				      isNeg: 'a -> bool,
				      neg: 'a -> 'a,
				      notb: 'a -> 'a,
				      rashift: 'a * word32 -> 'a,
				      rshift: 'a * word32 -> 'a,
				      sizeInBits: int32,
				      zero: 'a} =>
			   case x_904 of
			     {eq = #: 'a * 'a -> bool} => #) other) (upperBits, oneBits))
		      | false => false
		 end of
	    true =>
	    case sextd of
	      true => (fromWord (addTag (sextdToObjptrWord w)))
	    | false => (fromWord (addTag (zextdToObjptrWord w)))
	  | false =>
	    let val rec
		   loop: 'a * int64 * (int64 * word64) list
			 -> int64 * (int64 * word64) list = 
		      (fn x_897: 'a * int64 * (int64 * word64) list =>
		       case x_897 of
			 ((w: 'a, i: int64, acc: (int64 * word64) list)) =>
			 case (((fn x_899: {eq: 'a * 'a -> bool,
					    isNeg: 'a -> bool,
					    neg: 'a -> 'a,
					    notb: 'a -> 'a,
					    rashift: 'a * word32 -> 'a,
					    rshift: 'a * word32 -> 'a,
					    sizeInBits: int32,
					    zero: 'a} =>
				 case x_899 of
				   {eq = #: 'a * 'a -> bool} => #) other) (w,
					((fn x_900: {eq: 'a * 'a -> bool,
						     isNeg: 'a -> bool,
						     neg: 'a -> 'a,
						     notb: 'a -> 'a,
						     rashift: 'a * word32 -> 'a,
						     rshift: 'a * word32 -> 'a,
						     sizeInBits: int32,
						     zero: 'a} =>
					  case x_900 of
					    {zero = #: 'a} => #) other))) of
			   true => (i, acc)
			 | false =>
			   let val limb: word64 = (zextdToMPLimb w)
			       val w: 'a =
				  (((fn x_898: {eq: 'a * 'a -> bool,
						isNeg: 'a -> bool,
						neg: 'a -> 'a,
						notb: 'a -> 'a,
						rashift: 'a * word32 -> 'a,
						rshift: 'a * word32 -> 'a,
						sizeInBits: int32,
						zero: 'a} =>
				     case x_898 of
				       {rshift = #: 'a * word32 -> 'a} => #) other) (w, sizeInBitsWord))
			   in
			      (loop (w,
				     (+ (i, 0x1)),
				     (::[int64 * word64] ((i, limb), acc))))
			   end)
		val (n: int64, acc: (int64 * word64) list) =
		   case case sextd of
			  true =>
			  (((fn x_896: {eq: 'a * 'a -> bool,
					isNeg: 'a -> bool,
					neg: 'a -> 'a,
					notb: 'a -> 'a,
					rashift: 'a * word32 -> 'a,
					rshift: 'a * word32 -> 'a,
					sizeInBits: int32,
					zero: 'a} =>
			     case x_896 of
			       {isNeg = #: 'a -> bool} => #) other) w)
			| false => false of
		     true =>
		     (loop ((((fn x_895: {eq: 'a * 'a -> bool,
					  isNeg: 'a -> bool,
					  neg: 'a -> 'a,
					  notb: 'a -> 'a,
					  rashift: 'a * word32 -> 'a,
					  rshift: 'a * word32 -> 'a,
					  sizeInBits: int32,
					  zero: 'a} =>
			       case x_895 of
				 {neg = #: 'a -> 'a} => #) other) w),
			    0x1,
			    [(0x0, 0x1)]))
		   | false => (loop (w, 0x1, [(0x0, 0x0)]))
		val a: word64 array = (arrayUnsafe (word64) n)
		val rec
		   loop: (int64 * word64) list -> unit = 
		      (fn x_894: (int64 * word64) list =>
		       case x_894 of
			 (acc: (int64 * word64) list) =>
			 case acc of
			   [] => ()
			 | ::[int64 * word64] ((i: int64, v: word64),
					       acc: (int64 * word64) list) =>
			   (updateUnsafe (word64) (a, i, v)) ;(loop acc))
		val () = (loop acc)
	    in
	       (fromVector (fromArrayUnsafe (word64) a))
	    end))
val rec
   extdFromWord8: bool * word8 -> intInf = 
      (fn x_907: bool * word8 =>
       case x_907 of
	 ((sextd: bool, w: word8)) =>
	 ((make (word8) {zextdToMPLimb = zextdFromWord8,
			 zextdToObjptrWord = zextdFromWord8,
			 sextdToObjptrWord = sextdFromWord8,
			 other = {sizeInBits = sizeInBits,
				  zero = zero,
				  eq = = (word8),
				  isNeg = (fn x_908: word8 =>
					   case x_908 of
					     w: word8 =>
					     (< ((idFromWord8ToInt8 w), 0x0))),
				  neg = ~,
				  notb = notb,
				  rashift = ~>>?,
				  rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord8: word8 -> intInf = 
      (fn x_909: word8 =>
       case x_909 of
	 (w: word8) => (extdFromWord8 (false, w)))
val rec
   zextdFromInt8: int8 -> intInf = 
      (fn x_910: int8 =>
       case x_910 of
	 (i: int8) => (zextdFromWord8 (idFromInt8ToWord8 i)))
val rec
   sextdFromWord8: word8 -> intInf = 
      (fn x_911: word8 =>
       case x_911 of
	 (w: word8) => (extdFromWord8 (true, w)))
val rec
   sextdFromInt8: int8 -> intInf = 
      (fn x_912: int8 =>
       case x_912 of
	 (i: int8) => (sextdFromWord8 (idFromInt8ToWord8 i)))
val castFromInt8: int8 -> intInf = sextdFromInt8
val castFromWord8: word8 -> intInf = zextdFromWord8
val zchckFromInt8: int8 -> intInf = zextdFromInt8
val zchckFromWord8: word8 -> intInf = zextdFromWord8
val schckFromInt8: int8 -> intInf = sextdFromInt8
val schckFromWord8: word8 -> intInf = sextdFromWord8
val rec
   extdFromWord16: bool * word16 -> intInf = 
      (fn x_913: bool * word16 =>
       case x_913 of
	 ((sextd: bool, w: word16)) =>
	 ((make (word16) {zextdToMPLimb = zextdFromWord16,
			  zextdToObjptrWord = zextdFromWord16,
			  sextdToObjptrWord = sextdFromWord16,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word16),
				   isNeg = (fn x_914: word16 =>
					    case x_914 of
					      w: word16 =>
					      (< ((idFromWord16ToInt16 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord16: word16 -> intInf = 
      (fn x_915: word16 =>
       case x_915 of
	 (w: word16) => (extdFromWord16 (false, w)))
val rec
   zextdFromInt16: int16 -> intInf = 
      (fn x_916: int16 =>
       case x_916 of
	 (i: int16) => (zextdFromWord16 (idFromInt16ToWord16 i)))
val rec
   sextdFromWord16: word16 -> intInf = 
      (fn x_917: word16 =>
       case x_917 of
	 (w: word16) => (extdFromWord16 (true, w)))
val rec
   sextdFromInt16: int16 -> intInf = 
      (fn x_918: int16 =>
       case x_918 of
	 (i: int16) => (sextdFromWord16 (idFromInt16ToWord16 i)))
val castFromInt16: int16 -> intInf = sextdFromInt16
val castFromWord16: word16 -> intInf = zextdFromWord16
val zchckFromInt16: int16 -> intInf = zextdFromInt16
val zchckFromWord16: word16 -> intInf = zextdFromWord16
val schckFromInt16: int16 -> intInf = sextdFromInt16
val schckFromWord16: word16 -> intInf = sextdFromWord16
val rec
   extdFromWord32: bool * word32 -> intInf = 
      (fn x_919: bool * word32 =>
       case x_919 of
	 ((sextd: bool, w: word32)) =>
	 ((make (word32) {zextdToMPLimb = zextdFromWord32,
			  zextdToObjptrWord = zextdFromWord32,
			  sextdToObjptrWord = sextdFromWord32,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word32),
				   isNeg = (fn x_920: word32 =>
					    case x_920 of
					      w: word32 =>
					      (< ((idFromWord32ToInt32 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord32: word32 -> intInf = 
      (fn x_921: word32 =>
       case x_921 of
	 (w: word32) => (extdFromWord32 (false, w)))
val rec
   zextdFromInt32: int32 -> intInf = 
      (fn x_922: int32 =>
       case x_922 of
	 (i: int32) => (zextdFromWord32 (idFromInt32ToWord32 i)))
val rec
   sextdFromWord32: word32 -> intInf = 
      (fn x_923: word32 =>
       case x_923 of
	 (w: word32) => (extdFromWord32 (true, w)))
val rec
   sextdFromInt32: int32 -> intInf = 
      (fn x_924: int32 =>
       case x_924 of
	 (i: int32) => (sextdFromWord32 (idFromInt32ToWord32 i)))
val castFromInt32: int32 -> intInf = sextdFromInt32
val castFromWord32: word32 -> intInf = zextdFromWord32
val zchckFromInt32: int32 -> intInf = zextdFromInt32
val zchckFromWord32: word32 -> intInf = zextdFromWord32
val schckFromInt32: int32 -> intInf = sextdFromInt32
val schckFromWord32: word32 -> intInf = sextdFromWord32
val rec
   extdFromWord64: bool * word64 -> intInf = 
      (fn x_925: bool * word64 =>
       case x_925 of
	 ((sextd: bool, w: word64)) =>
	 ((make (word64) {zextdToMPLimb = zextdFromWord64,
			  zextdToObjptrWord = zextdFromWord64,
			  sextdToObjptrWord = sextdFromWord64,
			  other = {sizeInBits = sizeInBits,
				   zero = zero,
				   eq = = (word64),
				   isNeg = (fn x_926: word64 =>
					    case x_926 of
					      w: word64 =>
					      (< ((idFromWord64ToInt64 w), 0x0))),
				   neg = ~,
				   notb = notb,
				   rashift = ~>>?,
				   rshift = >>?}}) (sextd, w)))
val rec
   zextdFromWord64: word64 -> intInf = 
      (fn x_927: word64 =>
       case x_927 of
	 (w: word64) => (extdFromWord64 (false, w)))
val rec
   zextdFromInt64: int64 -> intInf = 
      (fn x_928: int64 =>
       case x_928 of
	 (i: int64) => (zextdFromWord64 (idFromInt64ToWord64 i)))
val rec
   sextdFromWord64: word64 -> intInf = 
      (fn x_929: word64 =>
       case x_929 of
	 (w: word64) => (extdFromWord64 (true, w)))
val rec
   sextdFromInt64: int64 -> intInf = 
      (fn x_930: int64 =>
       case x_930 of
	 (i: int64) => (sextdFromWord64 (idFromInt64ToWord64 i)))
val castFromInt64: int64 -> intInf = sextdFromInt64
val castFromWord64: word64 -> intInf = zextdFromWord64
val zchckFromInt64: int64 -> intInf = zextdFromInt64
val zchckFromWord64: word64 -> intInf = zextdFromWord64
val schckFromInt64: int64 -> intInf = sextdFromInt64
val schckFromWord64: word64 -> intInf = sextdFromWord64
val rec 'a_353
   zextdFromIntInf: 'a_353 -> 'a_353 = 
      (fn x_931: 'a_353 =>
       case x_931 of
	 (ii: 'a_353) => ii)
val rec 'a_354
   sextdFromIntInf: 'a_354 -> 'a_354 = 
      (fn x_932: 'a_354 =>
       case x_932 of
	 (ii: 'a_354) => ii)
val rec 'a_355
   castFromIntInf: 'a_355 -> 'a_355 = 
      (fn x_933: 'a_355 =>
       case x_933 of
	 (ii: 'a_355) => ii)
val rec 'a_356
   zchckFromIntInf: 'a_356 -> 'a_356 = 
      (fn x_934: 'a_356 =>
       case x_934 of
	 (ii: 'a_356) => ii)
val rec 'a_357
   schckFromIntInf: 'a_357 -> 'a_357 = 
      (fn x_935: 'a_357 =>
       case x_935 of
	 (ii: 'a_357) => ii)
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val fInt64: int64 -> intInf = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val f: int64 -> intInf = fInt64
val sextdFromObjptrInt: int64 -> intInf = f
datatype 'a Primitive.IntInf.ans = Big of bool * bool * 'a
				   | Small of word64
val rec 'a
   make: {other: {lshift: 'a * word32 -> 'a,
		  orb: 'a * 'a -> 'a,
		  sizeInBits: int32,
		  sizeInBitsWord: word32,
		  zero: 'a},
	  zextdFromMPLimb: word64 -> 'a}
	 -> intInf -> 'a Primitive.IntInf.ans = 
      (fn x_936: {other: {lshift: 'a * word32 -> 'a,
			  orb: 'a * 'a -> 'a,
			  sizeInBits: int32,
			  sizeInBitsWord: word32,
			  zero: 'a},
		  zextdFromMPLimb: word64 -> 'a} =>
       (fn x_937: intInf =>
	case (x_936, x_937) of
	  ({zextdFromMPLimb = zextdFromMPLimb: word64 -> 'a,
	    other = other: {lshift: 'a * word32 -> 'a,
			    orb: 'a * 'a -> 'a,
			    sizeInBits: int32,
			    sizeInBitsWord: word32,
			    zero: 'a}},
	   i: intInf) =>
	  case (isSmall i) of
	    true => (Small['a] (dropTagCoerce i))
	  | false =>
	    let val v: word64 vector = (toVector i)
		val n: int64 = (length (word64) v)
		val isneg: bool =
		   (<> (word64) ((subUnsafe (word64) (v, 0x0)), 0x0))
	    in
	       case (>= (sizeInBits,
			 ((fn x_944: {lshift: 'a * word32 -> 'a,
				      orb: 'a * 'a -> 'a,
				      sizeInBits: int32,
				      sizeInBitsWord: word32,
				      zero: 'a} =>
			   case x_944 of
			     {sizeInBits = #: int32} => #) other))) of
		 true =>
		 let val limbsPer: int64 = 0x1
		     val limb: word64 = (subUnsafe (word64) (v, 0x1))
		     val extra: bool =
			case (> (n, (+ (limbsPer, 0x1)))) of
			  true => true
			| false =>
			  (<> (word64) ((>>? (limb,
					      ((fn x_938: {lshift: 'a * word32
								   -> 'a,
							   orb: 'a * 'a -> 'a,
							   sizeInBits: int32,
							   sizeInBitsWord: word32,
							   zero: 'a} =>
						case x_938 of
						  {sizeInBitsWord = #: word32} =>
						  #) other))),
					0x0))
		     val ans: 'a = (zextdFromMPLimb limb)
		 in
		    (Big['a] (isneg, extra, ans))
		 end
	       | false =>
		 let val limbsPer: int64 =
			(sextdFromInt32 (quot (((fn x_943: {lshift: 'a * word32
								    -> 'a,
							    orb: 'a * 'a -> 'a,
							    sizeInBits: int32,
							    sizeInBitsWord: word32,
							    zero: 'a} =>
						 case x_943 of
						   {sizeInBits = #: int32} => #) other),
					       sizeInBits)))
		     val extra: bool = (> (n, (+ (limbsPer, 0x1))))
		     val ans: 'a =
			let val rec
			       loop: int64 * 'a -> 'a = 
				  (fn x_939: int64 * 'a =>
				   case x_939 of
				     ((i: int64, ans: 'a)) =>
				     case (> (i, 0x0)) of
				       true =>
				       let val limb: word64 =
					      (subUnsafe (word64) (v, i))
					   val ans: 'a =
					      (((fn x_940: {lshift: 'a * word32
								    -> 'a,
							    orb: 'a * 'a -> 'a,
							    sizeInBits: int32,
							    sizeInBitsWord: word32,
							    zero: 'a} =>
						 case x_940 of
						   {orb = #: 'a * 'a -> 'a} => #) other) ((((fn x_941: {lshift: 'a * word32 -> 'a,
						     orb: 'a * 'a -> 'a,
						     sizeInBits: int32,
						     sizeInBitsWord: word32,
						     zero: 'a} =>
					  case x_941 of
					    {lshift = #: 'a * word32 -> 'a} => #) other) (ans, sizeInBitsWord)),
				       (zextdFromMPLimb limb)))
				       in
					  (loop ((- (i, 0x1)), ans))
				       end
				     | false => ans)
			in
			   (loop ((min ((- (n, 0x1)), limbsPer)),
				  ((fn x_942: {lshift: 'a * word32 -> 'a,
					       orb: 'a * 'a -> 'a,
					       sizeInBits: int32,
					       sizeInBitsWord: word32,
					       zero: 'a} =>
				    case x_942 of
				      {zero = #: 'a} => #) other)))
			end
		 in
		    (Big['a] (isneg, extra, ans))
		 end
	    end))
val chckToWord8Aux: intInf -> word8 Primitive.IntInf.ans =
   (make (word8) {zextdFromMPLimb = zextdToWord8,
		  other = {sizeInBits = sizeInBits,
			   sizeInBitsWord = sizeInBitsWord,
			   zero = zero,
			   lshift = <<?,
			   orb = orb}})
val rec
   sextdToWord8: intInf -> word8 = 
      (fn x_945: intInf =>
       case x_945 of
	 (i: intInf) =>
	 case (chckToWord8Aux i) of
	   Small[word8] w: word64 => (sextdToWord8 w)
	 | Big[word8] (isneg: bool, _, ans: word8) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt8: intInf -> int8 = 
      (fn x_946: intInf =>
       case x_946 of
	 (i: intInf) => (idFromWord8ToInt8 (sextdToWord8 i)))
val zextdToWord8: intInf -> word8 = sextdToWord8
val rec
   zextdToInt8: intInf -> int8 = 
      (fn x_947: intInf =>
       case x_947 of
	 (i: intInf) => (idFromWord8ToInt8 (zextdToWord8 i)))
val castToWord8: intInf -> word8 = sextdToWord8
val castToInt8: intInf -> int8 = sextdToInt8
val rec
   schckToWord8: intInf -> word8 = 
      (fn x_948: intInf =>
       case x_948 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord8 i)
	 | false =>
	   case (chckToWord8Aux i) of
	     Small[word8] w: word64 => (schckToWord8 w)
	   | Big[word8] (isneg: bool, extra: bool, ans: word8) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word8 = (~ ans)
		     val ans': int8 = (idFromWord8ToInt8 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int8 = (idFromWord8ToInt8 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt8: intInf -> int8 = 
      (fn x_949: intInf =>
       case x_949 of
	 (i: intInf) => (idFromWord8ToInt8 (schckToWord8 i)))
val rec
   zchckToWord8: intInf -> word8 = 
      (fn x_950: intInf =>
       case x_950 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord8 i)
	 | false =>
	   case (chckToWord8Aux i) of
	     Small[word8] w: word64 => (schckToWord8 w)
	   | Big[word8] (isneg: bool, extra: bool, ans: word8) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt8: intInf -> int8 = 
      (fn x_951: intInf =>
       case x_951 of
	 (i: intInf) => (idFromWord8ToInt8 (zchckToWord8 i)))
val chckToWord16Aux: intInf -> word16 Primitive.IntInf.ans =
   (make (word16) {zextdFromMPLimb = zextdToWord16,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord16: intInf -> word16 = 
      (fn x_952: intInf =>
       case x_952 of
	 (i: intInf) =>
	 case (chckToWord16Aux i) of
	   Small[word16] w: word64 => (sextdToWord16 w)
	 | Big[word16] (isneg: bool, _, ans: word16) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt16: intInf -> int16 = 
      (fn x_953: intInf =>
       case x_953 of
	 (i: intInf) => (idFromWord16ToInt16 (sextdToWord16 i)))
val zextdToWord16: intInf -> word16 = sextdToWord16
val rec
   zextdToInt16: intInf -> int16 = 
      (fn x_954: intInf =>
       case x_954 of
	 (i: intInf) => (idFromWord16ToInt16 (zextdToWord16 i)))
val castToWord16: intInf -> word16 = sextdToWord16
val castToInt16: intInf -> int16 = sextdToInt16
val rec
   schckToWord16: intInf -> word16 = 
      (fn x_955: intInf =>
       case x_955 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord16 i)
	 | false =>
	   case (chckToWord16Aux i) of
	     Small[word16] w: word64 => (schckToWord16 w)
	   | Big[word16] (isneg: bool, extra: bool, ans: word16) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word16 = (~ ans)
		     val ans': int16 = (idFromWord16ToInt16 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int16 = (idFromWord16ToInt16 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt16: intInf -> int16 = 
      (fn x_956: intInf =>
       case x_956 of
	 (i: intInf) => (idFromWord16ToInt16 (schckToWord16 i)))
val rec
   zchckToWord16: intInf -> word16 = 
      (fn x_957: intInf =>
       case x_957 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord16 i)
	 | false =>
	   case (chckToWord16Aux i) of
	     Small[word16] w: word64 => (schckToWord16 w)
	   | Big[word16] (isneg: bool, extra: bool, ans: word16) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt16: intInf -> int16 = 
      (fn x_958: intInf =>
       case x_958 of
	 (i: intInf) => (idFromWord16ToInt16 (zchckToWord16 i)))
val chckToWord32Aux: intInf -> word32 Primitive.IntInf.ans =
   (make (word32) {zextdFromMPLimb = zextdToWord32,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord32: intInf -> word32 = 
      (fn x_959: intInf =>
       case x_959 of
	 (i: intInf) =>
	 case (chckToWord32Aux i) of
	   Small[word32] w: word64 => (sextdToWord32 w)
	 | Big[word32] (isneg: bool, _, ans: word32) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt32: intInf -> int32 = 
      (fn x_960: intInf =>
       case x_960 of
	 (i: intInf) => (idFromWord32ToInt32 (sextdToWord32 i)))
val zextdToWord32: intInf -> word32 = sextdToWord32
val rec
   zextdToInt32: intInf -> int32 = 
      (fn x_961: intInf =>
       case x_961 of
	 (i: intInf) => (idFromWord32ToInt32 (zextdToWord32 i)))
val castToWord32: intInf -> word32 = sextdToWord32
val castToInt32: intInf -> int32 = sextdToInt32
val rec
   schckToWord32: intInf -> word32 = 
      (fn x_962: intInf =>
       case x_962 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord32 i)
	 | false =>
	   case (chckToWord32Aux i) of
	     Small[word32] w: word64 => (schckToWord32 w)
	   | Big[word32] (isneg: bool, extra: bool, ans: word32) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word32 = (~ ans)
		     val ans': int32 = (idFromWord32ToInt32 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int32 = (idFromWord32ToInt32 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt32: intInf -> int32 = 
      (fn x_963: intInf =>
       case x_963 of
	 (i: intInf) => (idFromWord32ToInt32 (schckToWord32 i)))
val rec
   zchckToWord32: intInf -> word32 = 
      (fn x_964: intInf =>
       case x_964 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord32 i)
	 | false =>
	   case (chckToWord32Aux i) of
	     Small[word32] w: word64 => (schckToWord32 w)
	   | Big[word32] (isneg: bool, extra: bool, ans: word32) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt32: intInf -> int32 = 
      (fn x_965: intInf =>
       case x_965 of
	 (i: intInf) => (idFromWord32ToInt32 (zchckToWord32 i)))
val chckToWord64Aux: intInf -> word64 Primitive.IntInf.ans =
   (make (word64) {zextdFromMPLimb = zextdToWord64,
		   other = {sizeInBits = sizeInBits,
			    sizeInBitsWord = sizeInBitsWord,
			    zero = zero,
			    lshift = <<?,
			    orb = orb}})
val rec
   sextdToWord64: intInf -> word64 = 
      (fn x_966: intInf =>
       case x_966 of
	 (i: intInf) =>
	 case (chckToWord64Aux i) of
	   Small[word64] w: word64 => (sextdToWord64 w)
	 | Big[word64] (isneg: bool, _, ans: word64) =>
	   case isneg of
	     true => (~ ans) | false => ans)
val rec
   sextdToInt64: intInf -> int64 = 
      (fn x_967: intInf =>
       case x_967 of
	 (i: intInf) => (idFromWord64ToInt64 (sextdToWord64 i)))
val zextdToWord64: intInf -> word64 = sextdToWord64
val rec
   zextdToInt64: intInf -> int64 = 
      (fn x_968: intInf =>
       case x_968 of
	 (i: intInf) => (idFromWord64ToInt64 (zextdToWord64 i)))
val castToWord64: intInf -> word64 = sextdToWord64
val castToInt64: intInf -> int64 = sextdToInt64
val rec
   schckToWord64: intInf -> word64 = 
      (fn x_969: intInf =>
       case x_969 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (sextdToWord64 i)
	 | false =>
	   case (chckToWord64Aux i) of
	     Small[word64] w: word64 => (schckToWord64 w)
	   | Big[word64] (isneg: bool, extra: bool, ans: word64) =>
	     case extra of
	       true => raise Overflow
	     | false =>
	       case isneg of
		 true =>
		 let val ans: word64 = (~ ans)
		     val ans': int64 = (idFromWord64ToInt64 ans)
		 in
		    case (> (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end
	       | false =>
		 let val ans': int64 = (idFromWord64ToInt64 ans)
		 in
		    case (< (ans', 0x0)) of
		      true => raise Overflow | false => ans
		 end)
val rec
   schckToInt64: intInf -> int64 = 
      (fn x_970: intInf =>
       case x_970 of
	 (i: intInf) => (idFromWord64ToInt64 (schckToWord64 i)))
val rec
   zchckToWord64: intInf -> word64 = 
      (fn x_971: intInf =>
       case x_971 of
	 (i: intInf) =>
	 case (not detectOverflow) of
	   true => (zextdToWord64 i)
	 | false =>
	   case (chckToWord64Aux i) of
	     Small[word64] w: word64 => (schckToWord64 w)
	   | Big[word64] (isneg: bool, extra: bool, ans: word64) =>
	     case case isneg of
		    true => true | false => extra of
	       true => raise Overflow | false => ans)
val rec
   zchckToInt64: intInf -> int64 = 
      (fn x_972: intInf =>
       case x_972 of
	 (i: intInf) => (idFromWord64ToInt64 (zchckToWord64 i)))
val rec 'a_360
   zextdToIntInf: 'a_360 -> 'a_360 = 
      (fn x_973: 'a_360 =>
       case x_973 of
	 (ii: 'a_360) => ii)
val rec 'a_361
   sextdToIntInf: 'a_361 -> 'a_361 = 
      (fn x_974: 'a_361 =>
       case x_974 of
	 (ii: 'a_361) => ii)
val rec 'a_362
   castToIntInf: 'a_362 -> 'a_362 = 
      (fn x_975: 'a_362 =>
       case x_975 of
	 (ii: 'a_362) => ii)
val rec 'a_363
   zchckToIntInf: 'a_363 -> 'a_363 = 
      (fn x_976: 'a_363 =>
       case x_976 of
	 (ii: 'a_363) => ii)
val rec 'a_364
   schckToIntInf: 'a_364 -> 'a_364 = 
      (fn x_977: 'a_364 =>
       case x_977 of
	 (ii: 'a_364) => ii)
val bytesPerMPLimb: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerCounter: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerLength: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerHeader: word64 = (zextdFromInt32 (quot (sizeInBits, 0x8)))
val bytesPerArrayHeader: word64 =
   (+ (bytesPerCounter, (+ (bytesPerLength, bytesPerHeader))))
val rec
   reserve: int64 * int64 -> word64 = 
      (fn x_978: int64 * int64 =>
       case x_978 of
	 ((num: int64, extra: int64)) =>
	 (+ ((* (bytesPerMPLimb, (zextdFromSeqIndex num))),
	     (+ ((* (bytesPerMPLimb, (zextdFromSeqIndex extra))),
		 (+ (bytesPerMPLimb,
		     (+ (bytesPerArrayHeader,
			 case align of
			   Align4 => 0x3 | Align8 => 0x7)))))))))
val badObjptrInt: int64 = (~>>? (minInt', 0x1))
val badObjptrWord: word64 = (idFromObjptrInt badObjptrInt)
val badObjptrWordTagged: word64 = (addTag badObjptrWord)
val negBadIntInf: intInf = (sextdFromObjptrInt (~ badObjptrInt))
val rec
   sameSignBit: word64 * word64 -> bool = 
      (fn x_979: word64 * word64 =>
       case x_979 of
	 ((lhs: word64, rhs: word64)) =>
	 (>= ((idToObjptrInt (xorb (lhs, rhs))), 0x0)))
val rec
   make: (int64 * int64 -> int64)
	 * (intInf * intInf * word64 -> intInf)
	 * (int64 * int64 -> int64)
	 * int64
	 -> intInf * intInf -> intInf = 
      (fn x_980: (int64 * int64 -> int64)
		 * (intInf * intInf * word64 -> intInf)
		 * (int64 * int64 -> int64)
		 * int64 =>
       (fn x_981: intInf * intInf =>
	case (x_980, x_981) of
	  ((smallOp: int64 * int64 -> int64,
	    bigOp: intInf * intInf * word64 -> intInf,
	    limbsFn: int64 * int64 -> int64,
	    extra: int64),
	   (lhs: intInf, rhs: intInf)) =>
	  let val res: intInf Primitive.Option.t =
		 case (areSmall (lhs, rhs)) of
		   true =>
		   let val lhsw: word64 = (dropTagCoerce lhs)
		       val lhsi: int64 = (idToObjptrInt lhsw)
		       val rhsw: word64 = (dropTagCoerce rhs)
		       val rhsi: int64 = (idToObjptrInt rhsw)
		       val ansi: int64 = (smallOp (lhsi, rhsi))
		       val answ: word64 = (idFromObjptrInt ansi)
		       val ans: word64 = (addTag answ)
		   in
		      case (sameSignBit (ans, answ)) of
			true => (SOME[intInf] (fromWord ans))
		      | false => NONE[intInf]
		   end
		   handle x_982 => case x_982 of
				     Overflow => NONE[intInf]
		 | false => NONE[intInf]
	  in
	     case res of
	       NONE[intInf] =>
	       (bigOp (lhs,
		       rhs,
		       (reserve ((limbsFn ((numLimbs lhs), (numLimbs rhs))),
				 extra))))
	     | SOME[intInf] i: intInf => i
	  end))
val bigAdd: intInf * intInf -> intInf = (make (+!, +, max, 0x1))
val bigMul: intInf * intInf -> intInf = (make (*!, *, +, 0x0))
val rec
   bigNeg: intInf -> intInf = 
      (fn x_983: intInf =>
       case x_983 of
	 (arg: intInf) =>
	 case (isSmall arg) of
	   true =>
	   let val argw: word64 = (toWord arg)
	   in
	      case (= (word64) (argw, badObjptrWordTagged)) of
		true => negBadIntInf | false => (fromWord (- (0x2, argw)))
	   end
	 | false => (~ (arg, (reserve ((numLimbs arg), 0x1)))))
val rec 'a
   make: (int64 * int64 -> 'a) * (int32 * int32 -> 'a) -> intInf * intInf -> 'a = 
      (fn x_984: (int64 * int64 -> 'a) * (int32 * int32 -> 'a) =>
       (fn x_985: intInf * intInf =>
	case (x_984, x_985) of
	  ((smallTest: int64 * int64 -> 'a, int32Test: int32 * int32 -> 'a),
	   (lhs: intInf, rhs: intInf)) =>
	  case (areSmall (lhs, rhs)) of
	    true =>
	    (smallTest ((idToObjptrInt (toWord lhs)),
			(idToObjptrInt (toWord rhs))))
	  | false => (int32Test ((compare (lhs, rhs)), 0x0))))
val bigLT: intInf * intInf -> bool = (make (bool) (<, <))
val rec
   mkBigCvt: {base: int32, smallCvt: int64 -> string} -> intInf -> string = 
      (fn x_986: {base: int32, smallCvt: int64 -> string} =>
       (fn x_987: intInf =>
	case (x_986, x_987) of
	  ({base = base: int32, smallCvt = smallCvt: int64 -> string},
	   arg: intInf) =>
	  case (isSmall arg) of
	    true => (smallCvt (dropTagCoerceInt arg))
	  | false =>
	    let val bpd: int32 = (log2 base)
		val bpl: int32 = sizeInBits
		val dpl: int32 =
		   (+ ((quot (bpl, bpd)),
		       case (= (int32) ((mod (bpl, bpd)), 0x0)) of
			 true => 0x0 | false => 0x1))
		val bytes: word64 =
		   (+ ((+ (bytesPerArrayHeader,
			   (+ (0x1, case align of Align4 => 0x3 | Align8 => 0x7)))),
		       (* ((zextdFromInt32 dpl),
			   (zextdFromSeqIndex (numLimbs arg))))))
	    in
	       (toString (arg, base, bytes))
	    end))
val addTagCoerce: word64 -> intInf = addTagCoerce
val +: intInf * intInf -> intInf = bigAdd
val *: intInf * intInf -> intInf = bigMul
val ~: intInf -> intInf = bigNeg
val <: intInf * intInf -> bool = bigLT
val mkCvt: {base: int32, smallCvt: int64 -> string} -> intInf -> string =
   mkBigCvt
val zextdFromInt8ToIntInf: int8 -> intInf = zextdFromInt8
val zextdFromInt16ToIntInf: int16 -> intInf = zextdFromInt16
val zextdFromInt32ToIntInf: int32 -> intInf = zextdFromInt32
val zextdFromInt64ToIntInf: int64 -> intInf = zextdFromInt64
val zextdFromWord8ToIntInf: word8 -> intInf = zextdFromWord8
val zextdFromWord16ToIntInf: word16 -> intInf = zextdFromWord16
val zextdFromWord32ToIntInf: word32 -> intInf = zextdFromWord32
val zextdFromWord64ToIntInf: word64 -> intInf = zextdFromWord64
val zextdFromIntInfToInt8: intInf -> int8 = zextdToInt8
val zextdFromIntInfToInt16: intInf -> int16 = zextdToInt16
val zextdFromIntInfToInt32: intInf -> int32 = zextdToInt32
val zextdFromIntInfToInt64: intInf -> int64 = zextdToInt64
val zextdFromIntInfToWord8: intInf -> word8 = zextdToWord8
val zextdFromIntInfToWord16: intInf -> word16 = zextdToWord16
val zextdFromIntInfToWord32: intInf -> word32 = zextdToWord32
val zextdFromIntInfToWord64: intInf -> word64 = zextdToWord64
val sextdFromInt8ToIntInf: int8 -> intInf = sextdFromInt8
val sextdFromInt16ToIntInf: int16 -> intInf = sextdFromInt16
val sextdFromInt32ToIntInf: int32 -> intInf = sextdFromInt32
val sextdFromInt64ToIntInf: int64 -> intInf = sextdFromInt64
val sextdFromWord8ToIntInf: word8 -> intInf = sextdFromWord8
val sextdFromWord16ToIntInf: word16 -> intInf = sextdFromWord16
val sextdFromWord32ToIntInf: word32 -> intInf = sextdFromWord32
val sextdFromWord64ToIntInf: word64 -> intInf = sextdFromWord64
val sextdFromIntInfToInt8: intInf -> int8 = sextdToInt8
val sextdFromIntInfToInt16: intInf -> int16 = sextdToInt16
val sextdFromIntInfToInt32: intInf -> int32 = sextdToInt32
val sextdFromIntInfToInt64: intInf -> int64 = sextdToInt64
val sextdFromIntInfToWord8: intInf -> word8 = sextdToWord8
val sextdFromIntInfToWord16: intInf -> word16 = sextdToWord16
val sextdFromIntInfToWord32: intInf -> word32 = sextdToWord32
val sextdFromIntInfToWord64: intInf -> word64 = sextdToWord64
val castFromInt8ToIntInf: int8 -> intInf = castFromInt8
val castFromInt16ToIntInf: int16 -> intInf = castFromInt16
val castFromInt32ToIntInf: int32 -> intInf = castFromInt32
val castFromInt64ToIntInf: int64 -> intInf = castFromInt64
val castFromWord8ToIntInf: word8 -> intInf = castFromWord8
val castFromWord16ToIntInf: word16 -> intInf = castFromWord16
val castFromWord32ToIntInf: word32 -> intInf = castFromWord32
val castFromWord64ToIntInf: word64 -> intInf = castFromWord64
val castFromIntInfToInt8: intInf -> int8 = castToInt8
val castFromIntInfToInt16: intInf -> int16 = castToInt16
val castFromIntInfToInt32: intInf -> int32 = castToInt32
val castFromIntInfToInt64: intInf -> int64 = castToInt64
val castFromIntInfToWord8: intInf -> word8 = castToWord8
val castFromIntInfToWord16: intInf -> word16 = castToWord16
val castFromIntInfToWord32: intInf -> word32 = castToWord32
val castFromIntInfToWord64: intInf -> word64 = castToWord64
val zchckFromInt8ToIntInf: int8 -> intInf = zchckFromInt8
val zchckFromInt16ToIntInf: int16 -> intInf = zchckFromInt16
val zchckFromInt32ToIntInf: int32 -> intInf = zchckFromInt32
val zchckFromInt64ToIntInf: int64 -> intInf = zchckFromInt64
val zchckFromWord8ToIntInf: word8 -> intInf = zchckFromWord8
val zchckFromWord16ToIntInf: word16 -> intInf = zchckFromWord16
val zchckFromWord32ToIntInf: word32 -> intInf = zchckFromWord32
val zchckFromWord64ToIntInf: word64 -> intInf = zchckFromWord64
val zchckFromIntInfToInt8: intInf -> int8 = zchckToInt8
val zchckFromIntInfToInt16: intInf -> int16 = zchckToInt16
val zchckFromIntInfToInt32: intInf -> int32 = zchckToInt32
val zchckFromIntInfToInt64: intInf -> int64 = zchckToInt64
val zchckFromIntInfToWord8: intInf -> word8 = zchckToWord8
val zchckFromIntInfToWord16: intInf -> word16 = zchckToWord16
val zchckFromIntInfToWord32: intInf -> word32 = zchckToWord32
val zchckFromIntInfToWord64: intInf -> word64 = zchckToWord64
val schckFromInt8ToIntInf: int8 -> intInf = schckFromInt8
val schckFromInt16ToIntInf: int16 -> intInf = schckFromInt16
val schckFromInt32ToIntInf: int32 -> intInf = schckFromInt32
val schckFromInt64ToIntInf: int64 -> intInf = schckFromInt64
val schckFromWord8ToIntInf: word8 -> intInf = schckFromWord8
val schckFromWord16ToIntInf: word16 -> intInf = schckFromWord16
val schckFromWord32ToIntInf: word32 -> intInf = schckFromWord32
val schckFromWord64ToIntInf: word64 -> intInf = schckFromWord64
val schckFromIntInfToInt8: intInf -> int8 = schckToInt8
val schckFromIntInfToInt16: intInf -> int16 = schckToInt16
val schckFromIntInfToInt32: intInf -> int32 = schckToInt32
val schckFromIntInfToInt64: intInf -> int64 = schckToInt64
val schckFromIntInfToWord8: intInf -> word8 = schckToWord8
val schckFromIntInfToWord16: intInf -> word16 = schckToWord16
val schckFromIntInfToWord32: intInf -> word32 = schckToWord32
val schckFromIntInfToWord64: intInf -> word64 = schckToWord64
val zextdFromIntInf: intInf -> int8 = zextdFromIntInfToInt8
val zextdToIntInf: int8 -> intInf = zextdFromInt8ToIntInf
val sextdFromIntInf: intInf -> int8 = sextdFromIntInfToInt8
val sextdToIntInf: int8 -> intInf = sextdFromInt8ToIntInf
val castFromIntInf: intInf -> int8 = castFromIntInfToInt8
val castToIntInf: int8 -> intInf = castFromInt8ToIntInf
val zchckFromIntInf: intInf -> int8 = zchckFromIntInfToInt8
val zchckToIntInf: int8 -> intInf = zchckFromInt8ToIntInf
val schckFromIntInf: intInf -> int8 = schckFromIntInfToInt8
val schckToIntInf: int8 -> intInf = schckFromInt8ToIntInf
val zextdFromIntInf: intInf -> int16 = zextdFromIntInfToInt16
val zextdToIntInf: int16 -> intInf = zextdFromInt16ToIntInf
val sextdFromIntInf: intInf -> int16 = sextdFromIntInfToInt16
val sextdToIntInf: int16 -> intInf = sextdFromInt16ToIntInf
val castFromIntInf: intInf -> int16 = castFromIntInfToInt16
val castToIntInf: int16 -> intInf = castFromInt16ToIntInf
val zchckFromIntInf: intInf -> int16 = zchckFromIntInfToInt16
val zchckToIntInf: int16 -> intInf = zchckFromInt16ToIntInf
val schckFromIntInf: intInf -> int16 = schckFromIntInfToInt16
val schckToIntInf: int16 -> intInf = schckFromInt16ToIntInf
val zextdFromIntInf: intInf -> int32 = zextdFromIntInfToInt32
val zextdToIntInf: int32 -> intInf = zextdFromInt32ToIntInf
val sextdFromIntInf: intInf -> int32 = sextdFromIntInfToInt32
val sextdToIntInf: int32 -> intInf = sextdFromInt32ToIntInf
val castFromIntInf: intInf -> int32 = castFromIntInfToInt32
val castToIntInf: int32 -> intInf = castFromInt32ToIntInf
val zchckFromIntInf: intInf -> int32 = zchckFromIntInfToInt32
val zchckToIntInf: int32 -> intInf = zchckFromInt32ToIntInf
val schckFromIntInf: intInf -> int32 = schckFromIntInfToInt32
val schckToIntInf: int32 -> intInf = schckFromInt32ToIntInf
val zextdFromIntInf: intInf -> int64 = zextdFromIntInfToInt64
val zextdToIntInf: int64 -> intInf = zextdFromInt64ToIntInf
val sextdFromIntInf: intInf -> int64 = sextdFromIntInfToInt64
val sextdToIntInf: int64 -> intInf = sextdFromInt64ToIntInf
val castFromIntInf: intInf -> int64 = castFromIntInfToInt64
val castToIntInf: int64 -> intInf = castFromInt64ToIntInf
val zchckFromIntInf: intInf -> int64 = zchckFromIntInfToInt64
val zchckToIntInf: int64 -> intInf = zchckFromInt64ToIntInf
val schckFromIntInf: intInf -> int64 = schckFromIntInfToInt64
val schckToIntInf: int64 -> intInf = schckFromInt64ToIntInf
val zextdFromIntInf: intInf -> word8 = zextdFromIntInfToWord8
val zextdToIntInf: word8 -> intInf = zextdFromWord8ToIntInf
val sextdFromIntInf: intInf -> word8 = sextdFromIntInfToWord8
val sextdToIntInf: word8 -> intInf = sextdFromWord8ToIntInf
val castFromIntInf: intInf -> word8 = castFromIntInfToWord8
val castToIntInf: word8 -> intInf = castFromWord8ToIntInf
val zchckFromIntInf: intInf -> word8 = zchckFromIntInfToWord8
val zchckToIntInf: word8 -> intInf = zchckFromWord8ToIntInf
val schckFromIntInf: intInf -> word8 = schckFromIntInfToWord8
val schckToIntInf: word8 -> intInf = schckFromWord8ToIntInf
val zextdFromIntInf: intInf -> word16 = zextdFromIntInfToWord16
val zextdToIntInf: word16 -> intInf = zextdFromWord16ToIntInf
val sextdFromIntInf: intInf -> word16 = sextdFromIntInfToWord16
val sextdToIntInf: word16 -> intInf = sextdFromWord16ToIntInf
val castFromIntInf: intInf -> word16 = castFromIntInfToWord16
val castToIntInf: word16 -> intInf = castFromWord16ToIntInf
val zchckFromIntInf: intInf -> word16 = zchckFromIntInfToWord16
val zchckToIntInf: word16 -> intInf = zchckFromWord16ToIntInf
val schckFromIntInf: intInf -> word16 = schckFromIntInfToWord16
val schckToIntInf: word16 -> intInf = schckFromWord16ToIntInf
val zextdFromIntInf: intInf -> word32 = zextdFromIntInfToWord32
val zextdToIntInf: word32 -> intInf = zextdFromWord32ToIntInf
val sextdFromIntInf: intInf -> word32 = sextdFromIntInfToWord32
val sextdToIntInf: word32 -> intInf = sextdFromWord32ToIntInf
val castFromIntInf: intInf -> word32 = castFromIntInfToWord32
val castToIntInf: word32 -> intInf = castFromWord32ToIntInf
val zchckFromIntInf: intInf -> word32 = zchckFromIntInfToWord32
val zchckToIntInf: word32 -> intInf = zchckFromWord32ToIntInf
val schckFromIntInf: intInf -> word32 = schckFromIntInfToWord32
val schckToIntInf: word32 -> intInf = schckFromWord32ToIntInf
val zextdFromIntInf: intInf -> word64 = zextdFromIntInfToWord64
val zextdToIntInf: word64 -> intInf = zextdFromWord64ToIntInf
val sextdFromIntInf: intInf -> word64 = sextdFromIntInfToWord64
val sextdToIntInf: word64 -> intInf = sextdFromWord64ToIntInf
val castFromIntInf: intInf -> word64 = castFromIntInfToWord64
val castToIntInf: word64 -> intInf = castFromWord64ToIntInf
val zchckFromIntInf: intInf -> word64 = zchckFromIntInfToWord64
val zchckToIntInf: word64 -> intInf = zchckFromWord64ToIntInf
val schckFromIntInf: intInf -> word64 = schckFromIntInfToWord64
val schckToIntInf: word64 -> intInf = schckFromWord64ToIntInf
val zextdToIntInf_0: intInf -> intInf = zextdToIntInf (intInf)
val zextdFromIntInf_0: intInf -> intInf = zextdFromIntInf (intInf)
val zchckToIntInf_0: intInf -> intInf = zchckToIntInf (intInf)
val zchckFromIntInf_0: intInf -> intInf = zchckFromIntInf (intInf)
val sextdToIntInf_0: intInf -> intInf = sextdToIntInf (intInf)
val sextdFromIntInf_0: intInf -> intInf = sextdFromIntInf (intInf)
val schckToIntInf_0: intInf -> intInf = schckToIntInf (intInf)
val schckFromIntInf_0: intInf -> intInf = schckFromIntInf (intInf)
val castToIntInf_0: intInf -> intInf = castToIntInf (intInf)
val castFromIntInf_0: intInf -> intInf = castFromIntInf (intInf)
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt64: int64 -> int8 = zextdFromInt64
val fIntInf: intInf -> int8 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt64: int8 -> int64 = zextdToInt64
val fIntInf: int8 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt64: int64 -> int8 = sextdFromInt64
val fIntInf: intInf -> int8 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt64: int8 -> int64 = sextdToInt64
val fIntInf: int8 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt64: int64 -> int8 = castFromInt64
val fIntInf: intInf -> int8 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt64: int8 -> int64 = castToInt64
val fIntInf: int8 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt64: int64 -> int8 = zchckFromInt64
val fIntInf: intInf -> int8 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt64: int8 -> int64 = zchckToInt64
val fIntInf: int8 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt64: int64 -> int8 = schckFromInt64
val fIntInf: intInf -> int8 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt64: int8 -> int64 = schckToInt64
val fIntInf: int8 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt32: int32 -> int8 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt32: int8 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt32: int32 -> int8 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt32: int8 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt32: int32 -> int8 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt32: int8 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt32: int32 -> int8 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt32: int8 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt32: int32 -> int8 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt32: int8 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int8 = zextdFromInt8
val fInt16: int16 -> int8 = zextdFromInt16
val fInt32: int32 -> int8 = zextdFromInt32
val fInt64: int64 -> int8 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zextdToInt8
val fInt16: int8 -> int16 = zextdToInt16
val fInt32: int8 -> int32 = zextdToInt32
val fInt64: int8 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = sextdFromInt8
val fInt16: int16 -> int8 = sextdFromInt16
val fInt32: int32 -> int8 = sextdFromInt32
val fInt64: int64 -> int8 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = sextdToInt8
val fInt16: int8 -> int16 = sextdToInt16
val fInt32: int8 -> int32 = sextdToInt32
val fInt64: int8 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = castFromInt8
val fInt16: int16 -> int8 = castFromInt16
val fInt32: int32 -> int8 = castFromInt32
val fInt64: int64 -> int8 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = castToInt8
val fInt16: int8 -> int16 = castToInt16
val fInt32: int8 -> int32 = castToInt32
val fInt64: int8 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zchckFromInt8
val fInt16: int16 -> int8 = zchckFromInt16
val fInt32: int32 -> int8 = zchckFromInt32
val fInt64: int64 -> int8 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = zchckToInt8
val fInt16: int8 -> int16 = zchckToInt16
val fInt32: int8 -> int32 = zchckToInt32
val fInt64: int8 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = schckFromInt8
val fInt16: int16 -> int8 = schckFromInt16
val fInt32: int32 -> int8 = schckFromInt32
val fInt64: int64 -> int8 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int8 = schckToInt8
val fInt16: int8 -> int16 = schckToInt16
val fInt32: int8 -> int32 = schckToInt32
val fInt64: int8 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord64: word64 -> int8 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord64: int8 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord64: word64 -> int8 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord64: int8 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord64: word64 -> int8 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord64: int8 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord64: word64 -> int8 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord64: int8 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord64: word64 -> int8 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord64: int8 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord32: word32 -> int8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord32: int8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord32: word32 -> int8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord32: int8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord32: word32 -> int8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord32: int8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord32: word32 -> int8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord32: int8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord32: word32 -> int8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord32: int8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zextdFromWord8
val fWord16: word16 -> int8 = zextdFromWord16
val fWord32: word32 -> int8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zextdToWord8
val fWord16: int8 -> word16 = zextdToWord16
val fWord32: int8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = sextdFromWord8
val fWord16: word16 -> int8 = sextdFromWord16
val fWord32: word32 -> int8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = sextdToWord8
val fWord16: int8 -> word16 = sextdToWord16
val fWord32: int8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = castFromWord8
val fWord16: word16 -> int8 = castFromWord16
val fWord32: word32 -> int8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = castToWord8
val fWord16: int8 -> word16 = castToWord16
val fWord32: int8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = zchckFromWord8
val fWord16: word16 -> int8 = zchckFromWord16
val fWord32: word32 -> int8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = zchckToWord8
val fWord16: int8 -> word16 = zchckToWord16
val fWord32: int8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int8 = schckFromWord8
val fWord16: word16 -> int8 = schckFromWord16
val fWord32: word32 -> int8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int8 -> word8 = schckToWord8
val fWord16: int8 -> word16 = schckToWord16
val fWord32: int8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt64: int64 -> int16 = zextdFromInt64
val fIntInf: intInf -> int16 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt64: int16 -> int64 = zextdToInt64
val fIntInf: int16 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt64: int64 -> int16 = sextdFromInt64
val fIntInf: intInf -> int16 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt64: int16 -> int64 = sextdToInt64
val fIntInf: int16 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt64: int64 -> int16 = castFromInt64
val fIntInf: intInf -> int16 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt64: int16 -> int64 = castToInt64
val fIntInf: int16 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt64: int64 -> int16 = zchckFromInt64
val fIntInf: intInf -> int16 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt64: int16 -> int64 = zchckToInt64
val fIntInf: int16 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt64: int64 -> int16 = schckFromInt64
val fIntInf: intInf -> int16 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt64: int16 -> int64 = schckToInt64
val fIntInf: int16 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt32: int32 -> int16 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt32: int16 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt32: int32 -> int16 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt32: int16 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt32: int32 -> int16 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt32: int16 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt32: int32 -> int16 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt32: int16 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt32: int32 -> int16 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt32: int16 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int16 = zextdFromInt8
val fInt16: int16 -> int16 = zextdFromInt16
val fInt32: int32 -> int16 = zextdFromInt32
val fInt64: int64 -> int16 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = zextdToInt8
val fInt16: int16 -> int16 = zextdToInt16
val fInt32: int16 -> int32 = zextdToInt32
val fInt64: int16 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = sextdFromInt8
val fInt16: int16 -> int16 = sextdFromInt16
val fInt32: int32 -> int16 = sextdFromInt32
val fInt64: int64 -> int16 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = sextdToInt8
val fInt16: int16 -> int16 = sextdToInt16
val fInt32: int16 -> int32 = sextdToInt32
val fInt64: int16 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = castFromInt8
val fInt16: int16 -> int16 = castFromInt16
val fInt32: int32 -> int16 = castFromInt32
val fInt64: int64 -> int16 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = castToInt8
val fInt16: int16 -> int16 = castToInt16
val fInt32: int16 -> int32 = castToInt32
val fInt64: int16 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = zchckFromInt8
val fInt16: int16 -> int16 = zchckFromInt16
val fInt32: int32 -> int16 = zchckFromInt32
val fInt64: int64 -> int16 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = zchckToInt8
val fInt16: int16 -> int16 = zchckToInt16
val fInt32: int16 -> int32 = zchckToInt32
val fInt64: int16 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int16 = schckFromInt8
val fInt16: int16 -> int16 = schckFromInt16
val fInt32: int32 -> int16 = schckFromInt32
val fInt64: int64 -> int16 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int16 -> int8 = schckToInt8
val fInt16: int16 -> int16 = schckToInt16
val fInt32: int16 -> int32 = schckToInt32
val fInt64: int16 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord64: word64 -> int16 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord64: int16 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord64: word64 -> int16 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord64: int16 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord64: word64 -> int16 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord64: int16 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord64: word64 -> int16 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord64: int16 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord64: word64 -> int16 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord64: int16 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord32: word32 -> int16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord32: int16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord32: word32 -> int16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord32: int16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord32: word32 -> int16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord32: int16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord32: word32 -> int16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord32: int16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord32: word32 -> int16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord32: int16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zextdFromWord8
val fWord16: word16 -> int16 = zextdFromWord16
val fWord32: word32 -> int16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zextdToWord8
val fWord16: int16 -> word16 = zextdToWord16
val fWord32: int16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = sextdFromWord8
val fWord16: word16 -> int16 = sextdFromWord16
val fWord32: word32 -> int16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = sextdToWord8
val fWord16: int16 -> word16 = sextdToWord16
val fWord32: int16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = castFromWord8
val fWord16: word16 -> int16 = castFromWord16
val fWord32: word32 -> int16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = castToWord8
val fWord16: int16 -> word16 = castToWord16
val fWord32: int16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = zchckFromWord8
val fWord16: word16 -> int16 = zchckFromWord16
val fWord32: word32 -> int16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = zchckToWord8
val fWord16: int16 -> word16 = zchckToWord16
val fWord32: int16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int16 = schckFromWord8
val fWord16: word16 -> int16 = schckFromWord16
val fWord32: word32 -> int16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int16 -> word8 = schckToWord8
val fWord16: int16 -> word16 = schckToWord16
val fWord32: int16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt64: int64 -> int32 = zextdFromInt64
val fIntInf: intInf -> int32 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val fInt64: int32 -> int64 = zextdToInt64
val fIntInf: int32 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zextdToInt: int32 -> int32 = f
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt64: int64 -> int32 = sextdFromInt64
val fIntInf: intInf -> int32 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt64: int32 -> int64 = sextdToInt64
val fIntInf: int32 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt64: int64 -> int32 = castFromInt64
val fIntInf: intInf -> int32 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt64: int32 -> int64 = castToInt64
val fIntInf: int32 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt64: int64 -> int32 = zchckFromInt64
val fIntInf: intInf -> int32 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt64: int32 -> int64 = zchckToInt64
val fIntInf: int32 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val fInt64: int64 -> int32 = schckFromInt64
val fIntInf: intInf -> int32 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckFromInt: int32 -> int32 = f
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val fInt64: int32 -> int64 = schckToInt64
val fIntInf: int32 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckToInt: int32 -> int32 = f
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt32: int32 -> int32 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt32: int32 -> int32 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt32: int32 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt32: int32 -> int32 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt32: int32 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt32: int32 -> int32 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt32: int32 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int32 = zextdFromInt8
val fInt16: int16 -> int32 = zextdFromInt16
val fInt32: int32 -> int32 = zextdFromInt32
val fInt64: int64 -> int32 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = zextdToInt8
val fInt16: int32 -> int16 = zextdToInt16
val fInt32: int32 -> int32 = zextdToInt32
val fInt64: int32 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = sextdFromInt8
val fInt16: int16 -> int32 = sextdFromInt16
val fInt32: int32 -> int32 = sextdFromInt32
val fInt64: int64 -> int32 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = sextdToInt8
val fInt16: int32 -> int16 = sextdToInt16
val fInt32: int32 -> int32 = sextdToInt32
val fInt64: int32 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = castFromInt8
val fInt16: int16 -> int32 = castFromInt16
val fInt32: int32 -> int32 = castFromInt32
val fInt64: int64 -> int32 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = castToInt8
val fInt16: int32 -> int16 = castToInt16
val fInt32: int32 -> int32 = castToInt32
val fInt64: int32 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = zchckFromInt8
val fInt16: int16 -> int32 = zchckFromInt16
val fInt32: int32 -> int32 = zchckFromInt32
val fInt64: int64 -> int32 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = zchckToInt8
val fInt16: int32 -> int16 = zchckToInt16
val fInt32: int32 -> int32 = zchckToInt32
val fInt64: int32 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int32 = schckFromInt8
val fInt16: int16 -> int32 = schckFromInt16
val fInt32: int32 -> int32 = schckFromInt32
val fInt64: int64 -> int32 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int32 -> int8 = schckToInt8
val fInt16: int32 -> int16 = schckToInt16
val fInt32: int32 -> int32 = schckToInt32
val fInt64: int32 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord64: word64 -> int32 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord64: int32 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord64: word64 -> int32 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord64: int32 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord64: word64 -> int32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord64: int32 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord64: word64 -> int32 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord64: int32 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord64: word64 -> int32 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord64: int32 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord32: word32 -> int32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord32: int32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord32: word32 -> int32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord32: int32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord32: word32 -> int32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord32: int32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord32: word32 -> int32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord32: int32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord32: word32 -> int32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord32: int32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zextdFromWord8
val fWord16: word16 -> int32 = zextdFromWord16
val fWord32: word32 -> int32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zextdToWord8
val fWord16: int32 -> word16 = zextdToWord16
val fWord32: int32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = sextdFromWord8
val fWord16: word16 -> int32 = sextdFromWord16
val fWord32: word32 -> int32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = sextdToWord8
val fWord16: int32 -> word16 = sextdToWord16
val fWord32: int32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = castFromWord8
val fWord16: word16 -> int32 = castFromWord16
val fWord32: word32 -> int32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = castToWord8
val fWord16: int32 -> word16 = castToWord16
val fWord32: int32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = zchckFromWord8
val fWord16: word16 -> int32 = zchckFromWord16
val fWord32: word32 -> int32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = zchckToWord8
val fWord16: int32 -> word16 = zchckToWord16
val fWord32: int32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int32 = schckFromWord8
val fWord16: word16 -> int32 = schckFromWord16
val fWord32: word32 -> int32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int32 -> word8 = schckToWord8
val fWord16: int32 -> word16 = schckToWord16
val fWord32: int32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt64: int64 -> int64 = zextdFromInt64
val fIntInf: intInf -> int64 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt64: int64 -> int64 = zextdToInt64
val fIntInf: int64 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt64: int64 -> int64 = sextdFromInt64
val fIntInf: intInf -> int64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt64: int64 -> int64 = sextdToInt64
val fIntInf: int64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt64: int64 -> int64 = castFromInt64
val fIntInf: intInf -> int64 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt64: int64 -> int64 = castToInt64
val fIntInf: int64 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt64: int64 -> int64 = zchckFromInt64
val fIntInf: intInf -> int64 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt64: int64 -> int64 = zchckToInt64
val fIntInf: int64 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val fIntInf: intInf -> int64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val schckFromInt: int32 -> int64 = f
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val schckToInt: int64 -> int32 = f
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt32: int32 -> int64 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt32: int64 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt32: int32 -> int64 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt32: int64 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt32: int32 -> int64 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt32: int64 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> int64 = zextdFromInt8
val fInt16: int16 -> int64 = zextdFromInt16
val fInt32: int32 -> int64 = zextdFromInt32
val fInt64: int64 -> int64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = zextdToInt8
val fInt16: int64 -> int16 = zextdToInt16
val fInt32: int64 -> int32 = zextdToInt32
val fInt64: int64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val fInt64: int64 -> int64 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val fInt64: int64 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = castFromInt8
val fInt16: int16 -> int64 = castFromInt16
val fInt32: int32 -> int64 = castFromInt32
val fInt64: int64 -> int64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = castToInt8
val fInt16: int64 -> int16 = castToInt16
val fInt32: int64 -> int32 = castToInt32
val fInt64: int64 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = zchckFromInt8
val fInt16: int16 -> int64 = zchckFromInt16
val fInt32: int32 -> int64 = zchckFromInt32
val fInt64: int64 -> int64 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = zchckToInt8
val fInt16: int64 -> int16 = zchckToInt16
val fInt32: int64 -> int32 = zchckToInt32
val fInt64: int64 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord64: word64 -> int64 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord64: int64 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord64: word64 -> int64 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord64: int64 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord64: word64 -> int64 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord64: int64 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord64: word64 -> int64 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord64: int64 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord64: word64 -> int64 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord64: int64 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord32: word32 -> int64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord32: int64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord32: word32 -> int64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord32: int64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord32: word32 -> int64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord32: int64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord32: word32 -> int64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord32: int64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord32: word32 -> int64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord32: int64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zextdFromWord8
val fWord16: word16 -> int64 = zextdFromWord16
val fWord32: word32 -> int64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zextdToWord8
val fWord16: int64 -> word16 = zextdToWord16
val fWord32: int64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = sextdFromWord8
val fWord16: word16 -> int64 = sextdFromWord16
val fWord32: word32 -> int64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = sextdToWord8
val fWord16: int64 -> word16 = sextdToWord16
val fWord32: int64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = castFromWord8
val fWord16: word16 -> int64 = castFromWord16
val fWord32: word32 -> int64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = castToWord8
val fWord16: int64 -> word16 = castToWord16
val fWord32: int64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = zchckFromWord8
val fWord16: word16 -> int64 = zchckFromWord16
val fWord32: word32 -> int64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = zchckToWord8
val fWord16: int64 -> word16 = zchckToWord16
val fWord32: int64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> int64 = schckFromWord8
val fWord16: word16 -> int64 = schckFromWord16
val fWord32: word32 -> int64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: int64 -> word8 = schckToWord8
val fWord16: int64 -> word16 = schckToWord16
val fWord32: int64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt64: int64 -> intInf = zextdFromInt64
val fIntInf: intInf -> intInf = zextdFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt64: intInf -> int64 = zextdToInt64
val fIntInf: intInf -> intInf = zextdToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt64: int64 -> intInf = sextdFromInt64
val fIntInf: intInf -> intInf = sextdFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt64: intInf -> int64 = sextdToInt64
val fIntInf: intInf -> intInf = sextdToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt64: int64 -> intInf = castFromInt64
val fIntInf: intInf -> intInf = castFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt64: intInf -> int64 = castToInt64
val fIntInf: intInf -> intInf = castToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt64: int64 -> intInf = zchckFromInt64
val fIntInf: intInf -> intInf = zchckFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt64: intInf -> int64 = zchckToInt64
val fIntInf: intInf -> intInf = zchckToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt64: int64 -> intInf = schckFromInt64
val fIntInf: intInf -> intInf = schckFromIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt64: intInf -> int64 = schckToInt64
val fIntInf: intInf -> intInf = schckToIntInf_0
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt32: int32 -> intInf = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt32: intInf -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt32: intInf -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt32: int32 -> intInf = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt32: intInf -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt32: int32 -> intInf = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt32: intInf -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt32: int32 -> intInf = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt32: intInf -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> intInf = zextdFromInt8
val fInt16: int16 -> intInf = zextdFromInt16
val fInt32: int32 -> intInf = zextdFromInt32
val fInt64: int64 -> intInf = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = zextdToInt8
val fInt16: intInf -> int16 = zextdToInt16
val fInt32: intInf -> int32 = zextdToInt32
val fInt64: intInf -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = sextdFromInt8
val fInt16: int16 -> intInf = sextdFromInt16
val fInt32: int32 -> intInf = sextdFromInt32
val fInt64: int64 -> intInf = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = sextdToInt8
val fInt16: intInf -> int16 = sextdToInt16
val fInt32: intInf -> int32 = sextdToInt32
val fInt64: intInf -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = castFromInt8
val fInt16: int16 -> intInf = castFromInt16
val fInt32: int32 -> intInf = castFromInt32
val fInt64: int64 -> intInf = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = castToInt8
val fInt16: intInf -> int16 = castToInt16
val fInt32: intInf -> int32 = castToInt32
val fInt64: intInf -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = zchckFromInt8
val fInt16: int16 -> intInf = zchckFromInt16
val fInt32: int32 -> intInf = zchckFromInt32
val fInt64: int64 -> intInf = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = zchckToInt8
val fInt16: intInf -> int16 = zchckToInt16
val fInt32: intInf -> int32 = zchckToInt32
val fInt64: intInf -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> intInf = schckFromInt8
val fInt16: int16 -> intInf = schckFromInt16
val fInt32: int32 -> intInf = schckFromInt32
val fInt64: int64 -> intInf = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: intInf -> int8 = schckToInt8
val fInt16: intInf -> int16 = schckToInt16
val fInt32: intInf -> int32 = schckToInt32
val fInt64: intInf -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord64: word64 -> intInf = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord64: intInf -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord64: word64 -> intInf = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord64: intInf -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord64: word64 -> intInf = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord64: intInf -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord64: word64 -> intInf = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord64: intInf -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord64: word64 -> intInf = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord64: intInf -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord32: word32 -> intInf = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord32: intInf -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord32: word32 -> intInf = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord32: intInf -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord32: word32 -> intInf = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord32: intInf -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord32: word32 -> intInf = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord32: intInf -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord32: word32 -> intInf = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord32: intInf -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zextdFromWord8
val fWord16: word16 -> intInf = zextdFromWord16
val fWord32: word32 -> intInf = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zextdToWord8
val fWord16: intInf -> word16 = zextdToWord16
val fWord32: intInf -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = sextdFromWord8
val fWord16: word16 -> intInf = sextdFromWord16
val fWord32: word32 -> intInf = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = sextdToWord8
val fWord16: intInf -> word16 = sextdToWord16
val fWord32: intInf -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = castFromWord8
val fWord16: word16 -> intInf = castFromWord16
val fWord32: word32 -> intInf = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = castToWord8
val fWord16: intInf -> word16 = castToWord16
val fWord32: intInf -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = zchckFromWord8
val fWord16: word16 -> intInf = zchckFromWord16
val fWord32: word32 -> intInf = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = zchckToWord8
val fWord16: intInf -> word16 = zchckToWord16
val fWord32: intInf -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> intInf = schckFromWord8
val fWord16: word16 -> intInf = schckFromWord16
val fWord32: word32 -> intInf = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: intInf -> word8 = schckToWord8
val fWord16: intInf -> word16 = schckToWord16
val fWord32: intInf -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt64: int64 -> word8 = zextdFromInt64
val fIntInf: intInf -> word8 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt64: word8 -> int64 = zextdToInt64
val fIntInf: word8 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt64: int64 -> word8 = sextdFromInt64
val fIntInf: intInf -> word8 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt64: word8 -> int64 = sextdToInt64
val fIntInf: word8 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt64: int64 -> word8 = castFromInt64
val fIntInf: intInf -> word8 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt64: word8 -> int64 = castToInt64
val fIntInf: word8 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt64: int64 -> word8 = zchckFromInt64
val fIntInf: intInf -> word8 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt64: word8 -> int64 = zchckToInt64
val fIntInf: word8 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt64: int64 -> word8 = schckFromInt64
val fIntInf: intInf -> word8 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt64: word8 -> int64 = schckToInt64
val fIntInf: word8 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt32: int32 -> word8 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt32: word8 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt32: int32 -> word8 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt32: word8 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt32: int32 -> word8 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt32: word8 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt32: int32 -> word8 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt32: word8 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt32: int32 -> word8 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt32: word8 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word8 = zextdFromInt8
val fInt16: int16 -> word8 = zextdFromInt16
val fInt32: int32 -> word8 = zextdFromInt32
val fInt64: int64 -> word8 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = zextdToInt8
val fInt16: word8 -> int16 = zextdToInt16
val fInt32: word8 -> int32 = zextdToInt32
val fInt64: word8 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = sextdFromInt8
val fInt16: int16 -> word8 = sextdFromInt16
val fInt32: int32 -> word8 = sextdFromInt32
val fInt64: int64 -> word8 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = sextdToInt8
val fInt16: word8 -> int16 = sextdToInt16
val fInt32: word8 -> int32 = sextdToInt32
val fInt64: word8 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = castFromInt8
val fInt16: int16 -> word8 = castFromInt16
val fInt32: int32 -> word8 = castFromInt32
val fInt64: int64 -> word8 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = castToInt8
val fInt16: word8 -> int16 = castToInt16
val fInt32: word8 -> int32 = castToInt32
val fInt64: word8 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = zchckFromInt8
val fInt16: int16 -> word8 = zchckFromInt16
val fInt32: int32 -> word8 = zchckFromInt32
val fInt64: int64 -> word8 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = zchckToInt8
val fInt16: word8 -> int16 = zchckToInt16
val fInt32: word8 -> int32 = zchckToInt32
val fInt64: word8 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word8 = schckFromInt8
val fInt16: int16 -> word8 = schckFromInt16
val fInt32: int32 -> word8 = schckFromInt32
val fInt64: int64 -> word8 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word8 -> int8 = schckToInt8
val fInt16: word8 -> int16 = schckToInt16
val fInt32: word8 -> int32 = schckToInt32
val fInt64: word8 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord64: word64 -> word8 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord64: word8 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord64: word64 -> word8 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord64: word8 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord64: word64 -> word8 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord64: word8 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord64: word64 -> word8 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord64: word8 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord64: word64 -> word8 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord64: word8 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord32: word32 -> word8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord32: word8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord32: word32 -> word8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord32: word8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord32: word32 -> word8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord32: word8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord32: word32 -> word8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord32: word8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord32: word32 -> word8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord32: word8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdFromWord8
val fWord16: word16 -> word8 = zextdFromWord16
val fWord32: word32 -> word8 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zextdToWord8
val fWord16: word8 -> word16 = zextdToWord16
val fWord32: word8 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdFromWord8
val fWord16: word16 -> word8 = sextdFromWord16
val fWord32: word32 -> word8 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = sextdToWord8
val fWord16: word8 -> word16 = sextdToWord16
val fWord32: word8 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castFromWord8
val fWord16: word16 -> word8 = castFromWord16
val fWord32: word32 -> word8 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = castToWord8
val fWord16: word8 -> word16 = castToWord16
val fWord32: word8 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckFromWord8
val fWord16: word16 -> word8 = zchckFromWord16
val fWord32: word32 -> word8 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = zchckToWord8
val fWord16: word8 -> word16 = zchckToWord16
val fWord32: word8 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckFromWord8
val fWord16: word16 -> word8 = schckFromWord16
val fWord32: word32 -> word8 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word8 = schckToWord8
val fWord16: word8 -> word16 = schckToWord16
val fWord32: word8 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt64: int64 -> word16 = zextdFromInt64
val fIntInf: intInf -> word16 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt64: word16 -> int64 = zextdToInt64
val fIntInf: word16 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt64: int64 -> word16 = sextdFromInt64
val fIntInf: intInf -> word16 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt64: word16 -> int64 = sextdToInt64
val fIntInf: word16 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt64: int64 -> word16 = castFromInt64
val fIntInf: intInf -> word16 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt64: word16 -> int64 = castToInt64
val fIntInf: word16 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt64: int64 -> word16 = zchckFromInt64
val fIntInf: intInf -> word16 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt64: word16 -> int64 = zchckToInt64
val fIntInf: word16 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt64: int64 -> word16 = schckFromInt64
val fIntInf: intInf -> word16 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt64: word16 -> int64 = schckToInt64
val fIntInf: word16 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt32: int32 -> word16 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt32: word16 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt32: int32 -> word16 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt32: word16 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt32: int32 -> word16 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt32: word16 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt32: int32 -> word16 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt32: word16 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt32: int32 -> word16 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt32: word16 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word16 = zextdFromInt8
val fInt16: int16 -> word16 = zextdFromInt16
val fInt32: int32 -> word16 = zextdFromInt32
val fInt64: int64 -> word16 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = zextdToInt8
val fInt16: word16 -> int16 = zextdToInt16
val fInt32: word16 -> int32 = zextdToInt32
val fInt64: word16 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = sextdFromInt8
val fInt16: int16 -> word16 = sextdFromInt16
val fInt32: int32 -> word16 = sextdFromInt32
val fInt64: int64 -> word16 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = sextdToInt8
val fInt16: word16 -> int16 = sextdToInt16
val fInt32: word16 -> int32 = sextdToInt32
val fInt64: word16 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = castFromInt8
val fInt16: int16 -> word16 = castFromInt16
val fInt32: int32 -> word16 = castFromInt32
val fInt64: int64 -> word16 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = castToInt8
val fInt16: word16 -> int16 = castToInt16
val fInt32: word16 -> int32 = castToInt32
val fInt64: word16 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = zchckFromInt8
val fInt16: int16 -> word16 = zchckFromInt16
val fInt32: int32 -> word16 = zchckFromInt32
val fInt64: int64 -> word16 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = zchckToInt8
val fInt16: word16 -> int16 = zchckToInt16
val fInt32: word16 -> int32 = zchckToInt32
val fInt64: word16 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word16 = schckFromInt8
val fInt16: int16 -> word16 = schckFromInt16
val fInt32: int32 -> word16 = schckFromInt32
val fInt64: int64 -> word16 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word16 -> int8 = schckToInt8
val fInt16: word16 -> int16 = schckToInt16
val fInt32: word16 -> int32 = schckToInt32
val fInt64: word16 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord64: word64 -> word16 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord64: word16 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord64: word64 -> word16 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord64: word16 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord64: word64 -> word16 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord64: word16 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord64: word64 -> word16 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord64: word16 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord64: word64 -> word16 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord64: word16 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord32: word32 -> word16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord32: word16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord32: word32 -> word16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord32: word16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord32: word32 -> word16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord32: word16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord32: word32 -> word16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord32: word16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord32: word32 -> word16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord32: word16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zextdFromWord8
val fWord16: word16 -> word16 = zextdFromWord16
val fWord32: word32 -> word16 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zextdToWord8
val fWord16: word16 -> word16 = zextdToWord16
val fWord32: word16 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = sextdFromWord8
val fWord16: word16 -> word16 = sextdFromWord16
val fWord32: word32 -> word16 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = sextdToWord8
val fWord16: word16 -> word16 = sextdToWord16
val fWord32: word16 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = castFromWord8
val fWord16: word16 -> word16 = castFromWord16
val fWord32: word32 -> word16 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = castToWord8
val fWord16: word16 -> word16 = castToWord16
val fWord32: word16 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = zchckFromWord8
val fWord16: word16 -> word16 = zchckFromWord16
val fWord32: word32 -> word16 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = zchckToWord8
val fWord16: word16 -> word16 = zchckToWord16
val fWord32: word16 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word16 = schckFromWord8
val fWord16: word16 -> word16 = schckFromWord16
val fWord32: word32 -> word16 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word16 -> word8 = schckToWord8
val fWord16: word16 -> word16 = schckToWord16
val fWord32: word16 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt64: int64 -> word32 = zextdFromInt64
val fIntInf: intInf -> word32 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt64: word32 -> int64 = zextdToInt64
val fIntInf: word32 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt64: int64 -> word32 = sextdFromInt64
val fIntInf: intInf -> word32 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt64: word32 -> int64 = sextdToInt64
val fIntInf: word32 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt64: int64 -> word32 = castFromInt64
val fIntInf: intInf -> word32 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt64: word32 -> int64 = castToInt64
val fIntInf: word32 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt64: int64 -> word32 = zchckFromInt64
val fIntInf: intInf -> word32 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val fInt64: word32 -> int64 = zchckToInt64
val fIntInf: word32 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val f: word32 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val zchckToInt: word32 -> int32 = f
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt64: int64 -> word32 = schckFromInt64
val fIntInf: intInf -> word32 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt64: word32 -> int64 = schckToInt64
val fIntInf: word32 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt32: int32 -> word32 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt32: word32 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt32: int32 -> word32 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt32: word32 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt32: int32 -> word32 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt32: word32 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt32: int32 -> word32 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt32: int32 -> word32 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt32: word32 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word32 = zextdFromInt8
val fInt16: int16 -> word32 = zextdFromInt16
val fInt32: int32 -> word32 = zextdFromInt32
val fInt64: int64 -> word32 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = zextdToInt8
val fInt16: word32 -> int16 = zextdToInt16
val fInt32: word32 -> int32 = zextdToInt32
val fInt64: word32 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = sextdFromInt8
val fInt16: int16 -> word32 = sextdFromInt16
val fInt32: int32 -> word32 = sextdFromInt32
val fInt64: int64 -> word32 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = sextdToInt8
val fInt16: word32 -> int16 = sextdToInt16
val fInt32: word32 -> int32 = sextdToInt32
val fInt64: word32 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = castFromInt8
val fInt16: int16 -> word32 = castFromInt16
val fInt32: int32 -> word32 = castFromInt32
val fInt64: int64 -> word32 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = castToInt8
val fInt16: word32 -> int16 = castToInt16
val fInt32: word32 -> int32 = castToInt32
val fInt64: word32 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = zchckFromInt8
val fInt16: int16 -> word32 = zchckFromInt16
val fInt32: int32 -> word32 = zchckFromInt32
val fInt64: int64 -> word32 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = zchckToInt8
val fInt16: word32 -> int16 = zchckToInt16
val fInt32: word32 -> int32 = zchckToInt32
val fInt64: word32 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word32 = schckFromInt8
val fInt16: int16 -> word32 = schckFromInt16
val fInt32: int32 -> word32 = schckFromInt32
val fInt64: int64 -> word32 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word32 -> int8 = schckToInt8
val fInt16: word32 -> int16 = schckToInt16
val fInt32: word32 -> int32 = schckToInt32
val fInt64: word32 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord64: word64 -> word32 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord64: word32 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord64: word64 -> word32 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord64: word32 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord64: word64 -> word32 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord64: word32 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord64: word64 -> word32 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord64: word32 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord64: word64 -> word32 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord64: word32 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord32: word32 -> word32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord32: word32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord32: word32 -> word32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord32: word32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord32: word32 -> word32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord32: word32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord32: word32 -> word32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord32: word32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord32: word32 -> word32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord32: word32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zextdFromWord8
val fWord16: word16 -> word32 = zextdFromWord16
val fWord32: word32 -> word32 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zextdToWord8
val fWord16: word32 -> word16 = zextdToWord16
val fWord32: word32 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = sextdFromWord8
val fWord16: word16 -> word32 = sextdFromWord16
val fWord32: word32 -> word32 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = sextdToWord8
val fWord16: word32 -> word16 = sextdToWord16
val fWord32: word32 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = castFromWord8
val fWord16: word16 -> word32 = castFromWord16
val fWord32: word32 -> word32 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = castToWord8
val fWord16: word32 -> word16 = castToWord16
val fWord32: word32 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = zchckFromWord8
val fWord16: word16 -> word32 = zchckFromWord16
val fWord32: word32 -> word32 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = zchckToWord8
val fWord16: word32 -> word16 = zchckToWord16
val fWord32: word32 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word32 = schckFromWord8
val fWord16: word16 -> word32 = schckFromWord16
val fWord32: word32 -> word32 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word32 -> word8 = schckToWord8
val fWord16: word32 -> word16 = schckToWord16
val fWord32: word32 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt64: int64 -> word64 = zextdFromInt64
val fIntInf: intInf -> word64 = zextdFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt64: word64 -> int64 = zextdToInt64
val fIntInf: word64 -> intInf = zextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val fInt64: int64 -> word64 = sextdFromInt64
val fIntInf: intInf -> word64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> word64 = fInt32
val _ = fInt64
val _ = fIntInf
val sextdFromInt: int32 -> word64 = f
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt64: word64 -> int64 = sextdToInt64
val fIntInf: word64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt64: int64 -> word64 = castFromInt64
val fIntInf: intInf -> word64 = castFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt64: word64 -> int64 = castToInt64
val fIntInf: word64 -> intInf = castToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt64: int64 -> word64 = zchckFromInt64
val fIntInf: intInf -> word64 = zchckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt64: word64 -> int64 = zchckToInt64
val fIntInf: word64 -> intInf = zchckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt64: int64 -> word64 = schckFromInt64
val fIntInf: intInf -> word64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt64: word64 -> int64 = schckToInt64
val fIntInf: word64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt32: word64 -> int32 = sextdToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt32: int32 -> word64 = castFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt32: word64 -> int32 = castToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt32: int32 -> word64 = zchckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt32: word64 -> int32 = zchckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt32: int32 -> word64 = schckFromInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt32: word64 -> int32 = schckToInt32
val _ = fInt8
val _ = fInt16
val _ = fInt32
val fInt8: int8 -> word64 = zextdFromInt8
val fInt16: int16 -> word64 = zextdFromInt16
val fInt32: int32 -> word64 = zextdFromInt32
val fInt64: int64 -> word64 = zextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = zextdToInt8
val fInt16: word64 -> int16 = zextdToInt16
val fInt32: word64 -> int32 = zextdToInt32
val fInt64: word64 -> int64 = zextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = sextdFromInt8
val fInt16: int16 -> word64 = sextdFromInt16
val fInt32: int32 -> word64 = sextdFromInt32
val fInt64: int64 -> word64 = sextdFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = sextdToInt8
val fInt16: word64 -> int16 = sextdToInt16
val fInt32: word64 -> int32 = sextdToInt32
val fInt64: word64 -> int64 = sextdToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = castFromInt8
val fInt16: int16 -> word64 = castFromInt16
val fInt32: int32 -> word64 = castFromInt32
val fInt64: int64 -> word64 = castFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = castToInt8
val fInt16: word64 -> int16 = castToInt16
val fInt32: word64 -> int32 = castToInt32
val fInt64: word64 -> int64 = castToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = zchckFromInt8
val fInt16: int16 -> word64 = zchckFromInt16
val fInt32: int32 -> word64 = zchckFromInt32
val fInt64: int64 -> word64 = zchckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = zchckToInt8
val fInt16: word64 -> int16 = zchckToInt16
val fInt32: word64 -> int32 = zchckToInt32
val fInt64: word64 -> int64 = zchckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: int8 -> word64 = schckFromInt8
val fInt16: int16 -> word64 = schckFromInt16
val fInt32: int32 -> word64 = schckFromInt32
val fInt64: int64 -> word64 = schckFromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: word64 -> int8 = schckToInt8
val fInt16: word64 -> int16 = schckToInt16
val fInt32: word64 -> int32 = schckToInt32
val fInt64: word64 -> int64 = schckToInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord64: word64 -> word64 = zextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord64: word64 -> word64 = zextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord64: word64 -> word64 = sextdFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord64: word64 -> word64 = sextdToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord64: word64 -> word64 = castFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord64: word64 -> word64 = castToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord64: word64 -> word64 = zchckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord64: word64 -> word64 = zchckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord64: word64 -> word64 = schckFromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord64: word64 -> word64 = schckToWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord32: word32 -> word64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord32: word64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord32: word32 -> word64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord32: word64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord32: word32 -> word64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord32: word64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord32: word32 -> word64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord32: word64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord32: word32 -> word64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord32: word64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zextdFromWord8
val fWord16: word16 -> word64 = zextdFromWord16
val fWord32: word32 -> word64 = zextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zextdToWord8
val fWord16: word64 -> word16 = zextdToWord16
val fWord32: word64 -> word32 = zextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = sextdFromWord8
val fWord16: word16 -> word64 = sextdFromWord16
val fWord32: word32 -> word64 = sextdFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = sextdToWord8
val fWord16: word64 -> word16 = sextdToWord16
val fWord32: word64 -> word32 = sextdToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = castFromWord8
val fWord16: word16 -> word64 = castFromWord16
val fWord32: word32 -> word64 = castFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = castToWord8
val fWord16: word64 -> word16 = castToWord16
val fWord32: word64 -> word32 = castToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = zchckFromWord8
val fWord16: word16 -> word64 = zchckFromWord16
val fWord32: word32 -> word64 = zchckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = zchckToWord8
val fWord16: word64 -> word16 = zchckToWord16
val fWord32: word64 -> word32 = zchckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 -> word64 = schckFromWord8
val fWord16: word16 -> word64 = schckFromWord16
val fWord32: word32 -> word64 = schckFromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word64 -> word8 = schckToWord8
val fWord16: word64 -> word16 = schckToWord16
val fWord32: word64 -> word32 = schckToWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
exception Chr
exception Fail of string
exception Span
val 'a_1659 !: 'a_1659 ref -> 'a_1659 = deref ('a_1659)
val 'a_1660 :=: 'a_1660 ref * 'a_1660 -> unit = assign ('a_1660)
val rec ('a_1663, 'a_1662, 'a_1661)
   o: ('a_1662 -> 'a_1661) * ('a_1663 -> 'a_1662) -> 'a_1663 -> 'a_1661 = 
      (fn x_988: ('a_1662 -> 'a_1661) * ('a_1663 -> 'a_1662) =>
       (fn x_989: 'a_1663 =>
	case (x_988, x_989) of
	  ((f: 'a_1662 -> 'a_1661, g: 'a_1663 -> 'a_1662), x: 'a_1663) =>
	  (f (g x))))
val exnName: exn -> string = name
val messagers: (exn -> string Primitive.Option.t) list ref =
   (ref[(exn -> string Primitive.Option.t) list] [])
val addExnMessager: (exn -> string Primitive.Option.t) -> unit =
   (fn x_990: exn -> string Primitive.Option.t =>
    case x_990 of
      f: exn -> string Primitive.Option.t =>
      (:= ((exn -> string Primitive.Option.t) list) (messagers,
						     (::[exn
							 -> string Primitive.Option.t] (f,
											(! ((exn
											     -> string Primitive.Option.t) list) messagers))))))
val rec
   exnMessage: exn -> string = 
      (fn x_991: exn =>
       case x_991 of
	 e: exn =>
	 let val rec
		find: (exn -> string Primitive.Option.t) list -> string = 
		   (fn x_992: (exn -> string Primitive.Option.t) list =>
		    case x_992 of
		      [] => (exnName e)
		    | ::[exn -> string Primitive.Option.t] (m: exn
							       -> string Primitive.Option.t,
							    ms: (exn
								 -> string Primitive.Option.t) list) =>
		      case (m e) of
			NONE[string] => (find ms) | SOME[string] s: string => s)
	 in
	    (find (! ((exn -> string Primitive.Option.t) list) messagers))
	 end)
val ('a, 'c, 'b) o_0: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = o ('a, 'b, 'c)
val 'a :=_0: 'a ref * 'a -> unit = := ('a)
val 'a !_0: 'a ref -> 'a = ! ('a)
val ('a, 'c, 'b) o_1: ('b -> 'c) * ('a -> 'b) -> 'a -> 'c = o_0 ('a, 'c, 'b)
val 'a :=_1: 'a ref * 'a -> unit = :=_0 ('a)
val 'a !_1: 'a ref -> 'a = !_0 ('a)
datatype 'a One.t = T of {more: unit -> 'a, static: 'a, staticIsInUse: bool ref}
val rec 'a_1666
   make: (unit -> 'a_1666) -> 'a_1666 One.t = 
      (fn x_993: unit -> 'a_1666 =>
       case x_993 of
	 (f: unit -> 'a_1666) =>
	 (T['a_1666] {more = f,
		      static = (f ()),
		      staticIsInUse = (ref[bool] false)}))
val rec ('a_1668, 'a_1667)
   use: 'a_1668 One.t * ('a_1668 -> 'a_1667) -> 'a_1667 = 
      (fn x_994: 'a_1668 One.t * ('a_1668 -> 'a_1667) =>
       case x_994 of
	 ((T['a_1668] {more = more: unit -> 'a_1668,
		       static = static: 'a_1668,
		       staticIsInUse = staticIsInUse: bool ref},
	   f: 'a_1668 -> 'a_1667)) =>
	 let val () = (atomicBegin ())
	     val b: bool = (!_1 (bool) staticIsInUse)
	     val d: 'a_1668 =
		case b of
		  true => (atomicEnd ()) ;(more ())
		| false =>
		  (:=_1 (bool) (staticIsInUse, true)) ;(atomicEnd ()) ;static
	 in
	    (wind_0 ('a_1667) ((fn x_996: unit =>
				case x_996 of
				  () => (f d)),
			       (fn x_995: unit =>
				case x_995 of
				  () =>
				  case b of
				    true => ()
				  | false =>
				    (:=_1 (bool) (staticIsInUse, false)))))
	 end)
val ('b, 'a) use_0: 'a One.t * ('a -> 'b) -> 'b = use ('a, 'b)
val 'a make_0: (unit -> 'a) -> 'a One.t = make ('a)
exception Option
val rec ('a_1673, 'a_1672)
   map: ('a_1673 -> 'a_1672)
	-> 'a_1673 Primitive.Option.t -> 'a_1672 Primitive.Option.t = 
      (fn x_997: 'a_1673 -> 'a_1672 =>
       case x_997 of
	 (f: 'a_1673 -> 'a_1672) =>
	 (fn x_998: 'a_1673 Primitive.Option.t =>
	  case x_998 of
	    NONE['a_1673] => NONE['a_1672]
	  | SOME['a_1673] a: 'a_1673 => (SOME['a_1672] (f a))))
val 'a_1688 valOf: 'a_1688 Primitive.Option.t -> 'a_1688 =
   (fn x_999: 'a_1688 Primitive.Option.t =>
    case x_999 of
      NONE['a_1688] => raise Option | SOME['a_1688] v: 'a_1688 => v)
val 'a valOf_0: 'a Primitive.Option.t -> 'a = valOf ('a)
val ('b, 'a) map_0: ('a -> 'b) -> 'a Primitive.Option.t -> 'b Primitive.Option.t =
   map ('a, 'b)
val 'a valOf_1: 'a Primitive.Option.t -> 'a = valOf_0 ('a)
exception Empty
val rec ('a_1699, 'a_1698)
   foldl: ('a_1699 * 'a_1698 -> 'a_1698) -> 'a_1698 -> 'a_1699 list -> 'a_1698 = 
      (fn x_1000: 'a_1699 * 'a_1698 -> 'a_1698 =>
       (fn x_1001: 'a_1698 =>
	(fn x_1002: 'a_1699 list =>
	 case (x_1000, x_1001, x_1002) of
	   (f: 'a_1699 * 'a_1698 -> 'a_1698, b: 'a_1698, l: 'a_1699 list) =>
	   let val rec
		  loop: 'a_1699 list * 'a_1698 -> 'a_1698 = 
		     (fn x_1003: 'a_1699 list * 'a_1698 =>
		      case x_1003 of
			((l: 'a_1699 list, b: 'a_1698)) =>
			case l of
			  [] => b
			| ::['a_1699] (x: 'a_1699, l: 'a_1699 list) =>
			  (loop (l, (f (x, b)))))
	   in
	      (loop (l, b))
	   end)))
val rec 'a_1700
   length: 'a_1700 list -> int32 = 
      (fn x_1004: 'a_1700 list =>
       case x_1004 of
	 (l: 'a_1700 list) =>
	 (((foldl ('a_1700, int32) (fn x_1005: 'a_1700 * int32 =>
				    case x_1005 of
				      (_, n: int32) => (+? (n, 0x1)))) 0x0) l))
val rec 'a_1701
   appendRev: 'a_1701 list * 'a_1701 list -> 'a_1701 list = 
      (fn x_1006: 'a_1701 list * 'a_1701 list =>
       case x_1006 of
	 ((l1: 'a_1701 list, l2: 'a_1701 list)) =>
	 (((foldl ('a_1701, 'a_1701 list) ::['a_1701]) l2) l1))
val rec 'a_1703
   rev: 'a_1703 list -> 'a_1703 list = 
      (fn x_1007: 'a_1703 list =>
       case x_1007 of
	 (l: 'a_1703 list) => (appendRev ('a_1703) (l, [])))
val rec 'a_1708
   app: ('a_1708 -> unit) -> 'a_1708 list -> unit = 
      (fn x_1008: 'a_1708 -> unit =>
       case x_1008 of
	 (f: 'a_1708 -> unit) =>
	 ((foldl ('a_1708, unit) (o_1 ('a_1708 * unit, unit, 'a_1708) (f,
								       (fn x_1009: 'a_1708
										   * unit =>
									case x_1009 of
									  {1 = #: 'a_1708} =>
									  #)))) ()))
val rec ('a_1710, 'a_1709)
   map: ('a_1710 -> 'a_1709) -> 'a_1710 list -> 'a_1709 list = 
      (fn x_1010: 'a_1710 -> 'a_1709 =>
       (fn x_1011: 'a_1710 list =>
	case (x_1010, x_1011) of
	  (f: 'a_1710 -> 'a_1709, l: 'a_1710 list) =>
	  (rev ('a_1709) (((foldl ('a_1710, 'a_1709 list) (fn x_1012: 'a_1710
								      * 'a_1709 list =>
							   case x_1012 of
							     (x: 'a_1710,
							      l: 'a_1709 list) =>
							     (::['a_1709] ((f x),
									   l)))) []) l))))
val rec 'a_1715
   find: ('a_1715 -> bool) -> 'a_1715 list -> 'a_1715 Primitive.Option.t = 
      (fn x_1013: 'a_1715 -> bool =>
       case x_1013 of
	 (pred: 'a_1715 -> bool) =>
	 let val rec
		loop: 'a_1715 list -> 'a_1715 Primitive.Option.t = 
		   (fn x_1014: 'a_1715 list =>
		    case x_1014 of
		      [] => NONE['a_1715]
		    | ::['a_1715] (x: 'a_1715, l: 'a_1715 list) =>
		      case (pred x) of
			true => (SOME['a_1715] x) | false => (loop l))
	 in
	    loop
	 end)
val 'a rev_0: 'a list -> 'a list = rev ('a)
val ('b, 'a) map_1: ('a -> 'b) -> 'a list -> 'b list = map ('a, 'b)
val 'a length_0: 'a list -> int32 = length ('a)
val ('b, 'a) foldl_0: ('a * 'b -> 'b) -> 'b -> 'a list -> 'b = foldl ('a, 'b)
val 'a find_0: ('a -> bool) -> 'a list -> 'a Primitive.Option.t = find ('a)
val 'a app_0: ('a -> unit) -> 'a list -> unit = app ('a)
val 'a rev_1: 'a list -> 'a list = rev_0 ('a)
val ('b, 'a) map_2: ('a -> 'b) -> 'a list -> 'b list = map_1 ('b, 'a)
val 'a app_1: ('a -> unit) -> 'a list -> unit = app_0 ('a)
exception UnequalLengths
val maxLen': int64 = maxInt'
val fInt8: int8 -> int64 = sextdFromInt8
val fInt16: int16 -> int64 = sextdFromInt16
val fInt32: int32 -> int64 = sextdFromInt32
val fInt64: int64 -> int64 = sextdFromInt64
val fIntInf: intInf -> int64 = sextdFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val fromIntUnsafe: int32 -> int64 = f
val fInt8: int8 -> int64 = schckFromInt8
val fInt16: int16 -> int64 = schckFromInt16
val fInt32: int32 -> int64 = schckFromInt32
val fInt64: int64 -> int64 = schckFromInt64
val fIntInf: intInf -> int64 = schckFromIntInf
val _ = fInt8
val _ = fInt16
val f: int32 -> int64 = fInt32
val _ = fInt64
val _ = fIntInf
val fromInt: int32 -> int64 = f
val fInt8: int64 -> int8 = sextdToInt8
val fInt16: int64 -> int16 = sextdToInt16
val fInt32: int64 -> int32 = sextdToInt32
val fInt64: int64 -> int64 = sextdToInt64
val fIntInf: int64 -> intInf = sextdToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val toIntUnsafe: int64 -> int32 = f
val fInt8: int64 -> int8 = schckToInt8
val fInt16: int64 -> int16 = schckToInt16
val fInt32: int64 -> int32 = schckToInt32
val fInt64: int64 -> int64 = schckToInt64
val fIntInf: int64 -> intInf = schckToIntInf
val _ = fInt8
val _ = fInt16
val f: int64 -> int32 = fInt32
val _ = fInt64
val _ = fIntInf
val toInt: int64 -> int32 = f
val 'a_2004 fromArray: 'a_2004 array -> 'a_2004 vector =
   fromArrayUnsafe ('a_2004)
val isMutable: bool = false
val 'a_2005 length: 'a_2005 vector -> int64 = length ('a_2005)
val 'a_2006 subUnsafe: 'a_2006 vector * int64 -> 'a_2006 = subUnsafe ('a_2006)
val 'a subUnsafe_0: 'a vector * int64 -> 'a = subUnsafe ('a)
val 'a length_1: 'a vector -> int64 = length ('a)
val 'a fromArray_0: 'a array -> 'a vector = fromArray ('a)
val +?: int64 * int64 -> int64 = +?
val +: int64 * int64 -> int64 = +
val -?: int64 * int64 -> int64 = -?
val <: int64 * int64 -> bool = <
val <=: int64 * int64 -> bool = <=
val >: int64 * int64 -> bool = >
val >=: int64 * int64 -> bool = >=
val gtu: int64 * int64 -> bool = gtu
val geu: int64 * int64 -> bool = geu
val rec ('a_2012, 'a_2011)
   wrap2: (int32 * 'a_2012 -> 'a_2011) -> int64 * 'a_2012 -> 'a_2011 = 
      (fn x_1015: int32 * 'a_2012 -> 'a_2011 =>
       case x_1015 of
	 (f: int32 * 'a_2012 -> 'a_2011) =>
	 (fn x_1016: int64 * 'a_2012 =>
	  case x_1016 of
	    (i: int64, x: 'a_2012) => (f ((toIntUnsafe i), x))))
val rec 'a_2019
   doit: int32 * (int64 -> 'a_2019) * ('a_2019 -> int64) * 'a_2019
	 -> int64 * 'a_2019 = 
      (fn x_1017: int32 * (int64 -> 'a_2019) * ('a_2019 -> int64) * 'a_2019 =>
       case x_1017 of
	 ((precision: int32,
	   toInt: int64 -> 'a_2019,
	   fromInt: 'a_2019 -> int64,
	   maxInt': 'a_2019)) =>
	 case (>= ((valOf_1 (int32) precision), precision)) of
	   true => ((fromInt maxInt'), maxInt')
	 | false => (maxLen', (toInt maxLen')))
val fInt8: int64 * int8 =
   (doit (int8) ((valOf_1 (int32) precision),
		 schckToInt8,
		 schckFromInt8,
		 maxInt'))
val fInt16: int64 * int16 =
   (doit (int16) ((valOf_1 (int32) precision),
		  schckToInt16,
		  schckFromInt16,
		  maxInt'))
val fInt32: int64 * int32 =
   (doit (int32) ((valOf_1 (int32) precision),
		  schckToInt32,
		  schckFromInt32,
		  maxInt'))
val fInt64: int64 * int64 =
   (doit (int64) ((valOf_1 (int32) precision),
		  schckToInt64,
		  schckFromInt64,
		  maxInt'))
val fIntInf: int64 * intInf = (maxLen', (schckToIntInf maxLen'))
val _ = fInt8
val _ = fInt16
val f: int64 * int32 = fInt32
val _ = fInt64
val _ = fIntInf
val (maxLen': int64, maxLen: int32) = f
val rec
   fromIntForLength: int32 -> int64 = 
      (fn x_1018: int32 =>
       case x_1018 of
	 (n: int32) =>
	 case safe of
	   true =>
	   (fromInt n)
	   handle x_1019 => case x_1019 of
			      Overflow => raise Size
	 | false => (fromIntUnsafe n))
val rec 'a_2022
   length': 'a_2022 vector -> int64 = 
      (fn x_1020: 'a_2022 vector =>
       case x_1020 of
	 (s: 'a_2022 vector) => (length_1 ('a_2022) s))
val rec 'a_2023
   length: 'a_2023 vector -> int32 = 
      (fn x_1021: 'a_2023 vector =>
       case x_1021 of
	 (s: 'a_2023 vector) =>
	 case safe of
	   true =>
	   (toInt (length' ('a_2023) s))
	   handle x_1022 => case x_1022 of
			      Overflow => raise (Fail "Sequence.length")
	 | false => (toIntUnsafe (length' ('a_2023) s)))
val rec 'a_2024
   arrayUninit': int64 -> 'a_2024 array = 
      (fn x_1023: int64 =>
       case x_1023 of
	 (n: int64) =>
	 case case (not isMutable) of
		true => (= (int64) (n, 0x0)) | false => false of
	   true => (array0Const ('a_2024) ())
	 | false =>
	   case case safe of
		  true => (gtu (n, maxLen')) | false => false of
	     true => raise Size | false => (arrayUnsafe ('a_2024) n))
val rec ('a_2031, 'a_2030)
   unfoldi': int64 * 'a_2031 * (int64 * 'a_2031 -> 'a_2030 * 'a_2031)
	     -> 'a_2030 vector * 'a_2031 = 
      (fn x_1024: int64 * 'a_2031 * (int64 * 'a_2031 -> 'a_2030 * 'a_2031) =>
       case x_1024 of
	 ((n: int64, b: 'a_2031, f: int64 * 'a_2031 -> 'a_2030 * 'a_2031)) =>
	 let val a: 'a_2030 array = (arrayUninit' ('a_2030) n)
	     val rec
		loop: int64 * 'a_2031 -> 'a_2031 = 
		   (fn x_1025: int64 * 'a_2031 =>
		    case x_1025 of
		      ((i: int64, b: 'a_2031)) =>
		      case (>= (i, n)) of
			true => b
		      | false =>
			let val (x: 'a_2030, b': 'a_2031) = (f (i, b))
			    val () = (updateUnsafe ('a_2030) (a, i, x))
			in
			   (loop ((+? (i, 0x1)), b'))
			end)
	     val b: 'a_2031 = (loop (0x0, b))
	 in
	    ((fromArray_0 ('a_2030) a), b)
	 end)
val rec ('a_2033, 'a_2032)
   unfoldi: int32 * 'a_2032 * (int32 * 'a_2032 -> 'a_2033 * 'a_2032)
	    -> 'a_2033 vector * 'a_2032 = 
      (fn x_1026: int32 * 'a_2032 * (int32 * 'a_2032 -> 'a_2033 * 'a_2032) =>
       case x_1026 of
	 ((n: int32, b: 'a_2032, f: int32 * 'a_2032 -> 'a_2033 * 'a_2032)) =>
	 (unfoldi' ('a_2032, 'a_2033) ((fromIntForLength n),
				       b,
				       (wrap2 ('a_2032, 'a_2033 * 'a_2032) f))))
val rec ('a_2035, 'a_2034)
   unfold: int32 * 'a_2034 * ('a_2034 -> 'a_2035 * 'a_2034)
	   -> 'a_2035 vector * 'a_2034 = 
      (fn x_1027: int32 * 'a_2034 * ('a_2034 -> 'a_2035 * 'a_2034) =>
       case x_1027 of
	 ((n: int32, b: 'a_2034, f: 'a_2034 -> 'a_2035 * 'a_2034)) =>
	 (unfoldi ('a_2035, 'a_2034) (n,
				      b,
				      (o_1 (int32 * 'a_2034,
					    'a_2035 * 'a_2034,
					    'a_2034) (f,
						      (fn x_1028: int32
								  * 'a_2034 =>
						       case x_1028 of
							 {2 = #: 'a_2034} => #))))))
val rec 'a_2036
   seq0: unit -> 'a_2036 vector = 
      (fn x_1029: unit =>
       case x_1029 of
	 (()) =>
	 ((fn x_1030: 'a_2036 vector * unit =>
	   case x_1030 of
	     {1 = #: 'a_2036 vector} => #) (unfold ('a_2036, unit) (0x0,
						       (),
						       (fn x_1031: unit =>
							case x_1031 of
							  _ =>
							  raise (Fail "Sequence.seq0"))))))
val rec 'a_2037
   tabulate': int64 * (int64 -> 'a_2037) -> 'a_2037 vector = 
      (fn x_1032: int64 * (int64 -> 'a_2037) =>
       case x_1032 of
	 ((n: int64, f: int64 -> 'a_2037)) =>
	 ((fn x_1033: 'a_2037 vector * unit =>
	   case x_1033 of
	     {1 = #: 'a_2037 vector} => #) (unfoldi' (unit, 'a_2037) (n,
							 (),
							 (fn x_1034: int64
								     * unit =>
							  case x_1034 of
							    (i: int64, ()) =>
							    ((f i), ()))))))
val rec 'a_2038
   tabulate: int32 * (int32 -> 'a_2038) -> 'a_2038 vector = 
      (fn x_1035: int32 * (int32 -> 'a_2038) =>
       case x_1035 of
	 ((n: int32, f: int32 -> 'a_2038)) =>
	 ((fn x_1036: 'a_2038 vector * unit =>
	   case x_1036 of
	     {1 = #: 'a_2038 vector} => #) (unfoldi ('a_2038, unit) (n,
							(),
							(fn x_1037: int32 * unit =>
							 case x_1037 of
							   (i: int32, ()) =>
							   ((f i), ()))))))
val rec 'a_2040
   new: int32 * 'a_2040 -> 'a_2040 vector = 
      (fn x_1038: int32 * 'a_2040 =>
       case x_1038 of
	 ((n: int32, x: 'a_2040)) =>
	 (tabulate ('a_2040) (n, (fn x_1039: int32 => case x_1039 of _ => x))))
val rec 'a_2041
   fromList: 'a_2041 list -> 'a_2041 vector = 
      (fn x_1040: 'a_2041 list =>
       case x_1040 of
	 (l: 'a_2041 list) =>
	 ((fn x_1041: 'a_2041 vector * 'a_2041 list =>
	   case x_1041 of
	     {1 = #: 'a_2041 vector} => #) (unfold ('a_2041, 'a_2041 list) ((length_0 ('a_2041) l),
							       l,
							       (fn x_1042: 'a_2041 list =>
								case x_1042 of
								  l: 'a_2041 list =>
								  case l of
								    nil['a_2041] =>
								    raise (Fail "Sequence.fromList")
								  | ::['a_2041] (h: 'a_2041,
										 t: 'a_2041 list) =>
								    (h, t))))))
datatype 'a Sequence.Slice.t = T of {len: int64, seq: 'a vector, start: int64}
val rec 'a_2042
   length': 'a_2042 Sequence.Slice.t -> int64 = 
      (fn x_1043: 'a_2042 Sequence.Slice.t =>
       case x_1043 of
	 (T['a_2042] {len = len: int64}) => len)
val rec 'a_2044
   unsafeSub': 'a_2044 Sequence.Slice.t * int64 -> 'a_2044 = 
      (fn x_1044: 'a_2044 Sequence.Slice.t * int64 =>
       case x_1044 of
	 ((T['a_2044] {seq = seq: 'a_2044 vector, start = start: int64},
	   i: int64)) =>
	 (subUnsafe_0 ('a_2044) (seq, (+? (start, i)))))
val rec 'a_2045
   unsafeSub: 'a_2045 Sequence.Slice.t * int32 -> 'a_2045 = 
      (fn x_1045: 'a_2045 Sequence.Slice.t * int32 =>
       case x_1045 of
	 ((sl: 'a_2045 Sequence.Slice.t, i: int32)) =>
	 (unsafeSub' ('a_2045) (sl, (fromIntUnsafe i))))
val rec 'a_2046
   sub': 'a_2046 Sequence.Slice.t * int64 -> 'a_2046 = 
      (fn x_1046: 'a_2046 Sequence.Slice.t * int64 =>
       case x_1046 of
	 ((sl: 'a_2046 Sequence.Slice.t as T['a_2046] {len = len: int64},
	   i: int64)) =>
	 case case safe of
		true => (geu (i, len)) | false => false of
	   true => raise Subscript | false => (unsafeSub' ('a_2046) (sl, i)))
val rec 'a_2047
   sub: 'a_2047 Sequence.Slice.t * int32 -> 'a_2047 = 
      (fn x_1047: 'a_2047 Sequence.Slice.t * int32 =>
       case x_1047 of
	 ((sl: 'a_2047 Sequence.Slice.t, i: int32)) =>
	 case safe of
	   true =>
	   let val i: int64 =
		  (fromInt i)
		  handle x_1048 => case x_1048 of
				     Overflow => raise Subscript
	   in
	      (sub' ('a_2047) (sl, i))
	   end
	 | false => (unsafeSub ('a_2047) (sl, i)))
val rec 'a
   full: 'a vector -> 'a Sequence.Slice.t = 
      (fn x_1049: 'a vector =>
       case x_1049 of
	 (seq: 'a vector) =>
	 (T['a] {seq = seq, start = 0x0, len = (length_1 ('a) seq)}))
val rec 'a_2060
   unsafeSubslice': 'a_2060 Sequence.Slice.t * int64 * int64 Primitive.Option.t
		    -> 'a_2060 Sequence.Slice.t = 
      (fn x_1050: 'a_2060 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1050 of
	 ((T['a_2060] {seq = seq: 'a_2060 vector,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 (T['a_2060] {seq = seq,
		      start = (+? (start, start')),
		      len = case len' of
			      NONE[int64] => (-? (len, start'))
			    | SOME[int64] len': int64 => len'}))
val rec 'a_2061
   unsafeSubslice: 'a_2061 Sequence.Slice.t * int32 * int32 Primitive.Option.t
		   -> 'a_2061 Sequence.Slice.t = 
      (fn x_1051: 'a_2061 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1051 of
	 ((sl: 'a_2061 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 (unsafeSubslice' ('a_2061) (sl,
				     (fromIntUnsafe start),
				     ((map_0 (int64, int32) fromIntUnsafe) len))))
val rec 'a_2062
   unsafeSlice': 'a_2062 vector * int64 * int64 Primitive.Option.t
		 -> 'a_2062 Sequence.Slice.t = 
      (fn x_1052: 'a_2062 vector * int64 * int64 Primitive.Option.t =>
       case x_1052 of
	 ((seq: 'a_2062 vector, start: int64, len: int64 Primitive.Option.t)) =>
	 (unsafeSubslice' ('a_2062) ((full ('a_2062) seq), start, len)))
val rec 'a_2064
   subslice': 'a_2064 Sequence.Slice.t * int64 * int64 Primitive.Option.t
	      -> 'a_2064 Sequence.Slice.t = 
      (fn x_1053: 'a_2064 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1053 of
	 ((T['a_2064] {seq = seq: 'a_2064 vector,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 case len' of
	   NONE[int64] =>
	   case case safe of
		  true => (gtu (start', len)) | false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2064] {seq = seq,
			  start = (+? (start, start')),
			  len = (-? (len, start'))})
	 | SOME[int64] len': int64 =>
	   case case safe of
		  true =>
		  case (gtu (start', len)) of
		    true => true | false => (gtu (len', (-? (len, start'))))
		| false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2064] {seq = seq, start = (+? (start, start')), len = len'}))
val rec 'a_2065
   subslice: 'a_2065 Sequence.Slice.t * int32 * int32 Primitive.Option.t
	     -> 'a_2065 Sequence.Slice.t = 
      (fn x_1054: 'a_2065 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1054 of
	 ((sl: 'a_2065 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 case safe of
	   true =>
	   (subslice' ('a_2065) (sl,
				 (fromInt start),
				 ((map_0 (int64, int32) fromInt) len)))
	   handle x_1055 => case x_1055 of
			      Overflow => raise Subscript
	 | false => (unsafeSubslice ('a_2065) (sl, start, len)))
val rec 'a
   slice: 'a vector * int32 * int32 Primitive.Option.t -> 'a Sequence.Slice.t = 
      (fn x_1056: 'a vector * int32 * int32 Primitive.Option.t =>
       case x_1056 of
	 ((seq: 'a vector, start: int32, len: int32 Primitive.Option.t)) =>
	 (subslice ('a) ((full ('a) seq), start, len)))
val rec ('a_2071, 'a_2070)
   foldli': (int64 * 'a_2071 * 'a_2070 -> 'a_2070)
	    -> 'a_2070 -> 'a_2071 Sequence.Slice.t -> 'a_2070 = 
      (fn x_1057: int64 * 'a_2071 * 'a_2070 -> 'a_2070 =>
       (fn x_1058: 'a_2070 =>
	(fn x_1059: 'a_2071 Sequence.Slice.t =>
	 case (x_1057, x_1058, x_1059) of
	   (f: int64 * 'a_2071 * 'a_2070 -> 'a_2070,
	    b: 'a_2070,
	    T['a_2071] {seq = seq: 'a_2071 vector,
			start = start: int64,
			len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_2070 -> 'a_2070 = 
		     (fn x_1060: int64 * 'a_2070 =>
		      case x_1060 of
			((i: int64, b: 'a_2070)) =>
			case (> (i, max)) of
			  true => b
			| false =>
			  (loop ((+? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_0 ('a_2071) (seq, i)),
				     b)))))
	   in
	      (loop (min, b))
	   end)))
val rec ('a_2084, 'a_2083, 'a_2082, 'a_2081, 'a_2080, 'a_2079, 'a_2078)
   make: (('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
	  -> 'a_2080 -> 'a_2079 -> 'a_2078)
	 -> ('a_2083 * 'a_2082 -> 'a_2081) -> 'a_2080 -> 'a_2079 -> 'a_2078 = 
      (fn x_1061: ('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
		  -> 'a_2080 -> 'a_2079 -> 'a_2078 =>
       (fn x_1062: 'a_2083 * 'a_2082 -> 'a_2081 =>
	(fn x_1063: 'a_2080 =>
	 (fn x_1064: 'a_2079 =>
	  case (x_1061, x_1062, x_1063, x_1064) of
	    (foldi: ('a_2084 * 'a_2083 * 'a_2082 -> 'a_2081)
		    -> 'a_2080 -> 'a_2079 -> 'a_2078,
	     f: 'a_2083 * 'a_2082 -> 'a_2081,
	     b: 'a_2080,
	     sl: 'a_2079) =>
	    (((foldi (fn x_1065: 'a_2084 * 'a_2083 * 'a_2082 =>
		      case x_1065 of
			(_, x: 'a_2083, b: 'a_2082) => (f (x, b)))) b) sl)))))
val rec ('a_2086, 'a_2085)
   foldl: ('a_2086 * 'a_2085 -> 'a_2085)
	  -> 'a_2085 -> 'a_2086 Sequence.Slice.t -> 'a_2085 = 
      (fn x_1066: 'a_2086 * 'a_2085 -> 'a_2085 =>
       case x_1066 of
	 (f: 'a_2086 * 'a_2085 -> 'a_2085) =>
	 ((make (int64,
		 'a_2086,
		 'a_2085,
		 'a_2085,
		 'a_2085,
		 'a_2086 Sequence.Slice.t,
		 'a_2085) foldli' ('a_2086, 'a_2085)) f))
val rec ('a_2094, 'a_2093, 'a_2092)
   createi': (int64 * (int64 -> 'a_2093) -> 'a_2092)
	     -> (int64 * 'a_2094 -> 'a_2093)
		-> 'a_2094 Sequence.Slice.t -> 'a_2092 = 
      (fn x_1067: int64 * (int64 -> 'a_2093) -> 'a_2092 =>
       (fn x_1068: int64 * 'a_2094 -> 'a_2093 =>
	(fn x_1069: 'a_2094 Sequence.Slice.t =>
	 case (x_1067, x_1068, x_1069) of
	   (tabulate': int64 * (int64 -> 'a_2093) -> 'a_2092,
	    f: int64 * 'a_2094 -> 'a_2093,
	    T['a_2094] {seq = seq: 'a_2094 vector,
			start = start: int64,
			len = len: int64}) =>
	   (tabulate' (len,
		       (fn x_1070: int64 =>
			case x_1070 of
			  i: int64 =>
			  (f (i, (subUnsafe_0 ('a_2094) (seq, (+? (start, i))))))))))))
val rec ('a_2102, 'a_2101)
   mapi': (int64 * 'a_2102 -> 'a_2101)
	  -> 'a_2102 Sequence.Slice.t -> 'a_2101 vector = 
      (fn x_1071: int64 * 'a_2102 -> 'a_2101 =>
       (fn x_1072: 'a_2102 Sequence.Slice.t =>
	case (x_1071, x_1072) of
	  (f: int64 * 'a_2102 -> 'a_2101, sl: 'a_2102 Sequence.Slice.t) =>
	  (((createi' ('a_2102, 'a_2101, 'a_2101 vector) tabulate' ('a_2101)) f) sl)))
val rec ('a_2104, 'a_2103)
   mapi: (int32 * 'a_2104 -> 'a_2103)
	 -> 'a_2104 Sequence.Slice.t -> 'a_2103 vector = 
      (fn x_1073: int32 * 'a_2104 -> 'a_2103 =>
       (fn x_1074: 'a_2104 Sequence.Slice.t =>
	case (x_1073, x_1074) of
	  (f: int32 * 'a_2104 -> 'a_2103, sl: 'a_2104 Sequence.Slice.t) =>
	  ((mapi' ('a_2104, 'a_2103) (wrap2 ('a_2104, 'a_2103) f)) sl)))
val rec ('a_2106, 'a_2105)
   map: ('a_2105 -> 'a_2106) -> 'a_2105 Sequence.Slice.t -> 'a_2106 vector = 
      (fn x_1075: 'a_2105 -> 'a_2106 =>
       (fn x_1076: 'a_2105 Sequence.Slice.t =>
	case (x_1075, x_1076) of
	  (f: 'a_2105 -> 'a_2106, sl: 'a_2105 Sequence.Slice.t) =>
	  ((mapi ('a_2105, 'a_2106) (o_1 (int32 * 'a_2105, 'a_2106, 'a_2105) (f,
									      (fn x_1077: int32
											  * 'a_2105 =>
									       case x_1077 of
										 {2 = #: 'a_2105} =>
										 #)))) sl)))
val rec 'a
   sequence: 'a Sequence.Slice.t -> 'a vector = 
      (fn x_1078: 'a Sequence.Slice.t =>
       case x_1078 of
	 (sl: 'a Sequence.Slice.t as T['a] {seq = seq: 'a vector,
					    start = start: int64,
					    len = len: int64}) =>
	 case case isMutable of
		true => true
	      | false =>
		case (<> (int64) (start, 0x0)) of
		  true => true
		| false => (<> (int64) (len, (length_1 ('a) seq))) of
	   true =>
	   ((map ('a, 'a) (fn x_1079: 'a =>
			   case x_1079 of
			     x: 'a => x)) sl)
	 | false => seq)
val rec 'a
   append: 'a Sequence.Slice.t * 'a Sequence.Slice.t -> 'a vector = 
      (fn x_1080: 'a Sequence.Slice.t * 'a Sequence.Slice.t =>
       case x_1080 of
	 ((sl1: 'a Sequence.Slice.t, sl2: 'a Sequence.Slice.t)) =>
	 case (= (int64) ((length' ('a) sl1), 0x0)) of
	   true => (sequence ('a) sl2)
	 | false =>
	   case (= (int64) ((length' ('a) sl2), 0x0)) of
	     true => (sequence ('a) sl1)
	   | false =>
	     let val l1: int64 = (length' ('a) sl1)
		 val l2: int64 = (length' ('a) sl2)
		 val n: int64 =
		    (+ (l1, l2))
		    handle x_1081 => case x_1081 of
				       Overflow => raise Size
	     in
		((fn x_1082: 'a vector * (int64 * 'a Sequence.Slice.t) =>
		  case x_1082 of
		    {1 = #: 'a vector} => #) (unfoldi' (int64 * 'a Sequence.Slice.t, 'a) (n,
								      (0x0, sl1),
								      (fn x_1083: int64
										  * (int64
										     * 'a Sequence.Slice.t) =>
								       case x_1083 of
									 (_,
									  (i: int64,
									   sl: 'a Sequence.Slice.t)) =>
									 case (< (i,
										  (length' ('a) sl))) of
									   true =>
									   ((unsafeSub' ('a) (sl,
											      i)),
									    ((+? (i,
										  0x1)),
									     sl))
									 | false =>
									   ((unsafeSub' ('a) (sl2,
											      0x0)),
									    (0x1,
									     sl2))))))
	     end)
val rec 'a
   concat: 'a Sequence.Slice.t list -> 'a vector = 
      (fn x_1084: 'a Sequence.Slice.t list =>
       case x_1084 of
	 (sls: 'a Sequence.Slice.t list) =>
	 case sls of
	   [] => (seq0 ('a) ())
	 | [sl: 'a Sequence.Slice.t] => (sequence ('a) sl)
	 | sls': 'a Sequence.Slice.t list as ::['a Sequence.Slice.t] (sl: 'a Sequence.Slice.t,
								      sls: 'a Sequence.Slice.t list) =>
	   let val n: int64 =
		  (((foldl_0 (int64, 'a Sequence.Slice.t) (fn x_1086: 'a Sequence.Slice.t
								      * int64 =>
							   case x_1086 of
							     (sl: 'a Sequence.Slice.t,
							      s: int64) =>
							     (+? (s,
								  (length' ('a) sl))))) 0x0) sls')
		  handle x_1085 => case x_1085 of
				     Overflow => raise Size
	   in
	      ((fn x_1087: 'a vector
			   * (int64
			      * 'a Sequence.Slice.t
			      * 'a Sequence.Slice.t list) =>
		case x_1087 of
		  {1 = #: 'a vector} => #) (unfoldi' (int64
				    * 'a Sequence.Slice.t
				    * 'a Sequence.Slice.t list,
				    'a) (n,
					 (0x0, sl, sls),
					 (fn x_1088: int64
						     * (int64
							* 'a Sequence.Slice.t
							* 'a Sequence.Slice.t list) =>
					  case x_1088 of
					    (_,
					     ac: int64
						 * 'a Sequence.Slice.t
						 * 'a Sequence.Slice.t list) =>
					    let val rec 'a_2118
						   loop: int64
							 * 'a_2118 Sequence.Slice.t
							 * 'a_2118 Sequence.Slice.t list
							 -> 'a_2118
							    * (int64
							       * 'a_2118 Sequence.Slice.t
							       * 'a_2118 Sequence.Slice.t list) = 
						      (fn x_1089: int64
								  * 'a_2118 Sequence.Slice.t
								  * 'a_2118 Sequence.Slice.t list =>
						       case x_1089 of
							 ((i: int64,
							   sl: 'a_2118 Sequence.Slice.t,
							   sls: 'a_2118 Sequence.Slice.t list)) =>
							 case (< (i,
								  (length' ('a_2118) sl))) of
							   true =>
							   ((unsafeSub' ('a_2118) (sl,
										   i)),
							    ((+? (i, 0x1)),
							     sl,
							     sls))
							 | false =>
							   case sls of
							     [] =>
							     raise (Fail "Sequence.Slice.concat")
							   | ::['a_2118 Sequence.Slice.t] (sl: 'a_2118 Sequence.Slice.t,
											   sls: 'a_2118 Sequence.Slice.t list) =>
							     (loop ('a_2118) (0x0,
									      sl,
									      sls)))
					    in
					       (loop ('a) ac)
					    end))))
	   end)
val rec 'a
   isPrefix: ('a * 'a -> bool) -> 'a vector -> 'a Sequence.Slice.t -> bool = 
      (fn x_1090: 'a * 'a -> bool =>
       (fn x_1091: 'a vector =>
	(fn x_1092: 'a Sequence.Slice.t =>
	 case (x_1090, x_1091, x_1092) of
	   (eq: 'a * 'a -> bool, seq: 'a vector, sl: 'a Sequence.Slice.t) =>
	   let val n: int64 = (length_1 ('a) seq)
	       val n': int64 = (length' ('a) sl)
	   in
	      case (<= (n, n')) of
		true =>
		let val rec
		       loop: int64 -> bool = 
			  (fn x_1093: int64 =>
			   case x_1093 of
			     (j: int64) =>
			     case (>= (j, n)) of
			       true => true
			     | false =>
			       case (eq ((subUnsafe_0 ('a) (seq, j)),
					 (unsafeSub' ('a) (sl, j)))) of
				 true => (loop (+? (j, 0x1))) | false => false)
		in
		   (loop 0x0)
		end
	      | false => false
	   end)))
val rec 'a_2121
   split': 'a_2121 Sequence.Slice.t * int64
	   -> 'a_2121 Sequence.Slice.t * 'a_2121 Sequence.Slice.t = 
      (fn x_1094: 'a_2121 Sequence.Slice.t * int64 =>
       case x_1094 of
	 ((T['a_2121] {seq = seq: 'a_2121 vector,
		       start = start: int64,
		       len = len: int64},
	   i: int64)) =>
	 ((unsafeSlice' ('a_2121) (seq, start, (SOME[int64] (-? (i, start))))),
	  (unsafeSlice' ('a_2121) (seq,
				   i,
				   (SOME[int64] (-? (len, (-? (i, start)))))))))
val rec 'a_2122
   splitl: ('a_2122 -> bool)
	   -> 'a_2122 Sequence.Slice.t
	      -> 'a_2122 Sequence.Slice.t * 'a_2122 Sequence.Slice.t = 
      (fn x_1095: 'a_2122 -> bool =>
       (fn x_1096: 'a_2122 Sequence.Slice.t =>
	case (x_1095, x_1096) of
	  (f: 'a_2122 -> bool,
	   sl: 'a_2122 Sequence.Slice.t as T['a_2122] {seq = seq: 'a_2122 vector,
						       start = start: int64,
						       len = len: int64}) =>
	  let val stop: int64 = (+? (start, len))
	      val rec
		 loop: int64 -> int64 = 
		    (fn x_1097: int64 =>
		     case x_1097 of
		       (i: int64) =>
		       case (>= (i, stop)) of
			 true => i
		       | false =>
			 case (f (subUnsafe_0 ('a_2122) (seq, i))) of
			   true => (loop (+? (i, 0x1))) | false => i)
	  in
	     (split' ('a_2122) (sl, (loop start)))
	  end))
val rec 'a_2123
   splitr: ('a_2123 -> bool)
	   -> 'a_2123 Sequence.Slice.t
	      -> 'a_2123 Sequence.Slice.t * 'a_2123 Sequence.Slice.t = 
      (fn x_1098: 'a_2123 -> bool =>
       (fn x_1099: 'a_2123 Sequence.Slice.t =>
	case (x_1098, x_1099) of
	  (f: 'a_2123 -> bool,
	   sl: 'a_2123 Sequence.Slice.t as T['a_2123] {seq = seq: 'a_2123 vector,
						       start = start: int64,
						       len = len: int64}) =>
	  let val rec
		 loop: int64 -> int64 = 
		    (fn x_1100: int64 =>
		     case x_1100 of
		       (i: int64) =>
		       case (< (i, start)) of
			 true => start
		       | false =>
			 case (f (subUnsafe_0 ('a_2123) (seq, i))) of
			   true => (loop (-? (i, 0x1))) | false => (+? (i, 0x1)))
	  in
	     (split' ('a_2123) (sl, (loop (-? ((+? (start, len)), 0x1)))))
	  end))
val rec 'a_2127
   dropr: ('a_2127 -> bool)
	  -> 'a_2127 Sequence.Slice.t -> 'a_2127 Sequence.Slice.t = 
      (fn x_1101: 'a_2127 -> bool =>
       (fn x_1102: 'a_2127 Sequence.Slice.t =>
	case (x_1101, x_1102) of
	  (p: 'a_2127 -> bool, s: 'a_2127 Sequence.Slice.t) =>
	  ((fn x_1103: 'a_2127 Sequence.Slice.t * 'a_2127 Sequence.Slice.t =>
	    case x_1103 of
	      {1 = #: 'a_2127 Sequence.Slice.t} => #) ((splitr ('a_2127) p) s))))
val rec 'a_2128
   takel: ('a_2128 -> bool)
	  -> 'a_2128 Sequence.Slice.t -> 'a_2128 Sequence.Slice.t = 
      (fn x_1104: 'a_2128 -> bool =>
       (fn x_1105: 'a_2128 Sequence.Slice.t =>
	case (x_1104, x_1105) of
	  (p: 'a_2128 -> bool, s: 'a_2128 Sequence.Slice.t) =>
	  ((fn x_1106: 'a_2128 Sequence.Slice.t * 'a_2128 Sequence.Slice.t =>
	    case x_1106 of
	      {1 = #: 'a_2128 Sequence.Slice.t} => #) ((splitl ('a_2128) p) s))))
val rec 'a_2129
   taker: ('a_2129 -> bool)
	  -> 'a_2129 Sequence.Slice.t -> 'a_2129 Sequence.Slice.t = 
      (fn x_1107: 'a_2129 -> bool =>
       (fn x_1108: 'a_2129 Sequence.Slice.t =>
	case (x_1107, x_1108) of
	  (p: 'a_2129 -> bool, s: 'a_2129 Sequence.Slice.t) =>
	  ((fn x_1109: 'a_2129 Sequence.Slice.t * 'a_2129 Sequence.Slice.t =>
	    case x_1109 of
	      {2 = #: 'a_2129 Sequence.Slice.t} => #) ((splitr ('a_2129) p) s))))
val rec ('a_2130, 'a)
   translate: ('a -> 'a_2130 vector) -> 'a Sequence.Slice.t -> 'a_2130 vector = 
      (fn x_1110: 'a -> 'a_2130 vector =>
       (fn x_1111: 'a Sequence.Slice.t =>
	case (x_1110, x_1111) of
	  (f: 'a -> 'a_2130 vector, sl: 'a Sequence.Slice.t) =>
	  (concat ('a_2130) (rev_0 ('a_2130 Sequence.Slice.t) (((foldl ('a,
									'a_2130 Sequence.Slice.t list) (fn x_1112: 'a
														   * 'a_2130 Sequence.Slice.t list =>
													case x_1112 of
													  (c: 'a,
													   l: 'a_2130 Sequence.Slice.t list) =>
													  (::['a_2130 Sequence.Slice.t] ((full ('a_2130) (f c)),
																	 l)))) []) sl)))))
val rec ('a_2136, 'a_2135)
   make: ('a_2136 Sequence.Slice.t -> 'a_2135) -> 'a_2136 vector -> 'a_2135 = 
      (fn x_1113: 'a_2136 Sequence.Slice.t -> 'a_2135 =>
       (fn x_1114: 'a_2136 vector =>
	case (x_1113, x_1114) of
	  (f: 'a_2136 Sequence.Slice.t -> 'a_2135, seq: 'a_2136 vector) =>
	  (f (full ('a_2136) seq))))
val rec ('a_2139, 'a_2138, 'a_2137)
   make2: ('a_2139 Sequence.Slice.t * 'a_2138 Sequence.Slice.t -> 'a_2137)
	  -> 'a_2139 vector * 'a_2138 vector -> 'a_2137 = 
      (fn x_1115: 'a_2139 Sequence.Slice.t * 'a_2138 Sequence.Slice.t -> 'a_2137 =>
       (fn x_1116: 'a_2139 vector * 'a_2138 vector =>
	case (x_1115, x_1116) of
	  (f: 'a_2139 Sequence.Slice.t * 'a_2138 Sequence.Slice.t -> 'a_2137,
	   (seq1: 'a_2139 vector, seq2: 'a_2138 vector)) =>
	  (f ((full ('a_2139) seq1), (full ('a_2138) seq2)))))
val rec 'a_2140
   sub: 'a_2140 vector * int32 -> 'a_2140 = 
      (fn x_1117: 'a_2140 vector * int32 =>
       case x_1117 of
	 ((seq: 'a_2140 vector, i: int32)) =>
	 (sub ('a_2140) ((full ('a_2140) seq), i)))
val rec 'a_2156
   append: 'a_2156 vector * 'a_2156 vector -> 'a_2156 vector = 
      (fn x_1118: 'a_2156 vector * 'a_2156 vector =>
       case x_1118 of
	 (seqs: 'a_2156 vector * 'a_2156 vector) =>
	 ((make2 ('a_2156, 'a_2156, 'a_2156 vector) append ('a_2156)) seqs))
val rec 'a_2157
   concat: 'a_2157 vector list -> 'a_2157 vector = 
      (fn x_1119: 'a_2157 vector list =>
       case x_1119 of
	 (seqs: 'a_2157 vector list) =>
	 (concat ('a_2157) ((map_1 ('a_2157 Sequence.Slice.t, 'a_2157 vector) full ('a_2157)) seqs)))
val rec 'a_2191
   isPrefix: ('a_2191 * 'a_2191 -> bool)
	     -> 'a_2191 vector -> 'a_2191 vector -> bool = 
      (fn x_1120: 'a_2191 * 'a_2191 -> bool =>
       (fn x_1121: 'a_2191 vector =>
	case (x_1120, x_1121) of
	  (eq: 'a_2191 * 'a_2191 -> bool, seq: 'a_2191 vector) =>
	  (make ('a_2191, bool) ((isPrefix ('a_2191) eq) seq))))
val rec ('a_2195, 'a_2194)
   translate: ('a_2194 -> 'a_2195 vector) -> 'a_2194 vector -> 'a_2195 vector = 
      (fn x_1122: 'a_2194 -> 'a_2195 vector =>
       case x_1122 of
	 (f: 'a_2194 -> 'a_2195 vector) =>
	 (make ('a_2194, 'a_2195 vector) (translate ('a_2195, 'a_2194) f)))
val ('b, 'a) translate_0: ('a -> 'b vector) -> 'a vector -> 'b vector =
   translate ('b, 'a)
val 'a tabulate'_0: int64 * (int64 -> 'a) -> 'a vector = tabulate' ('a)
val 'a tabulate_0: int32 * (int32 -> 'a) -> 'a vector = tabulate ('a)
val 'a sub_0: 'a vector * int32 -> 'a = sub ('a)
val 'a new_0: int32 * 'a -> 'a vector = new ('a)
val 'a length_2: 'a vector -> int32 = length ('a)
val 'a isPrefix_0: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool =
   isPrefix ('a)
val 'a fromList_0: 'a list -> 'a vector = fromList ('a)
val 'a concat_0: 'a vector list -> 'a vector = concat ('a)
val 'a append_0: 'a vector * 'a vector -> 'a vector = append ('a)
val 'a taker_0: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   taker ('a)
val 'a takel_0: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   takel ('a)
val 'a slice_0: 'a vector * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice ('a)
val 'a sequence_0: 'a Sequence.Slice.t -> 'a vector = sequence ('a)
val 'a full_0: 'a vector -> 'a Sequence.Slice.t = full ('a)
val 'a dropr_0: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   dropr ('a)
val 'a_2220 vector: 'a_2220 Sequence.Slice.t -> 'a_2220 vector =
   sequence_0 ('a_2220)
val 'a_2224 unsafeFromArray: 'a_2224 array -> 'a_2224 vector =
   fromArrayUnsafe ('a_2224)
val 'a_2225 vector: int32 * 'a_2225 -> 'a_2225 vector = new_0 ('a_2225)
val 'a vector_0: int32 * 'a -> 'a vector = vector ('a)
val 'a unsafeFromArray_0: 'a array -> 'a vector = unsafeFromArray ('a)
val ('b, 'a) translate_1: ('a -> 'b vector) -> 'a vector -> 'b vector =
   translate_0 ('b, 'a)
val 'a tabulate'_1: int64 * (int64 -> 'a) -> 'a vector = tabulate'_0 ('a)
val 'a tabulate_1: int32 * (int32 -> 'a) -> 'a vector = tabulate_0 ('a)
val 'a sub_1: 'a vector * int32 -> 'a = sub_0 ('a)
val 'a length_3: 'a vector -> int32 = length_2 ('a)
val 'a isPrefix_1: ('a * 'a -> bool) -> 'a vector -> 'a vector -> bool =
   isPrefix_0 ('a)
val 'a fromList_1: 'a list -> 'a vector = fromList_0 ('a)
val 'a concat_1: 'a vector list -> 'a vector = concat_0 ('a)
val 'a append_1: 'a vector * 'a vector -> 'a vector = append_0 ('a)
val 'a vector_1: 'a Sequence.Slice.t -> 'a vector = vector ('a)
val 'a taker_1: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   taker_0 ('a)
val 'a takel_1: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   takel_0 ('a)
val 'a slice_1: 'a vector * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice_0 ('a)
val 'a full_1: 'a vector -> 'a Sequence.Slice.t = full_0 ('a)
val 'a dropr_1: ('a -> bool) -> 'a Sequence.Slice.t -> 'a Sequence.Slice.t =
   dropr_0 ('a)
val 'a_2240 fromArray: 'a_2240 -> 'a_2240 =
   (fn x_1123: 'a_2240 =>
    case x_1123 of
      a: 'a_2240 => a)
val isMutable: bool = true
val 'a_2241 length: 'a_2241 array -> int64 = length ('a_2241)
val 'a_2242 subUnsafe: 'a_2242 array * int64 -> 'a_2242 = subUnsafe ('a_2242)
val 'a subUnsafe_1: 'a array * int64 -> 'a = subUnsafe ('a)
val 'a length_4: 'a array -> int64 = length ('a)
val 'a fromArray_1: 'a array -> 'a array = fromArray ('a array)
val +?: int64 * int64 -> int64 = +?
val -?: int64 * int64 -> int64 = -?
val <: int64 * int64 -> bool = <
val >=: int64 * int64 -> bool = >=
val gtu: int64 * int64 -> bool = gtu
val geu: int64 * int64 -> bool = geu
val rec ('a_2248, 'a_2247)
   wrap2: (int32 * 'a_2248 -> 'a_2247) -> int64 * 'a_2248 -> 'a_2247 = 
      (fn x_1124: int32 * 'a_2248 -> 'a_2247 =>
       case x_1124 of
	 (f: int32 * 'a_2248 -> 'a_2247) =>
	 (fn x_1125: int64 * 'a_2248 =>
	  case x_1125 of
	    (i: int64, x: 'a_2248) => (f ((toIntUnsafe i), x))))
val rec ('a_2251, 'a_2250, 'a_2249)
   wrap3: (int32 * 'a_2251 * 'a_2250 -> 'a_2249)
	  -> int64 * 'a_2251 * 'a_2250 -> 'a_2249 = 
      (fn x_1126: int32 * 'a_2251 * 'a_2250 -> 'a_2249 =>
       case x_1126 of
	 (f: int32 * 'a_2251 * 'a_2250 -> 'a_2249) =>
	 (fn x_1127: int64 * 'a_2251 * 'a_2250 =>
	  case x_1127 of
	    (i: int64, x: 'a_2251, y: 'a_2250) => (f ((toIntUnsafe i), x, y))))
val rec 'a_2255
   doit: int32 * (int64 -> 'a_2255) * ('a_2255 -> int64) * 'a_2255
	 -> int64 * 'a_2255 = 
      (fn x_1128: int32 * (int64 -> 'a_2255) * ('a_2255 -> int64) * 'a_2255 =>
       case x_1128 of
	 ((precision: int32,
	   toInt: int64 -> 'a_2255,
	   fromInt: 'a_2255 -> int64,
	   maxInt': 'a_2255)) =>
	 case (>= ((valOf_1 (int32) precision), precision)) of
	   true => ((fromInt maxInt'), maxInt')
	 | false => (maxLen', (toInt maxLen')))
val fInt8: int64 * int8 =
   (doit (int8) ((valOf_1 (int32) precision),
		 schckToInt8,
		 schckFromInt8,
		 maxInt'))
val fInt16: int64 * int16 =
   (doit (int16) ((valOf_1 (int32) precision),
		  schckToInt16,
		  schckFromInt16,
		  maxInt'))
val fInt32: int64 * int32 =
   (doit (int32) ((valOf_1 (int32) precision),
		  schckToInt32,
		  schckFromInt32,
		  maxInt'))
val fInt64: int64 * int64 =
   (doit (int64) ((valOf_1 (int32) precision),
		  schckToInt64,
		  schckFromInt64,
		  maxInt'))
val fIntInf: int64 * intInf = (maxLen', (schckToIntInf maxLen'))
val _ = fInt8
val _ = fInt16
val f: int64 * int32 = fInt32
val _ = fInt64
val _ = fIntInf
val (maxLen': int64, maxLen: int32) = f
val rec
   fromIntForLength: int32 -> int64 = 
      (fn x_1129: int32 =>
       case x_1129 of
	 (n: int32) =>
	 case safe of
	   true =>
	   (fromInt n)
	   handle x_1130 => case x_1130 of
			      Overflow => raise Size
	 | false => (fromIntUnsafe n))
val rec 'a_2258
   length': 'a_2258 array -> int64 = 
      (fn x_1131: 'a_2258 array =>
       case x_1131 of
	 (s: 'a_2258 array) => (length_4 ('a_2258) s))
val rec 'a_2259
   length: 'a_2259 array -> int32 = 
      (fn x_1132: 'a_2259 array =>
       case x_1132 of
	 (s: 'a_2259 array) =>
	 case safe of
	   true =>
	   (toInt (length' ('a_2259) s))
	   handle x_1133 => case x_1133 of
			      Overflow => raise (Fail "Sequence.length")
	 | false => (toIntUnsafe (length' ('a_2259) s)))
val rec 'a_2260
   arrayUninit': int64 -> 'a_2260 array = 
      (fn x_1134: int64 =>
       case x_1134 of
	 (n: int64) =>
	 case case (not isMutable) of
		true => (= (int64) (n, 0x0)) | false => false of
	   true => (array0Const ('a_2260) ())
	 | false =>
	   case case safe of
		  true => (gtu (n, maxLen')) | false => false of
	     true => raise Size | false => (arrayUnsafe ('a_2260) n))
val rec 'a_2261
   arrayUninit: int32 -> 'a_2261 array = 
      (fn x_1135: int32 =>
       case x_1135 of
	 (n: int32) => (arrayUninit' ('a_2261) (fromIntForLength n)))
val rec 'a_2263
   newUninit: int32 -> 'a_2263 array = 
      (fn x_1136: int32 =>
       case x_1136 of
	 (n: int32) => (fromArray_1 ('a_2263) (arrayUninit ('a_2263) n)))
val rec ('a_2267, 'a_2266)
   unfoldi': int64 * 'a_2267 * (int64 * 'a_2267 -> 'a_2266 * 'a_2267)
	     -> 'a_2266 array * 'a_2267 = 
      (fn x_1137: int64 * 'a_2267 * (int64 * 'a_2267 -> 'a_2266 * 'a_2267) =>
       case x_1137 of
	 ((n: int64, b: 'a_2267, f: int64 * 'a_2267 -> 'a_2266 * 'a_2267)) =>
	 let val a: 'a_2266 array = (arrayUninit' ('a_2266) n)
	     val rec
		loop: int64 * 'a_2267 -> 'a_2267 = 
		   (fn x_1138: int64 * 'a_2267 =>
		    case x_1138 of
		      ((i: int64, b: 'a_2267)) =>
		      case (>= (i, n)) of
			true => b
		      | false =>
			let val (x: 'a_2266, b': 'a_2267) = (f (i, b))
			    val () = (updateUnsafe ('a_2266) (a, i, x))
			in
			   (loop ((+? (i, 0x1)), b'))
			end)
	     val b: 'a_2267 = (loop (0x0, b))
	 in
	    ((fromArray_1 ('a_2266) a), b)
	 end)
val rec ('a_2269, 'a_2268)
   unfoldi: int32 * 'a_2268 * (int32 * 'a_2268 -> 'a_2269 * 'a_2268)
	    -> 'a_2269 array * 'a_2268 = 
      (fn x_1139: int32 * 'a_2268 * (int32 * 'a_2268 -> 'a_2269 * 'a_2268) =>
       case x_1139 of
	 ((n: int32, b: 'a_2268, f: int32 * 'a_2268 -> 'a_2269 * 'a_2268)) =>
	 (unfoldi' ('a_2268, 'a_2269) ((fromIntForLength n),
				       b,
				       (wrap2 ('a_2268, 'a_2269 * 'a_2268) f))))
val rec 'a_2274
   tabulate: int32 * (int32 -> 'a_2274) -> 'a_2274 array = 
      (fn x_1140: int32 * (int32 -> 'a_2274) =>
       case x_1140 of
	 ((n: int32, f: int32 -> 'a_2274)) =>
	 ((fn x_1141: 'a_2274 array * unit =>
	   case x_1141 of
	     {1 = #: 'a_2274 array} => #) (unfoldi ('a_2274, unit) (n,
						       (),
						       (fn x_1142: int32 * unit =>
							case x_1142 of
							  (i: int32, ()) =>
							  ((f i), ()))))))
val rec 'a_2276
   new: int32 * 'a_2276 -> 'a_2276 array = 
      (fn x_1143: int32 * 'a_2276 =>
       case x_1143 of
	 ((n: int32, x: 'a_2276)) =>
	 (tabulate ('a_2276) (n, (fn x_1144: int32 => case x_1144 of _ => x))))
datatype 'a Sequence.Slice.t = T of {len: int64, seq: 'a array, start: int64}
val rec 'a_2280
   unsafeSub': 'a_2280 Sequence.Slice.t * int64 -> 'a_2280 = 
      (fn x_1145: 'a_2280 Sequence.Slice.t * int64 =>
       case x_1145 of
	 ((T['a_2280] {seq = seq: 'a_2280 array, start = start: int64}, i: int64)) =>
	 (subUnsafe_1 ('a_2280) (seq, (+? (start, i)))))
val rec 'a_2281
   unsafeSub: 'a_2281 Sequence.Slice.t * int32 -> 'a_2281 = 
      (fn x_1146: 'a_2281 Sequence.Slice.t * int32 =>
       case x_1146 of
	 ((sl: 'a_2281 Sequence.Slice.t, i: int32)) =>
	 (unsafeSub' ('a_2281) (sl, (fromIntUnsafe i))))
val rec 'a_2282
   sub': 'a_2282 Sequence.Slice.t * int64 -> 'a_2282 = 
      (fn x_1147: 'a_2282 Sequence.Slice.t * int64 =>
       case x_1147 of
	 ((sl: 'a_2282 Sequence.Slice.t as T['a_2282] {len = len: int64},
	   i: int64)) =>
	 case case safe of
		true => (geu (i, len)) | false => false of
	   true => raise Subscript | false => (unsafeSub' ('a_2282) (sl, i)))
val rec 'a_2283
   sub: 'a_2283 Sequence.Slice.t * int32 -> 'a_2283 = 
      (fn x_1148: 'a_2283 Sequence.Slice.t * int32 =>
       case x_1148 of
	 ((sl: 'a_2283 Sequence.Slice.t, i: int32)) =>
	 case safe of
	   true =>
	   let val i: int64 =
		  (fromInt i)
		  handle x_1149 => case x_1149 of
				     Overflow => raise Subscript
	   in
	      (sub' ('a_2283) (sl, i))
	   end
	 | false => (unsafeSub ('a_2283) (sl, i)))
val rec ('a_2286, 'a_2285, 'a_2284)
   unsafeUpdate'Mk: ('a_2286 array * int64 * 'a_2285 -> 'a_2284)
		    -> 'a_2286 Sequence.Slice.t * int64 * 'a_2285 -> 'a_2284 = 
      (fn x_1150: 'a_2286 array * int64 * 'a_2285 -> 'a_2284 =>
       (fn x_1151: 'a_2286 Sequence.Slice.t * int64 * 'a_2285 =>
	case (x_1150, x_1151) of
	  (updateUnsafe: 'a_2286 array * int64 * 'a_2285 -> 'a_2284,
	   (T['a_2286] {seq = seq: 'a_2286 array, start = start: int64},
	    i: int64,
	    x: 'a_2285)) =>
	  (updateUnsafe (seq, (+? (start, i)), x))))
val rec ('a_2289, 'a_2288, 'a_2287)
   unsafeUpdateMk: ('a_2289 array * int64 * 'a_2288 -> 'a_2287)
		   -> 'a_2289 Sequence.Slice.t * int32 * 'a_2288 -> 'a_2287 = 
      (fn x_1152: 'a_2289 array * int64 * 'a_2288 -> 'a_2287 =>
       (fn x_1153: 'a_2289 Sequence.Slice.t * int32 * 'a_2288 =>
	case (x_1152, x_1153) of
	  (updateUnsafe: 'a_2289 array * int64 * 'a_2288 -> 'a_2287,
	   (sl: 'a_2289 Sequence.Slice.t, i: int32, x: 'a_2288)) =>
	  ((unsafeUpdate'Mk ('a_2289, 'a_2288, 'a_2287) updateUnsafe) (sl,
								       (fromIntUnsafe i),
								       x))))
val rec ('a_2292, 'a_2291, 'a_2290)
   update'Mk: ('a_2292 array * int64 * 'a_2291 -> 'a_2290)
	      -> 'a_2292 Sequence.Slice.t * int64 * 'a_2291 -> 'a_2290 = 
      (fn x_1154: 'a_2292 array * int64 * 'a_2291 -> 'a_2290 =>
       (fn x_1155: 'a_2292 Sequence.Slice.t * int64 * 'a_2291 =>
	case (x_1154, x_1155) of
	  (updateUnsafe: 'a_2292 array * int64 * 'a_2291 -> 'a_2290,
	   (sl: 'a_2292 Sequence.Slice.t as T['a_2292] {len = len: int64},
	    i: int64,
	    x: 'a_2291)) =>
	  case case safe of
		 true => (geu (i, len)) | false => false of
	    true => raise Subscript
	  | false =>
	    ((unsafeUpdate'Mk ('a_2292, 'a_2291, 'a_2290) updateUnsafe) (sl,
									 i,
									 x))))
val rec ('a_2295, 'a_2294, 'a_2293)
   updateMk: ('a_2295 array * int64 * 'a_2294 -> 'a_2293)
	     -> 'a_2295 Sequence.Slice.t * int32 * 'a_2294 -> 'a_2293 = 
      (fn x_1156: 'a_2295 array * int64 * 'a_2294 -> 'a_2293 =>
       (fn x_1157: 'a_2295 Sequence.Slice.t * int32 * 'a_2294 =>
	case (x_1156, x_1157) of
	  (updateUnsafe: 'a_2295 array * int64 * 'a_2294 -> 'a_2293,
	   (sl: 'a_2295 Sequence.Slice.t, i: int32, x: 'a_2294)) =>
	  case safe of
	    true =>
	    let val i: int64 =
		   (fromInt i)
		   handle x_1158 => case x_1158 of
				      Overflow => raise Subscript
	    in
	       ((update'Mk ('a_2295, 'a_2294, 'a_2293) updateUnsafe) (sl, i, x))
	    end
	  | false =>
	    ((unsafeUpdateMk ('a_2295, 'a_2294, 'a_2293) updateUnsafe) (sl, i, x))))
val rec 'a
   full: 'a array -> 'a Sequence.Slice.t = 
      (fn x_1159: 'a array =>
       case x_1159 of
	 (seq: 'a array) =>
	 (T['a] {seq = seq, start = 0x0, len = (length_4 ('a) seq)}))
val rec 'a_2296
   unsafeSubslice': 'a_2296 Sequence.Slice.t * int64 * int64 Primitive.Option.t
		    -> 'a_2296 Sequence.Slice.t = 
      (fn x_1160: 'a_2296 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1160 of
	 ((T['a_2296] {seq = seq: 'a_2296 array,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 (T['a_2296] {seq = seq,
		      start = (+? (start, start')),
		      len = case len' of
			      NONE[int64] => (-? (len, start'))
			    | SOME[int64] len': int64 => len'}))
val rec 'a_2297
   unsafeSubslice: 'a_2297 Sequence.Slice.t * int32 * int32 Primitive.Option.t
		   -> 'a_2297 Sequence.Slice.t = 
      (fn x_1161: 'a_2297 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1161 of
	 ((sl: 'a_2297 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 (unsafeSubslice' ('a_2297) (sl,
				     (fromIntUnsafe start),
				     ((map_0 (int64, int32) fromIntUnsafe) len))))
val rec 'a_2300
   subslice': 'a_2300 Sequence.Slice.t * int64 * int64 Primitive.Option.t
	      -> 'a_2300 Sequence.Slice.t = 
      (fn x_1162: 'a_2300 Sequence.Slice.t * int64 * int64 Primitive.Option.t =>
       case x_1162 of
	 ((T['a_2300] {seq = seq: 'a_2300 array,
		       start = start: int64,
		       len = len: int64},
	   start': int64,
	   len': int64 Primitive.Option.t)) =>
	 case len' of
	   NONE[int64] =>
	   case case safe of
		  true => (gtu (start', len)) | false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2300] {seq = seq,
			  start = (+? (start, start')),
			  len = (-? (len, start'))})
	 | SOME[int64] len': int64 =>
	   case case safe of
		  true =>
		  case (gtu (start', len)) of
		    true => true | false => (gtu (len', (-? (len, start'))))
		| false => false of
	     true => raise Subscript
	   | false =>
	     (T['a_2300] {seq = seq, start = (+? (start, start')), len = len'}))
val rec 'a_2301
   subslice: 'a_2301 Sequence.Slice.t * int32 * int32 Primitive.Option.t
	     -> 'a_2301 Sequence.Slice.t = 
      (fn x_1163: 'a_2301 Sequence.Slice.t * int32 * int32 Primitive.Option.t =>
       case x_1163 of
	 ((sl: 'a_2301 Sequence.Slice.t,
	   start: int32,
	   len: int32 Primitive.Option.t)) =>
	 case safe of
	   true =>
	   (subslice' ('a_2301) (sl,
				 (fromInt start),
				 ((map_0 (int64, int32) fromInt) len)))
	   handle x_1164 => case x_1164 of
			      Overflow => raise Subscript
	 | false => (unsafeSubslice ('a_2301) (sl, start, len)))
val rec 'a
   slice: 'a array * int32 * int32 Primitive.Option.t -> 'a Sequence.Slice.t = 
      (fn x_1165: 'a array * int32 * int32 Primitive.Option.t =>
       case x_1165 of
	 ((seq: 'a array, start: int32, len: int32 Primitive.Option.t)) =>
	 (subslice ('a) ((full ('a) seq), start, len)))
val rec ('a_2311, 'a_2310)
   foldri': (int64 * 'a_2311 * 'a_2310 -> 'a_2310)
	    -> 'a_2310 -> 'a_2311 Sequence.Slice.t -> 'a_2310 = 
      (fn x_1166: int64 * 'a_2311 * 'a_2310 -> 'a_2310 =>
       (fn x_1167: 'a_2310 =>
	(fn x_1168: 'a_2311 Sequence.Slice.t =>
	 case (x_1166, x_1167, x_1168) of
	   (f: int64 * 'a_2311 * 'a_2310 -> 'a_2310,
	    b: 'a_2310,
	    T['a_2311] {seq = seq: 'a_2311 array,
			start = start: int64,
			len = len: int64}) =>
	   let val min: int64 = start
	       val len: int64 = (-? (len, 0x1))
	       val max: int64 = (+? (start, len))
	       val rec
		  loop: int64 * 'a_2310 -> 'a_2310 = 
		     (fn x_1169: int64 * 'a_2310 =>
		      case x_1169 of
			((i: int64, b: 'a_2310)) =>
			case (< (i, min)) of
			  true => b
			| false =>
			  (loop ((-? (i, 0x1)),
				 (f ((-? (i, min)),
				     (subUnsafe_1 ('a_2311) (seq, i)),
				     b)))))
	   in
	      (loop (max, b))
	   end)))
val rec ('a_2313, 'a_2312)
   foldri: (int32 * 'a_2313 * 'a_2312 -> 'a_2312)
	   -> 'a_2312 -> 'a_2313 Sequence.Slice.t -> 'a_2312 = 
      (fn x_1170: int32 * 'a_2313 * 'a_2312 -> 'a_2312 =>
       (fn x_1171: 'a_2312 =>
	(fn x_1172: 'a_2313 Sequence.Slice.t =>
	 case (x_1170, x_1171, x_1172) of
	   (f: int32 * 'a_2313 * 'a_2312 -> 'a_2312,
	    b: 'a_2312,
	    sl: 'a_2313 Sequence.Slice.t) =>
	   (((foldri' ('a_2313, 'a_2312) (wrap3 ('a_2313, 'a_2312, 'a_2312) f)) b) sl))))
val rec ('a_2330, 'a_2329, 'a_2328)
   createi': (int64 * (int64 -> 'a_2329) -> 'a_2328)
	     -> (int64 * 'a_2330 -> 'a_2329)
		-> 'a_2330 Sequence.Slice.t -> 'a_2328 = 
      (fn x_1173: int64 * (int64 -> 'a_2329) -> 'a_2328 =>
       (fn x_1174: int64 * 'a_2330 -> 'a_2329 =>
	(fn x_1175: 'a_2330 Sequence.Slice.t =>
	 case (x_1173, x_1174, x_1175) of
	   (tabulate': int64 * (int64 -> 'a_2329) -> 'a_2328,
	    f: int64 * 'a_2330 -> 'a_2329,
	    T['a_2330] {seq = seq: 'a_2330 array,
			start = start: int64,
			len = len: int64}) =>
	   (tabulate' (len,
		       (fn x_1176: int64 =>
			case x_1176 of
			  i: int64 =>
			  (f (i, (subUnsafe_1 ('a_2330) (seq, (+? (start, i))))))))))))
val rec ('a_2333, 'a_2332, 'a_2331)
   createi: (int64 * (int64 -> 'a_2331) -> 'a_2333)
	    -> (int32 * 'a_2332 -> 'a_2331)
	       -> 'a_2332 Sequence.Slice.t -> 'a_2333 = 
      (fn x_1177: int64 * (int64 -> 'a_2331) -> 'a_2333 =>
       (fn x_1178: int32 * 'a_2332 -> 'a_2331 =>
	(fn x_1179: 'a_2332 Sequence.Slice.t =>
	 case (x_1177, x_1178, x_1179) of
	   (tabulate': int64 * (int64 -> 'a_2331) -> 'a_2333,
	    f: int32 * 'a_2332 -> 'a_2331,
	    sl: 'a_2332 Sequence.Slice.t) =>
	   (((createi' ('a_2332, 'a_2331, 'a_2333) tabulate') (wrap2 ('a_2332,
								      'a_2331) f)) sl))))
val rec ('a_2336, 'a_2335, 'a_2334)
   create: (int64 * (int64 -> 'a_2335) -> 'a_2336)
	   -> ('a_2334 -> 'a_2335) -> 'a_2334 Sequence.Slice.t -> 'a_2336 = 
      (fn x_1180: int64 * (int64 -> 'a_2335) -> 'a_2336 =>
       (fn x_1181: 'a_2334 -> 'a_2335 =>
	(fn x_1182: 'a_2334 Sequence.Slice.t =>
	 case (x_1180, x_1181, x_1182) of
	   (tabulate': int64 * (int64 -> 'a_2335) -> 'a_2336,
	    f: 'a_2334 -> 'a_2335,
	    sl: 'a_2334 Sequence.Slice.t) =>
	   (((createi ('a_2336, 'a_2334, 'a_2335) tabulate') (o_1 (int32
								   * 'a_2334,
								   'a_2335,
								   'a_2334) (f,
									     (fn x_1183: int32
											 * 'a_2334 =>
									      case x_1183 of
										{2 = #: 'a_2334} =>
										#)))) sl))))
val rec ('a_2372, 'a_2371)
   make: ('a_2372 Sequence.Slice.t -> 'a_2371) -> 'a_2372 array -> 'a_2371 = 
      (fn x_1184: 'a_2372 Sequence.Slice.t -> 'a_2371 =>
       (fn x_1185: 'a_2372 array =>
	case (x_1184, x_1185) of
	  (f: 'a_2372 Sequence.Slice.t -> 'a_2371, seq: 'a_2372 array) =>
	  (f (full ('a_2372) seq))))
val rec 'a_2376
   sub: 'a_2376 array * int32 -> 'a_2376 = 
      (fn x_1186: 'a_2376 array * int32 =>
       case x_1186 of
	 ((seq: 'a_2376 array, i: int32)) =>
	 (sub ('a_2376) ((full ('a_2376) seq), i)))
val rec ('a_2382, 'a_2381, 'a_2380)
   updateMk: ('a_2380 array * int64 * 'a_2382 -> 'a_2381)
	     -> 'a_2380 array * int32 * 'a_2382 -> 'a_2381 = 
      (fn x_1187: 'a_2380 array * int64 * 'a_2382 -> 'a_2381 =>
       (fn x_1188: 'a_2380 array * int32 * 'a_2382 =>
	case (x_1187, x_1188) of
	  (updateUnsafe: 'a_2380 array * int64 * 'a_2382 -> 'a_2381,
	   (seq: 'a_2380 array, i: int32, x: 'a_2382)) =>
	  ((updateMk ('a_2380, 'a_2382, 'a_2381) updateUnsafe) ((full ('a_2380) seq),
								i,
								x))))
val rec ('a_2412, 'a_2411)
   foldri: (int32 * 'a_2412 * 'a_2411 -> 'a_2411)
	   -> 'a_2411 -> 'a_2412 array -> 'a_2411 = 
      (fn x_1189: int32 * 'a_2412 * 'a_2411 -> 'a_2411 =>
       (fn x_1190: 'a_2411 =>
	case (x_1189, x_1190) of
	  (f: int32 * 'a_2412 * 'a_2411 -> 'a_2411, b: 'a_2411) =>
	  (make ('a_2412, 'a_2411) ((foldri ('a_2412, 'a_2411) f) b))))
val 'a updateMk_0: ('a array * int64 * 'a -> unit)
		   -> 'a array * int32 * 'a -> unit =
   updateMk ('a, unit, 'a)
val ('a, 'b) unfoldi_0: int32 * 'b * (int32 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi ('a, 'b)
val 'a tabulate_2: int32 * (int32 -> 'a) -> 'a array = tabulate ('a)
val 'a sub_2: 'a array * int32 -> 'a = sub ('a)
val 'a newUninit_0: int32 -> 'a array = newUninit ('a)
val 'a new_1: int32 * 'a -> 'a array = new ('a)
val 'a length_5: 'a array -> int32 = length ('a)
val ('b, 'a) foldri_0: (int32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b =
   foldri ('a, 'b)
val 'a slice_2: 'a array * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice ('a)
val ('a, 'c, 'b) create_0: (int64 * (int64 -> 'b) -> 'c)
			   -> ('a -> 'b) -> 'a Sequence.Slice.t -> 'c =
   create ('c, 'b, 'a)
val rec 'a_2462
   vector: 'a_2462 Sequence.Slice.t -> 'a_2462 vector = 
      (fn x_1191: 'a_2462 Sequence.Slice.t =>
       case x_1191 of
	 (sl: 'a_2462 Sequence.Slice.t) =>
	 (((create_0 ('a_2462, 'a_2462 vector, 'a_2462) tabulate'_1 ('a_2462)) (fn x_1192: 'a_2462 =>
										case x_1192 of
										  x: 'a_2462 =>
										  x)) sl))
val 'a_2478 arrayUninit: int32 -> 'a_2478 array = newUninit_0 ('a_2478)
val 'a_2480 array: int32 * 'a_2480 -> 'a_2480 array = new_1 ('a_2480)
val rec 'a_2481
   update: 'a_2481 array * int32 * 'a_2481 -> unit = 
      (fn x_1193: 'a_2481 array * int32 * 'a_2481 =>
       case x_1193 of
	 ((arr: 'a_2481 array, i: int32, x: 'a_2481)) =>
	 ((updateMk_0 ('a_2481) updateUnsafe ('a_2481)) (arr, i, x)))
val 'a update_0: 'a array * int32 * 'a -> unit = update ('a)
val ('a, 'b) unfoldi_1: int32 * 'b * (int32 * 'b -> 'a * 'b) -> 'a array * 'b =
   unfoldi_0 ('a, 'b)
val 'a tabulate_3: int32 * (int32 -> 'a) -> 'a array = tabulate_2 ('a)
val 'a sub_3: 'a array * int32 -> 'a = sub_2 ('a)
val 'a length_6: 'a array -> int32 = length_5 ('a)
val ('b, 'a) foldri_1: (int32 * 'a * 'b -> 'b) -> 'b -> 'a array -> 'b =
   foldri_0 ('b, 'a)
val 'a arrayUninit_0: int32 -> 'a array = arrayUninit ('a)
val 'a array_0: int32 * 'a -> 'a array = array ('a)
val 'a vector_2: 'a Sequence.Slice.t -> 'a vector = vector ('a)
val 'a slice_3: 'a array * int32 * int32 Primitive.Option.t
		-> 'a Sequence.Slice.t =
   slice_2 ('a)
datatype Array2.traversal = RowMajor
			    | ColMajor
val vector_3: int32 * char8 -> string = vector_0 (char8)
val unsafeFromArray_1: char8 array -> string = unsafeFromArray_0 (char8)
val translate_2: (char8 -> string) -> string -> string =
   translate_1 (char8, char8)
val tabulate_4: int32 * (int32 -> char8) -> string = tabulate_1 (char8)
val sub_4: string * int32 -> char8 = sub_1 (char8)
val length_7: string -> int32 = length_3 (char8)
val isPrefix_2: (char8 * char8 -> bool) -> string -> string -> bool =
   isPrefix_1 (char8)
val fromList_2: char8 list -> string = fromList_1 (char8)
val concat_2: string list -> string = concat_1 (char8)
val append_2: string * string -> string = append_1 (char8)
val vector_4: char8 Sequence.Slice.t -> string = vector_1 (char8)
val taker_2: (char8 -> bool) -> char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   taker_1 (char8)
val takel_2: (char8 -> bool) -> char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   takel_1 (char8)
val slice_4: string * int32 * int32 Primitive.Option.t -> char8 Sequence.Slice.t =
   slice_1 (char8)
val full_2: string -> char8 Sequence.Slice.t = full_1 (char8)
val dropr_2: (char8 -> bool) -> char8 Sequence.Slice.t -> char8 Sequence.Slice.t =
   dropr_1 (char8)
val 'a_2613 fromPoly: 'a_2613 -> 'a_2613 =
   (fn x_1194: 'a_2613 =>
    case x_1194 of
      a: 'a_2613 => a)
val update_1: char8 array * int32 * char8 -> unit = update_0 (char8)
val fromPoly_0: char8 array -> char8 array = fromPoly (char8 array)
val array_1: int32 * char8 -> char8 array = array_0 (char8)
val vector_5: char8 Sequence.Slice.t -> string = vector_2 (char8)
val slice_5: char8 array * int32 * int32 Primitive.Option.t
	     -> char8 Sequence.Slice.t =
   slice_3 (char8)
val size: string -> int32 = length_7
val implode: char8 list -> string = fromList_2
val fChar8: {chrUnsafe: int32 -> char8,
	     maxChar: char8,
	     minChar: char8,
	     numChars: int32,
	     ord: char8 -> int32} =
   {chrUnsafe = (o_1 (int32, char8, word8) (idFromWord8, sextdToWord8)),
    ord = (o_1 (char8, int32, word8) (zextdFromWord8, idToWord8)),
    minChar = 0x0,
    maxChar = 0xFF,
    numChars = 0x100}
val fChar16: {chrUnsafe: int32 -> char16,
	      maxChar: char16,
	      minChar: char16,
	      numChars: int32,
	      ord: char16 -> int32} =
   {chrUnsafe = (o_1 (int32, char16, word16) (idFromWord16, sextdToWord16)),
    ord = (o_1 (char16, int32, word16) (zextdFromWord16, idToWord16)),
    minChar = 0x0,
    maxChar = 0xFFFF,
    numChars = 0x10000}
val fChar32: {chrUnsafe: int32 -> char32,
	      maxChar: char32,
	      minChar: char32,
	      numChars: int32,
	      ord: char32 -> int32} =
   {chrUnsafe = (o_1 (int32, char32, word32) (idFromWord32, sextdToWord32)),
    ord = (o_1 (char32, int32, word32) (zextdFromWord32, idToWord32)),
    minChar = 0x0,
    maxChar = 0x10FFFF,
    numChars = 0x110000}
val f: {chrUnsafe: int32 -> char8,
	maxChar: char8,
	minChar: char8,
	numChars: int32,
	ord: char8 -> int32} =
   fChar8
val _ = fChar16
val _ = fChar32
val {chrUnsafe = chrUnsafe: int32 -> char8,
     ord = ord: char8 -> int32,
     minChar = minChar: char8,
     maxChar = maxChar: char8,
     numChars = numChars: int32} =
   f
val _ = fChar8
val _ = fChar16
val rec ('b, 'a)
   readerN: ('b -> ('a * 'b) Primitive.Option.t) * int32
	    -> 'b -> ('a list * 'b) Primitive.Option.t = 
      (fn x_1195: ('b -> ('a * 'b) Primitive.Option.t) * int32 =>
       case x_1195 of
	 ((reader: 'b -> ('a * 'b) Primitive.Option.t, n: int32)) =>
	 (fn x_1196: 'b =>
	  case x_1196 of
	    state: 'b =>
	    let val rec
		   loop: int32 * 'b * 'a list
			 -> ('a list * 'b) Primitive.Option.t = 
		      (fn x_1197: int32 * 'b * 'a list =>
		       case x_1197 of
			 ((n: int32, state: 'b, accum: 'a list)) =>
			 case (<= (n, 0x0)) of
			   true =>
			   (SOME['a list * 'b] ((rev_1 ('a) accum), state))
			 | false =>
			   case (reader state) of
			     NONE['a * 'b] => NONE['a list * 'b]
			   | SOME['a * 'b] (x: 'a, state: 'b) =>
			     (loop ((- (n, 0x1)), state, (::['a] (x, accum)))))
	    in
	       (loop (n, state, []))
	    end))
val rec ('a_2663, 'a_2662)
   ignore: ('a_2663 -> bool)
	   -> ('a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t)
	      -> 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t = 
      (fn x_1198: 'a_2663 -> bool =>
       (fn x_1199: 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t =>
	case (x_1198, x_1199) of
	  (f: 'a_2663 -> bool,
	   reader: 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t) =>
	  let val rec
		 loop: 'a_2662 -> ('a_2663 * 'a_2662) Primitive.Option.t = 
		    (fn x_1200: 'a_2662 =>
		     case x_1200 of
		       (state: 'a_2662) =>
		       case (reader state) of
			 NONE['a_2663 * 'a_2662] => NONE['a_2663 * 'a_2662]
		       | SOME['a_2663 * 'a_2662] (x: 'a_2663, state: 'a_2662) =>
			 case (f x) of
			   true => (loop state)
			 | false => (SOME['a_2663 * 'a_2662] (x, state)))
	  in
	     loop
	  end))
val ('a_2665, 'a_2664) _ = ignore ('a_2665, 'a_2664)
val rec ('b, 'c, 'a)
   map: ('a -> 'c)
	-> ('b -> ('a * 'b) Primitive.Option.t)
	   -> 'b -> ('c * 'b) Primitive.Option.t = 
      (fn x_1201: 'a -> 'c =>
       (fn x_1202: 'b -> ('a * 'b) Primitive.Option.t =>
	case (x_1201, x_1202) of
	  (f: 'a -> 'c, reader: 'b -> ('a * 'b) Primitive.Option.t) =>
	  (fn x_1203: 'b =>
	   case x_1203 of
	     b: 'b =>
	     case (reader b) of
	       NONE['a * 'b] => NONE['c * 'b]
	     | SOME['a * 'b] (a: 'a, b: 'b) => (SOME['c * 'b] ((f a), b)))))
val rec ('a_2667, 'a_2666)
   reader2: ('a_2667 -> ('a_2666 * 'a_2667) Primitive.Option.t)
	    -> 'a_2667 -> (('a_2666 * 'a_2666) * 'a_2667) Primitive.Option.t = 
      (fn x_1204: 'a_2667 -> ('a_2666 * 'a_2667) Primitive.Option.t =>
       case x_1204 of
	 (reader: 'a_2667 -> ('a_2666 * 'a_2667) Primitive.Option.t) =>
	 ((map ('a_2667, 'a_2666 * 'a_2666, 'a_2666 list) (fn x_1205: 'a_2666 list =>
							   case x_1205 of
							     [y: 'a_2666,
							      z: 'a_2666] =>
							     (y, z)
							   | _ =>
							     raise (Fail "Reader.reader2"))) (readerN ('a_2667,
												       'a_2666) (reader,
														 0x2))))
val ('a_2669, 'a_2668) _ = reader2 ('a_2669, 'a_2668)
datatype StringCvt.radix = BIN
			   | OCT
			   | DEC
			   | HEX
val radixToInt: StringCvt.radix -> int32 =
   (fn x_1206: StringCvt.radix =>
    case x_1206 of
      BIN => 0x2 | OCT => 0x8 | DEC => 0xA | HEX => 0x10)
datatype StringCvt.realfmt = SCI of int32 Primitive.Option.t
			     | FIX of int32 Primitive.Option.t
			     | GEN of int32 Primitive.Option.t
			     | EXACT
val rec 'a_2676
   splitl: (char8 -> bool)
	   -> ('a_2676 -> (char8 * 'a_2676) Primitive.Option.t)
	      -> 'a_2676 -> string * 'a_2676 = 
      (fn x_1207: char8 -> bool =>
       (fn x_1208: 'a_2676 -> (char8 * 'a_2676) Primitive.Option.t =>
	(fn x_1209: 'a_2676 =>
	 case (x_1207, x_1208, x_1209) of
	   (p: char8 -> bool,
	    f: 'a_2676 -> (char8 * 'a_2676) Primitive.Option.t,
	    src: 'a_2676) =>
	   let val rec
		  done: char8 list -> string = 
		     (fn x_1211: char8 list =>
		      case x_1211 of
			(chars: char8 list) => (implode (rev_1 (char8) chars)))
	       val rec
		  loop: 'a_2676 * char8 list -> string * 'a_2676 = 
		     (fn x_1210: 'a_2676 * char8 list =>
		      case x_1210 of
			((src: 'a_2676, chars: char8 list)) =>
			case (f src) of
			  NONE[char8 * 'a_2676] => ((done chars), src)
			| SOME[char8 * 'a_2676] (c: char8, src': 'a_2676) =>
			  case (p c) of
			    true => (loop (src', (::[char8] (c, chars))))
			  | false => ((done chars), src))
	   in
	      (loop (src, []))
	   end)))
val rec 'a_2678
   dropl: (char8 -> bool)
	  -> ('a_2678 -> (char8 * 'a_2678) Primitive.Option.t)
	     -> 'a_2678 -> 'a_2678 = 
      (fn x_1212: char8 -> bool =>
       (fn x_1213: 'a_2678 -> (char8 * 'a_2678) Primitive.Option.t =>
	(fn x_1214: 'a_2678 =>
	 case (x_1212, x_1213, x_1214) of
	   (p: char8 -> bool,
	    f: 'a_2678 -> (char8 * 'a_2678) Primitive.Option.t,
	    s: 'a_2678) =>
	   ((fn x_1215: string * 'a_2678 =>
	     case x_1215 of
	       {2 = #: 'a_2678} => #) (((splitl ('a_2678) p) f) s)))))
val rec
   stringReader: string -> int32 -> (char8 * int32) Primitive.Option.t = 
      (fn x_1216: string =>
       case x_1216 of
	 (s: string) =>
	 (fn x_1217: int32 =>
	  case x_1217 of
	    i: int32 =>
	    case (>= (i, (size s))) of
	      true => NONE[char8 * int32]
	    | false => (SOME[char8 * int32] ((sub_4 (s, i)), (+ (i, 0x1))))))
val rec 'a
   scanString: ((int32 -> (char8 * int32) Primitive.Option.t)
		-> int32 -> ('a * int32) Primitive.Option.t)
	       -> string -> 'a Primitive.Option.t = 
      (fn x_1218: (int32 -> (char8 * int32) Primitive.Option.t)
		  -> int32 -> ('a * int32) Primitive.Option.t =>
       (fn x_1219: string =>
	case (x_1218, x_1219) of
	  (f: (int32 -> (char8 * int32) Primitive.Option.t)
	      -> int32 -> ('a * int32) Primitive.Option.t,
	   s: string) =>
	  case ((f (stringReader s)) 0x0) of
	    NONE['a * int32] => NONE['a]
	  | SOME['a * int32] (a: 'a, _) => (SOME['a] a)))
val rec 'a
   memoize: (char8 -> 'a) -> char8 -> 'a = 
      (fn x_1220: char8 -> 'a =>
       case x_1220 of
	 (f: char8 -> 'a) =>
	 let val a: 'a array =
		(tabulate_3 ('a) (numChars,
				  (o_1 (int32, 'a, char8) (f, chrUnsafe))))
	 in
	    (fn x_1221: char8 =>
	     case x_1221 of
	       c: char8 => (sub_3 ('a) (a, (ord c))))
	 end)
val rec
   range: int32 * char8 * char8 -> char8 -> int32 Primitive.Option.t = 
      (fn x_1222: int32 * char8 * char8 =>
       case x_1222 of
	 ((add: int32, cmin: char8, cmax: char8)) =>
	 let val min: int32 = (ord cmin)
	 in
	    (fn x_1223: char8 =>
	     case x_1223 of
	       c: char8 =>
	       case case (<= (cmin, c)) of
		      true => (<= (c, cmax)) | false => false of
		 true => (SOME[int32] (-? ((+? (add, (ord c))), min)))
	       | false => NONE[int32])
	 end)
val rec 'a
   combine: (char8 -> 'a Primitive.Option.t) list
	    -> char8 -> 'a Primitive.Option.t = 
      (fn x_1224: (char8 -> 'a Primitive.Option.t) list =>
       case x_1224 of
	 (ds: (char8 -> 'a Primitive.Option.t) list) =>
	 (memoize ('a Primitive.Option.t) (fn x_1225: char8 =>
					   case x_1225 of
					     c: char8 =>
					     let val rec 'a_2679
						    loop: (char8
							   -> 'a_2679 Primitive.Option.t) list
							  -> 'a_2679 Primitive.Option.t = 
						       (fn x_1226: (char8
								    -> 'a_2679 Primitive.Option.t) list =>
							case x_1226 of
							  [] => NONE['a_2679]
							| ::[char8
							     -> 'a_2679 Primitive.Option.t] (d: char8
												-> 'a_2679 Primitive.Option.t,
											     ds: (char8
												  -> 'a_2679 Primitive.Option.t) list) =>
							  case (d c) of
							    NONE['a_2679] =>
							    (loop ('a_2679) ds)
							  | z: 'a_2679 Primitive.Option.t =>
							    z)
					     in
						(loop ('a) ds)
					     end)))
val bin: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x31)))
val oct: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x37)))
val dec: char8 -> int32 Primitive.Option.t =
   (memoize (int32 Primitive.Option.t) (range (0x0, 0x30, 0x39)))
val hex: char8 -> int32 Primitive.Option.t =
   (combine (int32) [(range (0x0, 0x30, 0x39)),
		     (range (0xA, 0x61, 0x66)),
		     (range (0xA, 0x41, 0x46))])
val rec
   isSpace: char8 -> bool = 
      (fn x_1227: char8 =>
       case x_1227 of
	 (c: char8) =>
	 case case case case case (= (char8) (c, 0x20)) of
			       true => true | false => (= (char8) (c, 0x9)) of
			  true => true | false => (= (char8) (c, 0xD)) of
		     true => true | false => (= (char8) (c, 0xA)) of
		true => true | false => (= (char8) (c, 0xB)) of
	   true => true | false => (= (char8) (c, 0xC)))
val isSpace: char8 -> bool = (memoize (bool) isSpace)
val rec 'a_2680
   skipWS: ('a_2680 -> (char8 * 'a_2680) Primitive.Option.t)
	   -> 'a_2680 -> 'a_2680 = 
      (fn x_1228: 'a_2680 -> (char8 * 'a_2680) Primitive.Option.t =>
       case x_1228 of
	 (x: 'a_2680 -> (char8 * 'a_2680) Primitive.Option.t) =>
	 ((dropl ('a_2680) isSpace) x))
val rec
   charToDigit: StringCvt.radix -> char8 -> int32 Primitive.Option.t = 
      (fn x_1229: StringCvt.radix =>
       case x_1229 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => bin | OCT => oct | DEC => dec | HEX => hex)
val rec
   digitToChar: int32 -> char8 = 
      (fn x_1230: int32 =>
       case x_1230 of
	 (n: int32) => (sub_4 ("0123456789ABCDEF", n)))
val 'a skipWS_0: ('a -> (char8 * 'a) Primitive.Option.t) -> 'a -> 'a =
   skipWS ('a)
val 'a scanString_0: ((int32 -> (char8 * int32) Primitive.Option.t)
		      -> int32 -> ('a * int32) Primitive.Option.t)
		     -> string -> 'a Primitive.Option.t =
   scanString ('a)
val not: bool -> bool = not
val precision': int32 = (zextdToInt sizeInBits)
val precision': int32 = (zextdToInt sizeInBits)
val precision': int32 = (zextdToInt sizeInBits)
val fromInt: int32 -> int32 = schckFromInt
val toInt: int32 -> int32 = schckToInt
val maxNumDigits: int32 = (+ (precision', 0x1))
val oneBuf: char8 array One.t =
   (make_0 (char8 array) (fn x_1231: unit =>
			  case x_1231 of
			    () => (array_1 (maxNumDigits, 0x0))))
val rec
   fmt: StringCvt.radix -> int32 -> string = 
      (fn x_1232: StringCvt.radix =>
       (fn x_1233: int32 =>
	case (x_1232, x_1233) of
	  (radix: StringCvt.radix, n: int32) =>
	  (use_0 (string, char8 array) (oneBuf,
					(fn x_1234: char8 array =>
					 case x_1234 of
					   buf: char8 array =>
					   let val radix: int32 =
						  (fromInt (radixToInt radix))
					       val rec
						  loop: int32 * int32 -> string = 
						     (fn x_1235: int32 * int32 =>
						      case x_1235 of
							((q: int32, i: int32)) =>
							let val _ =
							       (update_1 (buf,
									  i,
									  (digitToChar (toInt (~? (rem (q,
													radix)))))))
							    val q: int32 =
							       (quot (q, radix))
							in
							   case (= (int32) (q,
									    zero)) of
							     true =>
							     let val start: int32 =
								    case (< (n,
									     zero)) of
								      true =>
								      let val i: int32 =
									     (- (i,
										 0x1))
									  val () =
									     (update_1 (buf,
											i,
											0x7E))
								      in
									 i
								      end
								    | false => i
							     in
								(vector_5 (slice_5 (buf,
										    start,
										    NONE[int32])))
							     end
							   | false =>
							     (loop (q,
								    (- (i, 0x1))))
							end)
					   in
					      (loop (case (< (n, zero)) of
						       true => n
						     | false => (~? n),
						     (- (maxNumDigits, 0x1))))
					   end)))))
val toString: int32 -> string = (fmt DEC)
val rec 'a_2692
   scan: StringCvt.radix
	 -> ('a_2692 -> (char8 * 'a_2692) Primitive.Option.t)
	    -> 'a_2692 -> (int32 * 'a_2692) Primitive.Option.t = 
      (fn x_1236: StringCvt.radix =>
       (fn x_1237: 'a_2692 -> (char8 * 'a_2692) Primitive.Option.t =>
	(fn x_1238: 'a_2692 =>
	 case (x_1236, x_1237, x_1238) of
	   (radix: StringCvt.radix,
	    reader: 'a_2692 -> (char8 * 'a_2692) Primitive.Option.t,
	    s: 'a_2692) =>
	   let val s: 'a_2692 = ((skipWS_0 ('a_2692) reader) s)
	       val rec
		  charToDigit: char8 -> int32 Primitive.Option.t = 
		     (fn x_1242: char8 =>
		      case x_1242 of
			(c: char8) =>
			case ((charToDigit radix) c) of
			  NONE[int32] => NONE[int32]
			| SOME[int32] n: int32 => (SOME[int32] (fromInt n)))
	       val radixInt: int32 = (fromInt (radixToInt radix))
	       val rec
		  finishNum: 'a_2692 * int32
			     -> (int32 * 'a_2692) Primitive.Option.t = 
		     (fn x_1241: 'a_2692 * int32 =>
		      case x_1241 of
			((s: 'a_2692, n: int32)) =>
			case (reader s) of
			  NONE[char8 * 'a_2692] =>
			  (SOME[int32 * 'a_2692] (n, s))
			| SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
			  case (charToDigit c) of
			    NONE[int32] => (SOME[int32 * 'a_2692] (n, s))
			  | SOME[int32] n': int32 =>
			    (finishNum (s', (- ((* (n, radixInt)), n')))))
	       val rec
		  num: 'a_2692 -> (int32 * 'a_2692) Primitive.Option.t = 
		     (fn x_1240: 'a_2692 =>
		      case x_1240 of
			(s: 'a_2692) =>
			case ((reader s), radix) of
			  (NONE[char8 * 'a_2692], _) => NONE[int32 * 'a_2692]
			| (SOME[char8 * 'a_2692] (0x30, s: 'a_2692), HEX) =>
			  case (reader s) of
			    NONE[char8 * 'a_2692] =>
			    (SOME[int32 * 'a_2692] (zero, s))
			  | SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
			    case case (= (char8) (c, 0x78)) of
				   true => true | false => (= (char8) (c, 0x58)) of
			      true =>
			      case (reader s') of
				NONE[char8 * 'a_2692] =>
				(SOME[int32 * 'a_2692] (zero, s))
			      | SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
				case (charToDigit c) of
				  NONE[int32] =>
				  (SOME[int32 * 'a_2692] (zero, s))
				| SOME[int32] n: int32 =>
				  (finishNum (s', (~? n)))
			    | false =>
			      case (charToDigit c) of
				NONE[int32] => (SOME[int32 * 'a_2692] (zero, s))
			      | SOME[int32] n: int32 => (finishNum (s', (~? n)))
			| (SOME[char8 * 'a_2692] (c: char8, s: 'a_2692), _) =>
			  case (charToDigit c) of
			    NONE[int32] => NONE[int32 * 'a_2692]
			  | SOME[int32] n: int32 => (finishNum (s, (~? n))))
	       val rec
		  negate: 'a_2692 -> (int32 * 'a_2692) Primitive.Option.t = 
		     (fn x_1239: 'a_2692 =>
		      case x_1239 of
			(s: 'a_2692) =>
			case (num s) of
			  NONE[int32 * 'a_2692] => NONE[int32 * 'a_2692]
			| SOME[int32 * 'a_2692] (n: int32, s: 'a_2692) =>
			  (SOME[int32 * 'a_2692] ((~ n), s)))
	   in
	      case (reader s) of
		NONE[char8 * 'a_2692] => NONE[int32 * 'a_2692]
	      | SOME[char8 * 'a_2692] (c: char8, s': 'a_2692) =>
		case c of
		  0x7E => (num s')
		| 0x2D => (num s') | 0x2B => (negate s') | _ => (negate s)
	   end)))
val fromString: string -> int32 Primitive.Option.t =
   (scanString_0 (int32) (scan (int32) DEC))
val precision': int32 = (zextdToInt sizeInBits)
val fromInt: int32 -> int64 = schckFromInt
val toInt: int64 -> int32 = schckToInt
val maxNumDigits: int32 = (+ (precision', 0x1))
val oneBuf: char8 array One.t =
   (make_0 (char8 array) (fn x_1243: unit =>
			  case x_1243 of
			    () => (array_1 (maxNumDigits, 0x0))))
val rec
   fmt: StringCvt.radix -> int64 -> string = 
      (fn x_1244: StringCvt.radix =>
       (fn x_1245: int64 =>
	case (x_1244, x_1245) of
	  (radix: StringCvt.radix, n: int64) =>
	  (use_0 (string, char8 array) (oneBuf,
					(fn x_1246: char8 array =>
					 case x_1246 of
					   buf: char8 array =>
					   let val radix: int64 =
						  (fromInt (radixToInt radix))
					       val rec
						  loop: int64 * int32 -> string = 
						     (fn x_1247: int64 * int32 =>
						      case x_1247 of
							((q: int64, i: int32)) =>
							let val _ =
							       (update_1 (buf,
									  i,
									  (digitToChar (toInt (~? (rem (q,
													radix)))))))
							    val q: int64 =
							       (quot (q, radix))
							in
							   case (= (int64) (q,
									    zero)) of
							     true =>
							     let val start: int32 =
								    case (< (n,
									     zero)) of
								      true =>
								      let val i: int32 =
									     (- (i,
										 0x1))
									  val () =
									     (update_1 (buf,
											i,
											0x7E))
								      in
									 i
								      end
								    | false => i
							     in
								(vector_5 (slice_5 (buf,
										    start,
										    NONE[int32])))
							     end
							   | false =>
							     (loop (q,
								    (- (i, 0x1))))
							end)
					   in
					      (loop (case (< (n, zero)) of
						       true => n
						     | false => (~? n),
						     (- (maxNumDigits, 0x1))))
					   end)))))
val wordSize: int32 = (zextdToInt sizeInBits)
val wordSize: int32 = (zextdToInt sizeInBits)
val wordSize: int32 = (zextdToInt sizeInBits)
val rec
   st: word32 * word32 * word32 -> word32 * word32 * word32 = 
      (fn x_1248: word32 * word32 * word32 =>
       case x_1248 of
	 ((w: word32, msk: word32, sft: word32)) =>
	 let val odd: word32 = (andb (w, msk))
	     val evn: word32 = (xorb (w, odd))
	 in
	    ((xorb ((<<? (odd, sft)), (>>? (evn, sft)))),
	     (xorb (msk, (<<? (msk, (>>? (sft, 0x1)))))),
	     (>>? (sft, 0x1)))
	 end)
val (f: word32 * word32 * word32 -> word32 * word32 * word32, sft: word32) =
   case sizeInBitsWord of
     0x8 =>
     ((fn x_1249: word32 * word32 * word32 =>
       case x_1249 of
	 x: word32 * word32 * word32 => x),
      0x4)
   | 0x10 => (st, 0x8)
   | 0x20 =>
     ((o_1 (word32 * word32 * word32,
	    word32 * word32 * word32,
	    word32 * word32 * word32) (st, st)),
      0x10)
   | 0x40 =>
     ((o_1 (word32 * word32 * word32,
	    word32 * word32 * word32,
	    word32 * word32 * word32) ((o_1 (word32 * word32 * word32,
				 word32 * word32 * word32,
				 word32 * word32 * word32) (st, st)),
			   st)),
      0x20)
   | _ => raise (Fail "Word.bswap")
val rec
   bswap: word32 -> word32 = 
      (fn x_1250: word32 =>
       case x_1250 of
	 (w: word32) =>
	 ((fn x_1251: word32 * word32 * word32 =>
	   case x_1251 of
	     {1 = #: word32} => #) (f (w, (- ((<<? (one, sft)), one)), sft))))
val rec
   toInt: word32 -> int32 = 
      (fn x_1252: word32 =>
       case x_1252 of
	 (w: word32) =>
	 let val i: int32 = (zchckToInt w)
	 in
	    case case case detectOverflow of
			true =>
			case precision of
			  NONE[int32] => false
			| SOME[int32] precision: int32 =>
			  (<= (precision, sizeInBits))
		      | false => false of
		   true => (< (i, 0x0)) | false => false of
	      true => raise Overflow | false => i
	 end)
val wordSize: int32 = (zextdToInt sizeInBits)
val fromInt: int32 -> word64 = sextdFromInt
val binCvt: intInf -> string = (mkCvt {base = 0x2, smallCvt = (fmt BIN)})
val octCvt: intInf -> string = (mkCvt {base = 0x8, smallCvt = (fmt OCT)})
val decCvt: intInf -> string = (mkCvt {base = 0xA, smallCvt = (fmt DEC)})
val hexCvt: intInf -> string = (mkCvt {base = 0x10, smallCvt = (fmt HEX)})
val rec
   fmt: StringCvt.radix -> intInf -> string = 
      (fn x_1253: StringCvt.radix =>
       case x_1253 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => binCvt | OCT => octCvt | DEC => decCvt | HEX => hexCvt)
val toString: intInf -> string = (fmt DEC)
val rec
   binDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1254: char8 =>
       case x_1254 of
	 (ch: char8) =>
	 case ch of
	   0x30 => (SOME[word64] 0x0)
	 | 0x31 => (SOME[word64] 0x1) | _ => NONE[word64])
val <=: char8 * char8 -> bool = <=
val rec
   octDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1255: char8 =>
       case x_1255 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x37)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false => NONE[word64])
val rec
   decDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1256: char8 =>
       case x_1256 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x39)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false => NONE[word64])
val rec
   hexDig: char8 -> word64 Primitive.Option.t = 
      (fn x_1257: char8 =>
       case x_1257 of
	 (ch: char8) =>
	 case case (<= (0x30, ch)) of
		true => (<= (ch, 0x39)) | false => false of
	   true => (SOME[word64] (fromInt (- ((ord ch), (ord 0x30)))))
	 | false =>
	   case case (<= (0x61, ch)) of
		  true => (<= (ch, 0x66)) | false => false of
	     true =>
	     (SOME[word64] (fromInt (- ((ord ch), (- ((ord 0x61), 0xA))))))
	   | false =>
	     case case (<= (0x41, ch)) of
		    true => (<= (ch, 0x46)) | false => false of
	       true =>
	       (SOME[word64] (fromInt (- ((ord ch), (- ((ord 0x41), 0xA))))))
	     | false => NONE[word64])
val rec 'a
   toDigR: (char8 -> word64 Primitive.Option.t)
	   * ('a -> (char8 * 'a) Primitive.Option.t)
	   -> 'a -> (word64 * 'a) Primitive.Option.t = 
      (fn x_1258: (char8 -> word64 Primitive.Option.t)
		  * ('a -> (char8 * 'a) Primitive.Option.t) =>
       (fn x_1259: 'a =>
	case (x_1258, x_1259) of
	  ((charToDig: char8 -> word64 Primitive.Option.t,
	    cread: 'a -> (char8 * 'a) Primitive.Option.t),
	   s: 'a) =>
	  case (cread s) of
	    NONE[char8 * 'a] => NONE[word64 * 'a]
	  | SOME[char8 * 'a] (ch: char8, s': 'a) =>
	    case (charToDig ch) of
	      NONE[word64] => NONE[word64 * 'a]
	    | SOME[word64] dig: word64 => (SOME[word64 * 'a] (dig, s'))))
val rec 'a
   toChunkR: word64 * ('a -> (word64 * 'a) Primitive.Option.t)
	     -> 'a
		-> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t = 
      (fn x_1260: word64 * ('a -> (word64 * 'a) Primitive.Option.t) =>
       case x_1260 of
	 ((base: word64, dread: 'a -> (word64 * 'a) Primitive.Option.t)) =>
	 let val rec
		loop: {chunk: word64, left: int32, s: 'a, shift: word64}
		      -> {chunk: word64, more: bool, shift: word64} * 'a = 
		   (fn x_1262: {chunk: word64, left: int32, s: 'a, shift: word64} =>
		    case x_1262 of
		      ({left = left: int32,
			shift = shift: word64,
			chunk = chunk: word64,
			s = s: 'a}) =>
		      case (<= (left, 0x0)) of
			true => ({more = true, shift = shift, chunk = chunk}, s)
		      | false =>
			case (dread s) of
			  NONE[word64 * 'a] =>
			  ({more = false, shift = shift, chunk = chunk}, s)
			| SOME[word64 * 'a] (dig: word64, s': 'a) =>
			  (loop {left = (- (left, 0x1)),
				 shift = (* (base, shift)),
				 chunk = (+ ((* (base, chunk)), dig)),
				 s = s'}))
	     val digitsPerChunk: int32 =
		case (wordSize, base) of
		  (0x40, 0x10) => 0xF
		| (0x40, 0xA) => 0x12
		| (0x40, 0x8) => 0x14
		| (0x40, 0x2) => 0x3D
		| (0x20, 0x10) => 0x7
		| (0x20, 0xA) => 0x8
		| (0x20, 0x8) => 0x9
		| (0x20, 0x2) => 0x1D
		| _ => raise (Fail "IntInf.scan:digitsPerChunk")
	     val rec
		reader: 'a
			-> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t = 
		   (fn x_1261: 'a =>
		    case x_1261 of
		      (s: 'a) =>
		      case (dread s) of
			NONE[word64 * 'a] =>
			NONE[{chunk: word64, more: bool, shift: word64} * 'a]
		      | SOME[word64 * 'a] (dig: word64, next: 'a) =>
			(SOME[{chunk: word64, more: bool, shift: word64} * 'a] (loop {left = (- (digitsPerChunk,
												 0x1)),
										      shift = base,
										      chunk = dig,
										      s = next})))
	 in
	    reader
	 end)
val rec 'a
   toUnsR: ('a
	    -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1263: 'a
		  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t =>
       case x_1263 of
	 (ckread: 'a
		  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t) =>
	 let val rec
		loop: bool * intInf * 'a -> intInf * 'a = 
		   (fn x_1265: bool * intInf * 'a =>
		    case x_1265 of
		      ((more: bool, acc: intInf, s: 'a)) =>
		      case more of
			true =>
			case (ckread s) of
			  NONE[{chunk: word64, more: bool, shift: word64} * 'a] =>
			  (acc, s)
			| SOME[{chunk: word64, more: bool, shift: word64} * 'a] ({more = more: bool,
										  shift = shift: word64,
										  chunk = chunk: word64},
										 s': 'a) =>
			  (loop (more,
				 (+ ((* ((addTagCoerce shift), acc)),
				     (addTagCoerce chunk))),
				 s'))
		      | false => (acc, s))
	     val rec
		reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		   (fn x_1264: 'a =>
		    case x_1264 of
		      (s: 'a) =>
		      case (ckread s) of
			NONE[{chunk: word64, more: bool, shift: word64} * 'a] =>
			NONE[intInf * 'a]
		      | SOME[{chunk: word64, more: bool, shift: word64} * 'a] ({more = more: bool,
										chunk = chunk: word64},
									       s': 'a) =>
			(SOME[intInf * 'a] (loop (more, (addTagCoerce chunk), s'))))
	 in
	    reader
	 end)
val rec 'a
   toHexR: ('a -> (char8 * 'a) Primitive.Option.t)
	   * ('a -> (intInf * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1266: ('a -> (char8 * 'a) Primitive.Option.t)
		  * ('a -> (intInf * 'a) Primitive.Option.t) =>
       (fn x_1267: 'a =>
	case (x_1266, x_1267) of
	  ((cread: 'a -> (char8 * 'a) Primitive.Option.t,
	    uread: 'a -> (intInf * 'a) Primitive.Option.t),
	   s: 'a) =>
	  case (cread s) of
	    NONE[char8 * 'a] => NONE[intInf * 'a]
	  | SOME[char8 * 'a] (c1: char8, s1: 'a) =>
	    case (= (char8) (c1, 0x30)) of
	      true =>
	      case (cread s1) of
		NONE[char8 * 'a] => (SOME[intInf * 'a] (zero, s1))
	      | SOME[char8 * 'a] (c2: char8, s2: 'a) =>
		case case (= (char8) (c2, 0x78)) of
		       true => true | false => (= (char8) (c2, 0x58)) of
		  true =>
		  case (uread s2) of
		    NONE[intInf * 'a] => (SOME[intInf * 'a] (zero, s1))
		  | SOME[intInf * 'a] x: intInf * 'a => (SOME[intInf * 'a] x)
		| false => (uread s)
	    | false => (uread s)))
val rec 'a
   toSign: ('a -> (char8 * 'a) Primitive.Option.t)
	   * ('a -> (intInf * 'a) Primitive.Option.t)
	   -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1268: ('a -> (char8 * 'a) Primitive.Option.t)
		  * ('a -> (intInf * 'a) Primitive.Option.t) =>
       case x_1268 of
	 ((cread: 'a -> (char8 * 'a) Primitive.Option.t,
	   uread: 'a -> (intInf * 'a) Primitive.Option.t)) =>
	 let val rec
		reader: 'a -> (intInf * 'a) Primitive.Option.t = 
		   (fn x_1269: 'a =>
		    case x_1269 of
		      (s: 'a) =>
		      let val s: 'a = ((skipWS_0 ('a) cread) s)
		      in
			 case (cread s) of
			   NONE[char8 * 'a] => NONE[intInf * 'a]
			 | SOME[char8 * 'a] (ch: char8, s': 'a) =>
			   let val (isNeg: bool, s'': 'a) =
				  case ch of
				    0x2B => (false, s')
				  | 0x2D => (true, s')
				  | 0x7E => (true, s')
				  | _ => (false, s)
			   in
			      case isNeg of
				true =>
				case (uread s'') of
				  NONE[intInf * 'a] => NONE[intInf * 'a]
				| SOME[intInf * 'a] (abs: intInf, s''': 'a) =>
				  (SOME[intInf * 'a] ((~ abs), s'''))
			      | false => (uread s'')
			   end
		      end)
	 in
	    reader
	 end)
val rec 'a
   reader: word64 * (char8 -> word64 Primitive.Option.t)
	   -> ('a -> (char8 * 'a) Primitive.Option.t)
	      -> 'a -> (intInf * 'a) Primitive.Option.t = 
      (fn x_1270: word64 * (char8 -> word64 Primitive.Option.t) =>
       (fn x_1271: 'a -> (char8 * 'a) Primitive.Option.t =>
	case (x_1270, x_1271) of
	  ((base: word64, dig: char8 -> word64 Primitive.Option.t),
	   cread: 'a -> (char8 * 'a) Primitive.Option.t) =>
	  let val dread: 'a -> (word64 * 'a) Primitive.Option.t =
		 (toDigR ('a) (dig, cread))
	      val ckread: 'a
			  -> ({chunk: word64, more: bool, shift: word64} * 'a) Primitive.Option.t =
		 (toChunkR ('a) (base, dread))
	      val uread: 'a -> (intInf * 'a) Primitive.Option.t =
		 (toUnsR ('a) ckread)
	      val hread: 'a -> (intInf * 'a) Primitive.Option.t =
		 case (= (word64) (base, 0x10)) of
		   true => (toHexR ('a) (cread, uread)) | false => uread
	      val reader: 'a -> (intInf * 'a) Primitive.Option.t =
		 (toSign ('a) (cread, hread))
	  in
	     reader
	  end))
val rec 'a_2865
   binReader: ('a_2865 -> (char8 * 'a_2865) Primitive.Option.t)
	      -> 'a_2865 -> (intInf * 'a_2865) Primitive.Option.t = 
      (fn x_1272: 'a_2865 -> (char8 * 'a_2865) Primitive.Option.t =>
       case x_1272 of
	 (z: 'a_2865 -> (char8 * 'a_2865) Primitive.Option.t) =>
	 ((reader ('a_2865) (0x2, binDig)) z))
val rec 'a_2866
   octReader: ('a_2866 -> (char8 * 'a_2866) Primitive.Option.t)
	      -> 'a_2866 -> (intInf * 'a_2866) Primitive.Option.t = 
      (fn x_1273: 'a_2866 -> (char8 * 'a_2866) Primitive.Option.t =>
       case x_1273 of
	 (z: 'a_2866 -> (char8 * 'a_2866) Primitive.Option.t) =>
	 ((reader ('a_2866) (0x8, octDig)) z))
val rec 'a_2867
   decReader: ('a_2867 -> (char8 * 'a_2867) Primitive.Option.t)
	      -> 'a_2867 -> (intInf * 'a_2867) Primitive.Option.t = 
      (fn x_1274: 'a_2867 -> (char8 * 'a_2867) Primitive.Option.t =>
       case x_1274 of
	 (z: 'a_2867 -> (char8 * 'a_2867) Primitive.Option.t) =>
	 ((reader ('a_2867) (0xA, decDig)) z))
val rec 'a_2868
   hexReader: ('a_2868 -> (char8 * 'a_2868) Primitive.Option.t)
	      -> 'a_2868 -> (intInf * 'a_2868) Primitive.Option.t = 
      (fn x_1275: 'a_2868 -> (char8 * 'a_2868) Primitive.Option.t =>
       case x_1275 of
	 (z: 'a_2868 -> (char8 * 'a_2868) Primitive.Option.t) =>
	 ((reader ('a_2868) (0x10, hexDig)) z))
val rec 'a_2869
   scan: StringCvt.radix
	 -> ('a_2869 -> (char8 * 'a_2869) Primitive.Option.t)
	    -> 'a_2869 -> (intInf * 'a_2869) Primitive.Option.t = 
      (fn x_1276: StringCvt.radix =>
       case x_1276 of
	 (radix: StringCvt.radix) =>
	 case radix of
	   BIN => binReader ('a_2869)
	 | OCT => octReader ('a_2869)
	 | DEC => decReader ('a_2869)
	 | HEX => hexReader ('a_2869))
val fromString: string -> intInf Primitive.Option.t =
   (scanString_0 (intInf) (scan (int32) DEC))
val +: int32 * int32 -> int32 = +
val -: int32 * int32 -> int32 = -
val <: int32 * int32 -> bool = <
val <=: int32 * int32 -> bool = <=
val >: int32 * int32 -> bool = >
val >=: int32 * int32 -> bool = >=
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val precision': int32 = (toInt sizeInBits)
val () =
   case (< (precision', precision')) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val wordSize: int32 = (toInt sizeInBits)
val () =
   case (< (wordSize, wordSize)) of
     true => () | false => raise (Fail "EmbedWord")
val fWord8: word8 array * int64 -> word8 = subArr
val fWord16: word8 array * int64 -> word16 = subArr
val fWord64: word8 array * int64 -> word64 = subArr
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 vector * int64 -> word8 = subVec
val fWord16: word8 vector * int64 -> word16 = subVec
val fWord64: word8 vector * int64 -> word64 = subVec
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 array * int64 * word8 -> unit = update
val fWord16: word8 array * int64 * word16 -> unit = update
val fWord64: word8 array * int64 * word64 -> unit = update
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 array * int64 -> word8 = subArr
val fWord16: word8 array * int64 -> word16 = subArr
val fWord32: word8 array * int64 -> word32 = subArr
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 vector * int64 -> word8 = subVec
val fWord16: word8 vector * int64 -> word16 = subVec
val fWord32: word8 vector * int64 -> word32 = subVec
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: word8 array * int64 * word8 -> unit = update
val fWord16: word8 array * int64 * word16 -> unit = update
val fWord32: word8 array * int64 * word32 -> unit = update
val _ = fWord8
val _ = fWord16
val _ = fWord32
val maxOrd: int32 = (- (numChars, 0x1))
val rec
   chrOpt: int32 -> char8 Primitive.Option.t = 
      (fn x_1277: int32 =>
       case x_1277 of
	 (c: int32) =>
	 case case safe of
		true => (gtu (c, maxOrd)) | false => false of
	   true => NONE[char8] | false => (SOME[char8] (chrUnsafe c)))
val rec
   chr: int32 -> char8 = 
      (fn x_1278: int32 =>
       case x_1278 of
	 (c: int32) =>
	 case (chrOpt c) of
	   NONE[char8] => raise Chr | SOME[char8] c: char8 => c)
val new: int32 * char8 -> string = vector_3
val rec
   str: char8 -> string = 
      (fn x_1279: char8 =>
       case x_1279 of
	 (c: char8) => (new (0x1, c)))
val size: string -> int32 = length_7
val ^: string * string -> string = append_2
val implode: char8 list -> string = fromList_2
val rec
   extract: string * int32 * int32 Primitive.Option.t -> string = 
      (fn x_1280: string * int32 * int32 Primitive.Option.t =>
       case x_1280 of
	 ((s: string, start: int32, len: int32 Primitive.Option.t)) =>
	 (vector_4 (slice_4 (s, start, len))))
val rec
   substring: string * int32 * int32 -> string = 
      (fn x_1281: string * int32 * int32 =>
       case x_1281 of
	 ((s: string, start: int32, len: int32)) =>
	 (extract (s, start, (SOME[int32] len))))
val rec 'a_3275
   make: ((char8 * char8 -> bool) -> 'a_3275) -> 'a_3275 = 
      (fn x_1282: (char8 * char8 -> bool) -> 'a_3275 =>
       case x_1282 of
	 (f: (char8 * char8 -> bool) -> 'a_3275) => (f = (char8)))
val isPrefix: string -> string -> bool =
   (make (string -> string -> bool) isPrefix_2)
val null: string = (str (chr 0x0))
val rec
   nullTerm: string -> string = 
      (fn x_1283: string =>
       case x_1283 of
	 (s: string) => (^ (s, null)))
val string: char8 Sequence.Slice.t -> string = vector_4
val _ =
   (addExnMessager (fn x_1284: exn =>
		    case x_1284 of
		      e: exn =>
		      case e of
			Fail s: string =>
			(SOME[string] (concat_2 ["Fail: ", s]))
		      | _ => NONE[string]))
val nullTerm: string -> string =
   (o_1 (string, string, string) (fromString, nullTerm))
val rec ('a_3288, 'a_3287)
   makeLength: ('a_3288 * int32 -> 'a_3287) * ('a_3287 -> bool)
	       -> 'a_3288 -> int32 = 
      (fn x_1285: ('a_3288 * int32 -> 'a_3287) * ('a_3287 -> bool) =>
       (fn x_1286: 'a_3288 =>
	case (x_1285, x_1286) of
	  ((sub: 'a_3288 * int32 -> 'a_3287, term: 'a_3287 -> bool), p: 'a_3288) =>
	  let val rec
		 loop: int32 -> int32 = 
		    (fn x_1287: int32 =>
		     case x_1287 of
		       (i: int32) =>
		       case (term (sub (p, i))) of
			 true => i | false => (loop (+? (i, 0x1))))
	  in
	     (loop 0x0)
	  end))
val rec ('b, 'a)
   toArrayOfLength: 'a * ('a * int32 -> 'b) * int32 -> 'b array = 
      (fn x_1288: 'a * ('a * int32 -> 'b) * int32 =>
       case x_1288 of
	 ((s: 'a, sub: 'a * int32 -> 'b, n: int32)) =>
	 let val (a: 'b array, _) =
		(unfoldi_1 ('b, unit) (n,
				       (),
				       (fn x_1289: int32 * unit =>
					case x_1289 of
					  (i: int32, ()) => ((sub (s, i)), ()))))
	 in
	    a
	 end)
val rec
   sub: word64 * int32 -> char8 = 
      (fn x_1290: word64 * int32 =>
       case x_1290 of
	 ((cs: word64, i: int32)) =>
	 (idFromWord8 (getWord8 ((fromWord cs), (fromInt i)))))
val length: word64 -> int32 =
   (makeLength (word64, char8) (sub,
				(fn x_1291: char8 =>
				 case x_1291 of
				   0x0 => true | _ => false)))
val rec
   toCharArrayOfLength: word64 * int32 -> char8 array = 
      (fn x_1292: word64 * int32 =>
       case x_1292 of
	 ((cs: word64, n: int32)) =>
	 (toArrayOfLength (char8, word64) (cs, sub, n)))
val rec
   toStringOfLength: word64 * int32 -> string = 
      (fn x_1293: word64 * int32 =>
       case x_1293 of
	 ((cs: word64, n: int32)) =>
	 (unsafeFromArray_1 (fromPoly_0 (toCharArrayOfLength (cs, n)))))
val rec
   toString: word64 -> string = 
      (fn x_1294: word64 =>
       case x_1294 of
	 (cs: word64) => (toStringOfLength (cs, (length cs))))
val rec
   new: unit -> (unit -> unit) list ref = 
      (fn x_1295: unit =>
       case x_1295 of
	 (()) => (ref[(unit -> unit) list] []))
val rec 'a_3289
   addNew: 'a_3289 list ref * 'a_3289 -> unit = 
      (fn x_1296: 'a_3289 list ref * 'a_3289 =>
       case x_1296 of
	 ((cs: 'a_3289 list ref, f: 'a_3289)) =>
	 (:=_1 ('a_3289 list) (cs, (::['a_3289] (f, (!_1 ('a_3289 list) cs))))))
val rec
   clean: (unit -> unit) list ref -> unit = 
      (fn x_1297: (unit -> unit) list ref =>
       case x_1297 of
	 (cs: (unit -> unit) list ref) =>
	 ((app_1 (unit -> unit) (fn x_1298: unit -> unit =>
				 case x_1298 of
				   c: unit -> unit =>
				   (c ())
				   handle x_1299 => case x_1299 of
						      _ => ())) (!_1 ((unit -> unit) list) cs)))
val atExit: (unit -> unit) list ref = (new ())
val atLoadWorld: (unit -> unit) list ref = (new ())
val addNew_0: (unit -> unit) list ref * (unit -> unit) -> unit =
   addNew (unit -> unit)
val fromRep: int32 -> int32 = (fn x_1300: int32 => case x_1300 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1301: int32 => case x_1301 of x: int32 => x)
val fromRep: int32 -> int32 = (fn x_1302: int32 => case x_1302 of x: int32 => x)
val toRep: int32 -> int32 = (fn x_1303: int32 => case x_1303 of x: int32 => x)
val acces: int32 = (fromRep EACCES)
val addrinuse: int32 = (fromRep EADDRINUSE)
val addrnotavail: int32 = (fromRep EADDRNOTAVAIL)
val afnosupport: int32 = (fromRep EAFNOSUPPORT)
val again: int32 = (fromRep EAGAIN)
val already: int32 = (fromRep EALREADY)
val badf: int32 = (fromRep EBADF)
val badmsg: int32 = (fromRep EBADMSG)
val busy: int32 = (fromRep EBUSY)
val canceled: int32 = (fromRep ECANCELED)
val child: int32 = (fromRep ECHILD)
val connaborted: int32 = (fromRep ECONNABORTED)
val connrefused: int32 = (fromRep ECONNREFUSED)
val connreset: int32 = (fromRep ECONNRESET)
val deadlk: int32 = (fromRep EDEADLK)
val destaddrreq: int32 = (fromRep EDESTADDRREQ)
val dom: int32 = (fromRep EDOM)
val dquot: int32 = (fromRep EDQUOT)
val exist: int32 = (fromRep EEXIST)
val fault: int32 = (fromRep EFAULT)
val fbig: int32 = (fromRep EFBIG)
val hostunreach: int32 = (fromRep EHOSTUNREACH)
val idrm: int32 = (fromRep EIDRM)
val ilseq: int32 = (fromRep EILSEQ)
val inprogress: int32 = (fromRep EINPROGRESS)
val intr: int32 = (fromRep EINTR)
val inval: int32 = (fromRep EINVAL)
val io: int32 = (fromRep EIO)
val isconn: int32 = (fromRep EISCONN)
val isdir: int32 = (fromRep EISDIR)
val loop: int32 = (fromRep ELOOP)
val mfile: int32 = (fromRep EMFILE)
val mlink: int32 = (fromRep EMLINK)
val msgsize: int32 = (fromRep EMSGSIZE)
val multihop: int32 = (fromRep EMULTIHOP)
val nametoolong: int32 = (fromRep ENAMETOOLONG)
val netdown: int32 = (fromRep ENETDOWN)
val netreset: int32 = (fromRep ENETRESET)
val netunreach: int32 = (fromRep ENETUNREACH)
val nfile: int32 = (fromRep ENFILE)
val nobufs: int32 = (fromRep ENOBUFS)
val nodata: int32 = (fromRep ENODATA)
val nodev: int32 = (fromRep ENODEV)
val noent: int32 = (fromRep ENOENT)
val noexec: int32 = (fromRep ENOEXEC)
val nolck: int32 = (fromRep ENOLCK)
val nolink: int32 = (fromRep ENOLINK)
val nomem: int32 = (fromRep ENOMEM)
val nomsg: int32 = (fromRep ENOMSG)
val noprotoopt: int32 = (fromRep ENOPROTOOPT)
val nospc: int32 = (fromRep ENOSPC)
val nosr: int32 = (fromRep ENOSR)
val nostr: int32 = (fromRep ENOSTR)
val nosys: int32 = (fromRep ENOSYS)
val notconn: int32 = (fromRep ENOTCONN)
val notdir: int32 = (fromRep ENOTDIR)
val notempty: int32 = (fromRep ENOTEMPTY)
val notsock: int32 = (fromRep ENOTSOCK)
val notsup: int32 = (fromRep ENOTSUP)
val notty: int32 = (fromRep ENOTTY)
val nxio: int32 = (fromRep ENXIO)
val opnotsupp: int32 = (fromRep EOPNOTSUPP)
val overflow: int32 = (fromRep EOVERFLOW)
val perm: int32 = (fromRep EPERM)
val pipe: int32 = (fromRep EPIPE)
val proto: int32 = (fromRep EPROTO)
val protonosupport: int32 = (fromRep EPROTONOSUPPORT)
val prototype: int32 = (fromRep EPROTOTYPE)
val range: int32 = (fromRep ERANGE)
val rofs: int32 = (fromRep EROFS)
val spipe: int32 = (fromRep ESPIPE)
val srch: int32 = (fromRep ESRCH)
val stale: int32 = (fromRep ESTALE)
val time: int32 = (fromRep ETIME)
val timedout: int32 = (fromRep ETIMEDOUT)
val toobig: int32 = (fromRep E2BIG)
val txtbsy: int32 = (fromRep ETXTBSY)
val wouldblock: int32 = (fromRep EWOULDBLOCK)
val xdev: int32 = (fromRep EXDEV)
val rec 'a_3290
   ::?: (int32 * 'a_3290) * (int32 * 'a_3290) list -> (int32 * 'a_3290) list = 
      (fn x_1304: (int32 * 'a_3290) * (int32 * 'a_3290) list =>
       case x_1304 of
	 (((n: int32, s: 'a_3290), l: (int32 * 'a_3290) list)) =>
	 case (= (int32) (n, (fromRep 0xFFFFFFFF))) of
	   true => l | false => (::[int32 * 'a_3290] ((n, s), l)))
val errorNames: (int32 * string) list =
   (::? (string) ((acces, "acces"),
		  (::? (string) ((addrinuse, "addrinuse"),
				 (::? (string) ((addrnotavail, "addrnotavail"),
						(::? (string) ((afnosupport,
								"afnosupport"),
							       (::? (string) ((again,
									       "again"),
									      (::? (string) ((already,
											      "already"),
											     (::? (string) ((badf,
													     "badf"),
													    (::? (string) ((badmsg,
															    "badmsg"),
															   (::? (string) ((busy,
																	   "busy"),
																	  (::? (string) ((canceled,
																			  "canceled"),
																			 (::? (string) ((child,
																					 "child"),
																					(::? (string) ((connaborted,
																							"connaborted"),
																						       (::? (string) ((connrefused,
																								       "connrefused"),
																								      (::? (string) ((connreset,
																										      "connreset"),
																										     (::? (string) ((deadlk,
																												     "deadlk"),
																												    (::? (string) ((destaddrreq,
																														    "destaddrreq"),
																														   (::? (string) ((dom,
																																   "dom"),
																																  (::? (string) ((dquot,
																																		  "dquot"),
																																		 (::? (string) ((exist,
																																				 "exist"),
																																				(::? (string) ((fault,
																																						"fault"),
																																					       (::? (string) ((fbig,
																																							       "fbig"),
																																							      (::? (string) ((hostunreach,
																																									      "hostunreach"),
																																									     (::? (string) ((idrm,
																																											     "idrm"),
																																											    (::? (string) ((ilseq,
																																													    "ilseq"),
																																													   (::? (string) ((inprogress,
																																															   "inprogress"),
																																															  (::? (string) ((intr,
																																																	  "intr"),
																																																	 (::? (string) ((inval,
																																																			 "inval"),
																																																			(::? (string) ((io,
																																																					"io"),
																																																				       (::? (string) ((isconn,
																																																						       "isconn"),
																																																						      (::? (string) ((isdir,
																																																								      "isdir"),
																																																								     (::? (string) ((loop,
																																																										     "loop"),
																																																										    (::? (string) ((mfile,
																																																												    "mfile"),
																																																												   (::? (string) ((mlink,
																																																														   "mlink"),
																																																														  (::? (string) ((msgsize,
																																																																  "msgsize"),
																																																																 (::? (string) ((multihop,
																																																																		 "multihop"),
																																																																		(::? (string) ((nametoolong,
																																																																				"nametoolong"),
																																																																			       (::? (string) ((netdown,
																																																																					       "netdown"),
																																																																					      (::? (string) ((netreset,
																																																																							      "netreset"),
																																																																							     (::? (string) ((netunreach,
																																																																									     "netunreach"),
																																																																									    (::? (string) ((nfile,
																																																																											    "nfile"),
																																																																											   (::? (string) ((nobufs,
																																																																													   "nobufs"),
																																																																													  (::? (string) ((nodata,
																																																																															  "nodata"),
																																																																															 (::? (string) ((nodev,
																																																																																	 "nodev"),
																																																																																	(::? (string) ((noent,
																																																																																			"noent"),
																																																																																		       (::? (string) ((noexec,
																																																																																				       "noexec"),
																																																																																				      (::? (string) ((nolck,
																																																																																						      "nolck"),
																																																																																						     (::? (string) ((nolink,
																																																																																								     "nolink"),
																																																																																								    (::? (string) ((nomem,
																																																																																										    "nomem"),
																																																																																										   (::? (string) ((nomsg,
																																																																																												   "nomsg"),
																																																																																												  (::? (string) ((noprotoopt,
																																																																																														  "noprotoopt"),
																																																																																														 (::? (string) ((nospc,
																																																																																																 "nospc"),
																																																																																																(::? (string) ((nosr,
																																																																																																		"nosr"),
																																																																																																	       (::? (string) ((nostr,
																																																																																																			       "nostr"),
																																																																																																			      (::? (string) ((nosys,
																																																																																																					      "nosys"),
																																																																																																					     (::? (string) ((notconn,
																																																																																																							     "notconn"),
																																																																																																							    (::? (string) ((notdir,
																																																																																																									    "notdir"),
																																																																																																									   (::? (string) ((notempty,
																																																																																																											   "notempty"),
																																																																																																											  (::? (string) ((notsock,
																																																																																																													  "notsock"),
																																																																																																													 (::? (string) ((notsup,
																																																																																																															 "notsup"),
																																																																																																															(::? (string) ((notty,
																																																																																																																	"notty"),
																																																																																																																       (::? (string) ((nxio,
																																																																																																																		       "nxio"),
																																																																																																																		      (::? (string) ((opnotsupp,
																																																																																																																				      "opnotsupp"),
																																																																																																																				     (::? (string) ((overflow,
																																																																																																																						     "overflow"),
																																																																																																																						    (::? (string) ((perm,
																																																																																																																								    "perm"),
																																																																																																																								   (::? (string) ((pipe,
																																																																																																																										   "pipe"),
																																																																																																																										  (::? (string) ((proto,
																																																																																																																												  "proto"),
																																																																																																																												 (::? (string) ((protonosupport,
																																																																																																																														 "protonosupport"),
																																																																																																																														(::? (string) ((prototype,
																																																																																																																																"prototype"),
																																																																																																																															       (::? (string) ((range,
																																																																																																																																	       "range"),
																																																																																																																																	      (::? (string) ((rofs,
																																																																																																																																			      "rofs"),
																																																																																																																																			     (::? (string) ((spipe,
																																																																																																																																					     "spipe"),
																																																																																																																																					    (::? (string) ((srch,
																																																																																																																																							    "srch"),
																																																																																																																																							   (::? (string) ((stale,
																																																																																																																																									   "stale"),
																																																																																																																																									  (::? (string) ((time,
																																																																																																																																											  "time"),
																																																																																																																																											 (::? (string) ((timedout,
																																																																																																																																													 "timedout"),
																																																																																																																																													(::? (string) ((toobig,
																																																																																																																																															"toobig"),
																																																																																																																																														       (::? (string) ((txtbsy,
																																																																																																																																																       "txtbsy"),
																																																																																																																																																      (::? (string) ((wouldblock,
																																																																																																																																																		      "wouldblock"),
																																																																																																																																																		     (::? (string) ((xdev,
																																																																																																																																																				     "xdev"),
																																																																																																																																																				    []))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
exception SysErr of string * int32 Primitive.Option.t
val rec
   errorName: int32 -> string = 
      (fn x_1305: int32 =>
       case x_1305 of
	 (n: int32) =>
	 case ((find_0 (int32 * string) (fn x_1306: int32 * string =>
					 case x_1306 of
					   (m: int32, _) => (= (int32) (n, m)))) errorNames) of
	   NONE[int32 * string] => "<UNKNOWN>"
	 | SOME[int32 * string] (_, s: string) => s)
val _ =
   (addExnMessager (fn x_1307: exn =>
		    case x_1307 of
		      e: exn =>
		      case e of
			SysErr (s: string, eo: int32 Primitive.Option.t) =>
			(SOME[string] (concat_2 ["SysErr: ",
						 s,
						 case eo of
						   NONE[int32] => ""
						 | SOME[int32] e: int32 =>
						   (concat_2 [" [",
							      (errorName e),
							      "]"])]))
		      | _ => NONE[string]))
val rec
   errorMsg: int32 -> string = 
      (fn x_1308: int32 =>
       case x_1308 of
	 (n: int32) =>
	 let val cs: word64 = (strError (toRep n))
	 in
	    case (isNull (fromWord cs)) of
	      true => "Unknown error" | false => (toString cs)
	 end)
val rec 'a_3291
   raiseSys: int32 -> 'a_3291 = 
      (fn x_1309: int32 =>
       case x_1309 of
	 (n: int32) => raise (SysErr ((errorMsg n), (SOME[int32] n))))
val 'a raiseSys_0: int32 -> 'a = raiseSys ('a)
exception Unordered
datatype IEEEReal.real_order = LESS
			       | EQUAL
			       | GREATER
			       | UNORDERED
datatype IEEEReal.float_class = INF
				| NAN
				| NORMAL
				| SUBNORMAL
				| ZERO
val rec 'a_3304
   mkClass: ('a_3304 -> int32) -> 'a_3304 -> IEEEReal.float_class = 
      (fn x_1310: 'a_3304 -> int32 =>
       (fn x_1311: 'a_3304 =>
	case (x_1310, x_1311) of
	  (class: 'a_3304 -> int32, x: 'a_3304) =>
	  let val i: int32 = (class x)
	  in
	     case (= (int32) (i, FP_NORMAL)) of
	       true => NORMAL
	     | false =>
	       case (= (int32) (i, FP_ZERO)) of
		 true => ZERO
	       | false =>
		 case (= (int32) (i, FP_INFINITE)) of
		   true => INF
		 | false =>
		   case (= (int32) (i, FP_NAN)) of
		     true => NAN
		   | false =>
		     case (= (int32) (i, FP_SUBNORMAL)) of
		       true => SUBNORMAL
		     | false => raise (Fail "Real_class returned bogus integer")
	  end))
datatype IEEEReal.RoundingMode.t = TO_NEAREST
				   | TO_NEGINF
				   | TO_POSINF
				   | TO_ZERO
val rec
   fromInt: int32 -> IEEEReal.RoundingMode.t = 
      (fn x_1312: int32 =>
       case x_1312 of
	 (i: int32) =>
	 let 
	 in
	    case (= (int32) (i, FE_TONEAREST)) of
	      true => TO_NEAREST
	    | false =>
	      case (= (int32) (i, FE_DOWNWARD)) of
		true => TO_NEGINF
	      | false =>
		case (= (int32) (i, FE_UPWARD)) of
		  true => TO_POSINF
		| false =>
		  case (= (int32) (i, FE_TOWARDZERO)) of
		    true => TO_ZERO
		  | false => raise (Fail "IEEEReal.RoundingMode.fromInt")
	 end)
val rec
   toInt: IEEEReal.RoundingMode.t -> int32 = 
      (fn x_1313: IEEEReal.RoundingMode.t =>
       case x_1313 of
	 (m: IEEEReal.RoundingMode.t) =>
	 let val i: int32 =
		case m of
		  TO_NEAREST => FE_TONEAREST
		| TO_NEGINF => FE_DOWNWARD
		| TO_POSINF => FE_UPWARD
		| TO_ZERO => FE_TOWARDZERO
	 in
	    case (= (int32) (i, FE_NOSUPPORT)) of
	      true => raise (Fail "IEEEReal rounding mode not supported")
	    | false => i
	 end)
val rec
   setRoundingMode: IEEEReal.RoundingMode.t -> unit = 
      (fn x_1314: IEEEReal.RoundingMode.t =>
       case x_1314 of
	 (m: IEEEReal.RoundingMode.t) =>
	 case (= (int32) ((setRoundingMode (toInt m)), 0x0)) of
	   true => () | false => raise (raiseSys_0 (exn) inval))
val getRoundingMode: unit -> IEEEReal.RoundingMode.t =
   (o_1 (unit, IEEEReal.RoundingMode.t, int32) (fromInt, getRoundingMode))
val rec 'a
   withRoundingMode: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a = 
      (fn x_1315: IEEEReal.RoundingMode.t * (unit -> 'a) =>
       case x_1315 of
	 ((m: IEEEReal.RoundingMode.t, th: unit -> 'a)) =>
	 let val m': IEEEReal.RoundingMode.t = (getRoundingMode ())
	     val _ = (setRoundingMode m)
	     val res: 'a = (th ())
	     val _ = (setRoundingMode m')
	 in
	    res
	 end)
val rec
   toString: {class: IEEEReal.float_class,
	      digits: int32 list,
	      exp: int32,
	      sign: bool}
	     -> string = 
      (fn x_1316: {class: IEEEReal.float_class,
		   digits: int32 list,
		   exp: int32,
		   sign: bool} =>
       case x_1316 of
	 ({class = class: IEEEReal.float_class,
	   sign = sign: bool,
	   digits = digits: int32 list,
	   exp = exp: int32}) =>
	 let val rec
		digitStr: unit -> string = 
		   (fn x_1318: unit =>
		    case x_1318 of
		      (()) =>
		      (implode ((map_2 (char8, int32) digitToChar) digits)))
	     val rec
		norm: unit -> string = 
		   (fn x_1317: unit =>
		    case x_1317 of
		      (()) =>
		      let val num: string = (^ ("0.", (digitStr ())))
		      in
			 case (= (int32) (exp, 0x0)) of
			   true => num
			 | false => (concat_2 [num, "E", (toString exp)])
		      end)
	     val num: string =
		case class of
		  ZERO => "0.0"
		| NORMAL => (norm ())
		| SUBNORMAL => (norm ())
		| INF => "inf"
		| NAN => "nan"
	 in
	    case sign of
	      true => (^ ("~", num)) | false => num
	 end)
val 'a withRoundingMode_0: IEEEReal.RoundingMode.t * (unit -> 'a) -> 'a =
   withRoundingMode ('a)
val 'a mkClass_0: ('a -> int32) -> 'a -> IEEEReal.float_class = mkClass ('a)
val +: real32 * real32 -> real32 = +
val -: real32 * real32 -> real32 = -
val /: real32 * real32 -> real32 = /
val <: real32 * real32 -> bool = <
val <=: real32 * real32 -> bool = <=
val >: real32 * real32 -> bool = >
val >=: real32 * real32 -> bool = >=
val ~: real32 -> real32 = ~
val realSize: int32 = (toInt realSize)
val precision: int32 = (toInt precision)
val signBit: real32 -> bool =
   (fn x_1319: real32 =>
    case x_1319 of
      r: real32 => (<> (int32) ((signBit r), 0x0)))
val rec 'a
   make: {fromRealUnsafe: 'a -> real32,
	  other: {precision: int32},
	  toRealUnsafe: real32 -> 'a}
	 -> (IEEEReal.RoundingMode.t -> 'a -> real32) * (real32 -> 'a) = 
      (fn x_1320: {fromRealUnsafe: 'a -> real32,
		   other: {precision: int32},
		   toRealUnsafe: real32 -> 'a} =>
       case x_1320 of
	 ({fromRealUnsafe = fromRealUnsafe: 'a -> real32,
	   toRealUnsafe = toRealUnsafe: real32 -> 'a,
	   other = other: {precision: int32}}) =>
	 case (= (int32) (precision,
			  ((fn x_1325: {precision: int32} =>
			    case x_1325 of
			      {precision = #: int32} => #) other))) of
	   true =>
	   ((fn x_1321: IEEEReal.RoundingMode.t =>
	     case x_1321 of
	       _ => fromRealUnsafe),
	    toRealUnsafe)
	 | false =>
	   ((fn x_1322: IEEEReal.RoundingMode.t =>
	     case x_1322 of
	       m: IEEEReal.RoundingMode.t =>
	       (fn x_1323: 'a =>
		case x_1323 of
		  r: 'a =>
		  (withRoundingMode_0 (real32) (m,
						(fn x_1324: unit =>
						 case x_1324 of
						   () => (fromRealUnsafe r)))))),
	    toRealUnsafe))
val (fromReal32: IEEEReal.RoundingMode.t -> real32 -> real32,
     toReal32: real32 -> real32) =
   (make (real32) {fromRealUnsafe = fromReal32Unsafe,
		   toRealUnsafe = toReal32Unsafe,
		   other = {precision = precision}})
val fReal32: real32 -> real32 = toReal32
val _ = fReal32
val fReal32: IEEEReal.RoundingMode.t -> real32 -> real32 = fromReal32
val _ = fReal32
val zero: real32 = (fromInt32Unsafe 0x0)
val one: real32 = (fromInt32Unsafe 0x1)
val two: real32 = (fromInt32Unsafe 0x2)
val half: real32 = (/ (one, two))
val class: real32 -> IEEEReal.float_class = (mkClass_0 (real32) class)
val rec
   roundReal: real32 * IEEEReal.RoundingMode.t -> real32 = 
      (fn x_1326: real32 * IEEEReal.RoundingMode.t =>
       case x_1326 of
	 ((x: real32, m: IEEEReal.RoundingMode.t)) =>
	 (withRoundingMode_0 (real32) (m,
				       (fn x_1327: unit =>
					case x_1327 of
					  () => (round x)))))
val rec
   strto: string * IEEEReal.RoundingMode.t -> real32 = 
      (fn x_1328: string * IEEEReal.RoundingMode.t =>
       case x_1328 of
	 ((str: string, rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (strto (str, rounding))
	 end)
exception Bad
datatype Real.mode = Fix
		     | Gen
		     | Sci
val one: int32 ref One.t =
   (make_0 (int32 ref) (fn x_1329: unit =>
			case x_1329 of
			  () => (ref[int32] 0x0)))
val rec
   gdtoa: real32 * Real.mode * int32 * IEEEReal.RoundingMode.t -> word64 * int32 = 
      (fn x_1330: real32 * Real.mode * int32 * IEEEReal.RoundingMode.t =>
       case x_1330 of
	 ((x: real32,
	   mode: Real.mode,
	   ndig: int32,
	   rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val mode: int32 = case mode of Fix => 0x3 | Gen => 0x0 | Sci => 0x2
	     val ndig: int32 = (fromInt ndig)
	     val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (use_0 (word64 * int32, int32 ref) (one,
						(fn x_1331: int32 ref =>
						 case x_1331 of
						   decpt: int32 ref =>
						   ((gdtoa (x,
							    mode,
							    ndig,
							    rounding,
							    decpt)),
						    (toInt (!_1 (int32) decpt))))))
	 end)
val rec
   toDecimal: real32
	      -> {class: IEEEReal.float_class,
		  digits: int32 list,
		  exp: int32,
		  sign: bool} = 
      (fn x_1332: real32 =>
       case x_1332 of
	 (x: real32) =>
	 case (class x) of
	   INF => {class = INF, digits = [], exp = 0x0, sign = (< (x, zero))}
	 | NAN => {class = NAN, digits = [], exp = 0x0, sign = false}
	 | ZERO => {class = ZERO, digits = [], exp = 0x0, sign = (signBit x)}
	 | c: IEEEReal.float_class =>
	   let val (cs: word64, exp: int32) = (gdtoa (x, Gen, 0x0, TO_NEAREST))
	       val rec
		  loop: int32 * int32 list -> int32 list = 
		     (fn x_1333: int32 * int32 list =>
		      case x_1333 of
			((i: int32, ac: int32 list)) =>
			case (< (i, 0x0)) of
			  true => ac
			| false =>
			  (loop ((- (i, 0x1)),
				 (::[int32] ((- ((ord (sub (cs, i))), (ord 0x30))),
					     ac)))))
	       val digits: int32 list = (loop ((- ((length cs), 0x1)), []))
	   in
	      {class = c, digits = digits, exp = exp, sign = (< (x, zero))}
	   end)
val rec
   fix: string * word64 * int32 * int32 -> string = 
      (fn x_1334: string * word64 * int32 * int32 =>
       case x_1334 of
	 ((sign: string, cs: word64, decpt: int32, ndig: int32)) =>
	 let val length: int32 = (length cs)
	 in
	    case (< (decpt, 0x0)) of
	      true =>
	      (concat_2 [sign,
			 "0.",
			 (new ((~ decpt), 0x30)),
			 (toString cs),
			 (new ((+ ((- (ndig, length)), decpt)), 0x30))])
	    | false =>
	      let val whole: string =
		     case (= (int32) (decpt, 0x0)) of
		       true => "0"
		     | false =>
		       (tabulate_4 (decpt,
				    (fn x_1335: int32 =>
				     case x_1335 of
				       i: int32 =>
				       case (< (i, length)) of
					 true => (sub (cs, i)) | false => 0x30)))
	      in
		 case (= (int32) (0x0, ndig)) of
		   true => (concat_2 [sign, whole])
		 | false =>
		   let val frac: string =
			  (tabulate_4 (ndig,
				       (fn x_1336: int32 =>
					case x_1336 of
					  i: int32 =>
					  let val j: int32 = (+ (i, decpt))
					  in
					     case (< (j, length)) of
					       true => (sub (cs, j))
					     | false => 0x30
					  end)))
		   in
		      (concat_2 [sign, whole, ".", frac])
		   end
	      end
	 end)
val rec
   sci: real32 * int32 -> string = 
      (fn x_1337: real32 * int32 =>
       case x_1337 of
	 ((x: real32, ndig: int32)) =>
	 let val sign: string = case (< (x, zero)) of true => "~" | false => ""
	     val (cs: word64, decpt: int32) =
		(gdtoa (x, Sci, (+ (0x1, ndig)), (getRoundingMode ())))
	     val length: int32 = (length cs)
	     val whole: string =
		(tabulate_4 (0x1,
			     (fn x_1339: int32 =>
			      case x_1339 of
				_ => (sub (cs, 0x0)))))
	     val frac: string =
		case (= (int32) (0x0, ndig)) of
		  true => ""
		| false =>
		  (concat_2 [".",
			     (tabulate_4 (ndig,
					  (fn x_1338: int32 =>
					   case x_1338 of
					     i: int32 =>
					     let val j: int32 = (+ (i, 0x1))
					     in
						case (< (j, length)) of
						  true => (sub (cs, j))
						| false => 0x30
					     end)))])
	     val exp: int32 = (- (decpt, 0x1))
	     val exp: string =
		let val (exp: int32, sign: string) =
		       case (< (exp, 0x0)) of
			 true => ((~ exp), "~") | false => (exp, "")
		in
		   (concat_2 [sign, (toString exp)])
		end
	 in
	    (concat_2 [sign, whole, frac, "E", exp])
	 end)
val rec
   gen: real32 * int32 -> string = 
      (fn x_1340: real32 * int32 =>
       case x_1340 of
	 ((x: real32, n: int32)) =>
	 case (class x) of
	   INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	 | NAN => "nan"
	 | _ =>
	   let val (prefix: string, x: real32) =
		  case (< (x, zero)) of
		    true => ("~", (~ x)) | false => ("", x)
	       val ss: char8 Sequence.Slice.t = (full_2 (sci (x, (- (n, 0x1)))))
	       val rec
		  isE: char8 -> bool = 
		     (fn x_1347: char8 =>
		      case x_1347 of
			(c: char8) => (= (char8) (c, 0x45)))
	       val rec
		  isZero: char8 -> bool = 
		     (fn x_1346: char8 =>
		      case x_1346 of
			(c: char8) => (= (char8) (c, 0x30)))
	       val expS: string =
		  (string ((taker_2 (o_1 (char8, bool, bool) (not, isE))) ss))
	       val exp: int32 = (valOf_1 (int32) (fromString expS))
	       val man: string =
		  ((translate_2 (fn x_1345: char8 =>
				 case x_1345 of
				   0x2E => "" | c: char8 => (str c))) (string ((dropr_2 isZero) ((takel_2 (o_1 (char8,
									     bool,
									     bool) (not,
										    isE))) ss))))
	       val manSize: int32 = (size man)
	       val rec
		  zeros: int32 -> string = 
		     (fn x_1343: int32 =>
		      case x_1343 of
			(i: int32) =>
			(tabulate_4 (i,
				     (fn x_1344: int32 =>
				      case x_1344 of
					_ => 0x30))))
	       val rec
		  dotAt: int32 -> string = 
		     (fn x_1342: int32 =>
		      case x_1342 of
			(i: int32) =>
			(concat_2 [(substring (man, 0x0, i)),
				   ".",
				   (extract (man, i, NONE[int32]))]))
	       val rec
		  sci: unit -> string = 
		     (fn x_1341: unit =>
		      case x_1341 of
			(()) =>
			(concat_2 [prefix,
				   case (= (int32) (manSize, 0x1)) of
				     true => man | false => (dotAt 0x1),
				   "E",
				   expS]))
	       val -: int32 * int32 -> int32 = -
	       val +: int32 * int32 -> int32 = +
	       val ~: int32 -> int32 = ~
	       val >=: int32 * int32 -> bool = >=
	   in
	      case (>= (exp,
			case (= (int32) (manSize, 0x1)) of
			  true => 0x3 | false => (+ (manSize, 0x3)))) of
		true => (sci ())
	      | false =>
		case (>= (exp, (- (manSize, 0x1)))) of
		  true =>
		  (concat_2 [prefix, man, (zeros (- (exp, (- (manSize, 0x1)))))])
		| false =>
		  case (>= (exp, 0x0)) of
		    true => (concat_2 [prefix, (dotAt (+ (exp, 0x1)))])
		  | false =>
		    case (>= (exp,
			      case (= (int32) (manSize, 0x1)) of
				true => 0xFFFFFFFE | false => 0xFFFFFFFD)) of
		      true =>
		      (concat_2 [prefix, "0.", (zeros (- ((~ exp), 0x1))), man])
		    | false => (sci ())
	   end)
val rec
   fmt: StringCvt.realfmt -> real32 -> string = 
      (fn x_1348: StringCvt.realfmt =>
       case x_1348 of
	 (spec: StringCvt.realfmt) =>
	 let val doit: real32 -> string =
		case spec of
		  EXACT =>
		  (o_1 (real32,
			string,
			{class: IEEEReal.float_class,
			 digits: int32 list,
			 exp: int32,
			 sign: bool}) (toString, toDecimal))
		| FIX opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1349: real32 =>
		      case x_1349 of
			x: real32 =>
			let val sign: string =
			       case (< (x, zero)) of
				 true => "~" | false => ""
			    val (cs: word64, decpt: int32) =
			       (gdtoa (x, Fix, n, (getRoundingMode ())))
			in
			   (fix (sign, cs, decpt, n))
			end)
		  end
		| GEN opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0xC
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x1)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1350: real32 =>
		      case x_1350 of
			x: real32 => (gen (x, n)))
		  end
		| SCI opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1351: real32 =>
		      case x_1351 of
			x: real32 => (sci (x, n)))
		  end
	 in
	    (fn x_1352: real32 =>
	     case x_1352 of
	       x: real32 =>
	       case (class x) of
		 NAN => "nan"
	       | INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	       | _ => (doit x))
	 end)
val rec 'a
   make: {fromIntUnsafe: 'a -> real32,
	  other: {maxInt': 'a, minInt': 'a, precision': int32},
	  toIntUnsafe: real32 -> 'a}
	 -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
      (fn x_1353: {fromIntUnsafe: 'a -> real32,
		   other: {maxInt': 'a, minInt': 'a, precision': int32},
		   toIntUnsafe: real32 -> 'a} =>
       case x_1353 of
	 ({fromIntUnsafe = fromIntUnsafe: 'a -> real32,
	   toIntUnsafe = toIntUnsafe: real32 -> 'a,
	   other = other: {maxInt': 'a, minInt': 'a, precision': int32}}) =>
	 (fromIntUnsafe,
	  case (< (precision,
		   ((fn x_1363: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1363 of
		       {precision' = #: int32} => #) other))) of
	    true =>
	    let val maxInt': 'a =
		   ((fn x_1356: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1356 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1355: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1355 of
		       {minInt' = #: 'a} => #) other)
		val (maxInt: real32, minInt: real32) =
		   (withRoundingMode_0 (real32 * real32) (TO_ZERO,
							  (fn x_1354: unit =>
							   case x_1354 of
							     () =>
							     ((fromIntUnsafe maxInt'),
							      (fromIntUnsafe minInt')))))
	    in
	       (fn x_1357: IEEEReal.RoundingMode.t =>
		case x_1357 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1358: real32 =>
		   case x_1358 of
		     x: real32 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true => raise Overflow | false => raise Domain))
	    end
	  | false =>
	    let val maxInt': 'a =
		   ((fn x_1360: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1360 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1359: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1359 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real32 = (fromIntUnsafe maxInt')
		val minInt: real32 = (fromIntUnsafe minInt')
	    in
	       (fn x_1361: IEEEReal.RoundingMode.t =>
		case x_1361 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1362: real32 =>
		   case x_1362 of
		     x: real32 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false =>
			 case (< (x, (+ (maxInt, one)))) of
			   true =>
			   case m of
			     TO_NEGINF => maxInt'
			   | TO_POSINF => raise Overflow
			   | TO_ZERO => maxInt'
			   | TO_NEAREST =>
			     case (>= ((- (x, maxInt)), half)) of
			       true => raise Overflow | false => maxInt'
			 | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true =>
			 case (< ((- (minInt, one)), x)) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => minInt'
			   | TO_ZERO => minInt'
			   | TO_NEAREST =>
			     case (< ((- (x, minInt)), (~ half))) of
			       true => raise Overflow | false => minInt'
			 | false => raise Overflow
		       | false => raise Domain))
	    end))
val (fromInt8: int8 -> real32, toInt8: IEEEReal.RoundingMode.t -> real32 -> int8) =
   (make (int8) {fromIntUnsafe = fromInt8Unsafe,
		 toIntUnsafe = toInt8Unsafe,
		 other = {maxInt' = maxInt',
			  minInt' = minInt',
			  precision' = precision'}})
val (fromInt16: int16 -> real32,
     toInt16: IEEEReal.RoundingMode.t -> real32 -> int16) =
   (make (int16) {fromIntUnsafe = fromInt16Unsafe,
		  toIntUnsafe = toInt16Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt32: int32 -> real32,
     toInt32: IEEEReal.RoundingMode.t -> real32 -> int32) =
   (make (int32) {fromIntUnsafe = fromInt32Unsafe,
		  toIntUnsafe = toInt32Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt64: int64 -> real32,
     toInt64: IEEEReal.RoundingMode.t -> real32 -> int64) =
   (make (int64) {fromIntUnsafe = fromInt64Unsafe,
		  toIntUnsafe = toInt64Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val fromIntInf: intInf -> real32 =
   (fn x_1364: intInf =>
    case x_1364 of
      i: intInf =>
      let val str: string =
	     case (< (i, 0)) of
	       true => (^ ("-", (toString (~ i)))) | false => (toString i)
	  val x: real32 = (strto ((nullTerm str), (getRoundingMode ())))
      in
	 x
      end)
val toIntInf: IEEEReal.RoundingMode.t -> real32 -> intInf =
   (fn x_1365: IEEEReal.RoundingMode.t =>
    case x_1365 of
      mode: IEEEReal.RoundingMode.t =>
      (fn x_1366: real32 =>
       case x_1366 of
	 x: real32 =>
	 case (class x) of
	   INF => raise Overflow
	 | NAN => raise Domain
	 | ZERO => 0
	 | _ =>
	   let val x: real32 = (roundReal (x, mode))
	   in
	      case (class x) of
		INF => raise Overflow
	      | _ =>
		(valOf_1 (intInf) (fromString ((fmt (FIX (SOME[int32] 0x0))) x)))
	   end))
val fInt8: int8 -> real32 = fromInt8
val fInt16: int16 -> real32 = fromInt16
val fInt64: int64 -> real32 = fromInt64
val fIntInf: intInf -> real32 = fromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> real32 = fromInt8
val fInt16: int16 -> real32 = fromInt16
val fInt32: int32 -> real32 = fromInt32
val fInt64: int64 -> real32 = fromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: IEEEReal.RoundingMode.t -> real32 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real32 -> int16 = toInt16
val fInt64: IEEEReal.RoundingMode.t -> real32 -> int64 = toInt64
val fIntInf: IEEEReal.RoundingMode.t -> real32 -> intInf = toIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: IEEEReal.RoundingMode.t -> real32 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real32 -> int16 = toInt16
val fInt32: IEEEReal.RoundingMode.t -> real32 -> int32 = toInt32
val fInt64: IEEEReal.RoundingMode.t -> real32 -> int64 = toInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val rec 'a
   make: {fromWordUnsafe: 'a -> real32,
	  other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
	  toWordUnsafe: real32 -> 'a}
	 -> ('a -> real32) * (IEEEReal.RoundingMode.t -> real32 -> 'a) = 
      (fn x_1367: {fromWordUnsafe: 'a -> real32,
		   other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
		   toWordUnsafe: real32 -> 'a} =>
       case x_1367 of
	 ({fromWordUnsafe = fromWordUnsafe: 'a -> real32,
	   toWordUnsafe = toWordUnsafe: real32 -> 'a,
	   other = other: {maxWord': 'a, wordSize: int32, zeroWord: 'a}}) =>
	 (fromWordUnsafe,
	  case (<= (precision,
		    ((fn x_1377: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		      case x_1377 of
			{wordSize = #: int32} => #) other))) of
	    true =>
	    let val maxWord': 'a =
		   ((fn x_1370: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1370 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real32 =
		   (withRoundingMode_0 (real32) (TO_ZERO,
						 (fn x_1369: unit =>
						  case x_1369 of
						    () =>
						    (fromWordUnsafe maxWord'))))
		val zeroWord: 'a =
		   ((fn x_1368: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1368 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1371: IEEEReal.RoundingMode.t =>
		case x_1371 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1372: real32 =>
		   case x_1372 of
		     x: real32 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end
	  | false =>
	    let val maxWord': 'a =
		   ((fn x_1374: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1374 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real32 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1373: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1373 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1375: IEEEReal.RoundingMode.t =>
		case x_1375 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1376: real32 =>
		   case x_1376 of
		     x: real32 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false =>
			   case (< (x, (+ (maxWord, one)))) of
			     true =>
			     case m of
			       TO_NEGINF => maxWord'
			     | TO_POSINF => raise Overflow
			     | TO_ZERO => maxWord'
			     | TO_NEAREST =>
			       case (>= ((- (x, maxWord)), half)) of
				 true => raise Overflow | false => maxWord'
			   | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end))
val (fromWord8: word8 -> real32,
     toWord8: IEEEReal.RoundingMode.t -> real32 -> word8) =
   (make (word8) {fromWordUnsafe = fromWord8Unsafe,
		  toWordUnsafe = toWord8Unsafe,
		  other = {maxWord' = maxWord',
			   wordSize = wordSize,
			   zeroWord = zero}})
val (fromWord16: word16 -> real32,
     toWord16: IEEEReal.RoundingMode.t -> real32 -> word16) =
   (make (word16) {fromWordUnsafe = fromWord16Unsafe,
		   toWordUnsafe = toWord16Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord32: word32 -> real32,
     toWord32: IEEEReal.RoundingMode.t -> real32 -> word32) =
   (make (word32) {fromWordUnsafe = fromWord32Unsafe,
		   toWordUnsafe = toWord32Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord64: word64 -> real32,
     toWord64: IEEEReal.RoundingMode.t -> real32 -> word64) =
   (make (word64) {fromWordUnsafe = fromWord64Unsafe,
		   toWordUnsafe = toWord64Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val fWord8: word8 -> real32 = fromWord8
val fWord16: word16 -> real32 = fromWord16
val fWord64: word64 -> real32 = fromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> real32 = fromWord8
val fWord16: word16 -> real32 = fromWord16
val fWord32: word32 -> real32 = fromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: IEEEReal.RoundingMode.t -> real32 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real32 -> word16 = toWord16
val fWord64: IEEEReal.RoundingMode.t -> real32 -> word64 = toWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: IEEEReal.RoundingMode.t -> real32 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real32 -> word16 = toWord16
val fWord32: IEEEReal.RoundingMode.t -> real32 -> word32 = toWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val +: real64 * real64 -> real64 = +
val -: real64 * real64 -> real64 = -
val /: real64 * real64 -> real64 = /
val <: real64 * real64 -> bool = <
val <=: real64 * real64 -> bool = <=
val >: real64 * real64 -> bool = >
val >=: real64 * real64 -> bool = >=
val ~: real64 -> real64 = ~
val precision: int32 = (toInt precision)
val signBit: real64 -> bool =
   (fn x_1378: real64 =>
    case x_1378 of
      r: real64 => (<> (int32) ((signBit r), 0x0)))
val rec 'a
   make: {fromRealUnsafe: 'a -> real64,
	  other: {precision: int32},
	  toRealUnsafe: real64 -> 'a}
	 -> (IEEEReal.RoundingMode.t -> 'a -> real64) * (real64 -> 'a) = 
      (fn x_1379: {fromRealUnsafe: 'a -> real64,
		   other: {precision: int32},
		   toRealUnsafe: real64 -> 'a} =>
       case x_1379 of
	 ({fromRealUnsafe = fromRealUnsafe: 'a -> real64,
	   toRealUnsafe = toRealUnsafe: real64 -> 'a,
	   other = other: {precision: int32}}) =>
	 case (= (int32) (precision,
			  ((fn x_1384: {precision: int32} =>
			    case x_1384 of
			      {precision = #: int32} => #) other))) of
	   true =>
	   ((fn x_1380: IEEEReal.RoundingMode.t =>
	     case x_1380 of
	       _ => fromRealUnsafe),
	    toRealUnsafe)
	 | false =>
	   ((fn x_1381: IEEEReal.RoundingMode.t =>
	     case x_1381 of
	       m: IEEEReal.RoundingMode.t =>
	       (fn x_1382: 'a =>
		case x_1382 of
		  r: 'a =>
		  (withRoundingMode_0 (real64) (m,
						(fn x_1383: unit =>
						 case x_1383 of
						   () => (fromRealUnsafe r)))))),
	    toRealUnsafe))
val (fromReal32: IEEEReal.RoundingMode.t -> real32 -> real64,
     toReal32: real64 -> real32) =
   (make (real32) {fromRealUnsafe = fromReal32Unsafe,
		   toRealUnsafe = toReal32Unsafe,
		   other = {precision = precision}})
val fReal32: real64 -> real32 = toReal32
val _ = fReal32
val fReal32: IEEEReal.RoundingMode.t -> real32 -> real64 = fromReal32
val _ = fReal32
val zero: real64 = (fromInt32Unsafe 0x0)
val one: real64 = (fromInt32Unsafe 0x1)
val two: real64 = (fromInt32Unsafe 0x2)
val half: real64 = (/ (one, two))
val class: real64 -> IEEEReal.float_class = (mkClass_0 (real64) class)
val rec
   roundReal: real64 * IEEEReal.RoundingMode.t -> real64 = 
      (fn x_1385: real64 * IEEEReal.RoundingMode.t =>
       case x_1385 of
	 ((x: real64, m: IEEEReal.RoundingMode.t)) =>
	 (withRoundingMode_0 (real64) (m,
				       (fn x_1386: unit =>
					case x_1386 of
					  () => (round x)))))
val rec
   strto: string * IEEEReal.RoundingMode.t -> real64 = 
      (fn x_1387: string * IEEEReal.RoundingMode.t =>
       case x_1387 of
	 ((str: string, rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (strto (str, rounding))
	 end)
exception Bad
datatype Real.mode = Fix
		     | Gen
		     | Sci
val one: int32 ref One.t =
   (make_0 (int32 ref) (fn x_1388: unit =>
			case x_1388 of
			  () => (ref[int32] 0x0)))
val rec
   gdtoa: real64 * Real.mode * int32 * IEEEReal.RoundingMode.t -> word64 * int32 = 
      (fn x_1389: real64 * Real.mode * int32 * IEEEReal.RoundingMode.t =>
       case x_1389 of
	 ((x: real64,
	   mode: Real.mode,
	   ndig: int32,
	   rounding_mode: IEEEReal.RoundingMode.t)) =>
	 let val mode: int32 = case mode of Fix => 0x3 | Gen => 0x0 | Sci => 0x2
	     val ndig: int32 = (fromInt ndig)
	     val rounding: int32 =
		case rounding_mode of
		  TO_NEAREST => 0x1
		| TO_NEGINF => 0x3 | TO_POSINF => 0x2 | TO_ZERO => 0x0
	 in
	    (use_0 (word64 * int32, int32 ref) (one,
						(fn x_1390: int32 ref =>
						 case x_1390 of
						   decpt: int32 ref =>
						   ((gdtoa (x,
							    mode,
							    ndig,
							    rounding,
							    decpt)),
						    (toInt (!_1 (int32) decpt))))))
	 end)
val rec
   toDecimal: real64
	      -> {class: IEEEReal.float_class,
		  digits: int32 list,
		  exp: int32,
		  sign: bool} = 
      (fn x_1391: real64 =>
       case x_1391 of
	 (x: real64) =>
	 case (class x) of
	   INF => {class = INF, digits = [], exp = 0x0, sign = (< (x, zero))}
	 | NAN => {class = NAN, digits = [], exp = 0x0, sign = false}
	 | ZERO => {class = ZERO, digits = [], exp = 0x0, sign = (signBit x)}
	 | c: IEEEReal.float_class =>
	   let val (cs: word64, exp: int32) = (gdtoa (x, Gen, 0x0, TO_NEAREST))
	       val rec
		  loop: int32 * int32 list -> int32 list = 
		     (fn x_1392: int32 * int32 list =>
		      case x_1392 of
			((i: int32, ac: int32 list)) =>
			case (< (i, 0x0)) of
			  true => ac
			| false =>
			  (loop ((- (i, 0x1)),
				 (::[int32] ((- ((ord (sub (cs, i))), (ord 0x30))),
					     ac)))))
	       val digits: int32 list = (loop ((- ((length cs), 0x1)), []))
	   in
	      {class = c, digits = digits, exp = exp, sign = (< (x, zero))}
	   end)
val rec
   fix: string * word64 * int32 * int32 -> string = 
      (fn x_1393: string * word64 * int32 * int32 =>
       case x_1393 of
	 ((sign: string, cs: word64, decpt: int32, ndig: int32)) =>
	 let val length: int32 = (length cs)
	 in
	    case (< (decpt, 0x0)) of
	      true =>
	      (concat_2 [sign,
			 "0.",
			 (new ((~ decpt), 0x30)),
			 (toString cs),
			 (new ((+ ((- (ndig, length)), decpt)), 0x30))])
	    | false =>
	      let val whole: string =
		     case (= (int32) (decpt, 0x0)) of
		       true => "0"
		     | false =>
		       (tabulate_4 (decpt,
				    (fn x_1394: int32 =>
				     case x_1394 of
				       i: int32 =>
				       case (< (i, length)) of
					 true => (sub (cs, i)) | false => 0x30)))
	      in
		 case (= (int32) (0x0, ndig)) of
		   true => (concat_2 [sign, whole])
		 | false =>
		   let val frac: string =
			  (tabulate_4 (ndig,
				       (fn x_1395: int32 =>
					case x_1395 of
					  i: int32 =>
					  let val j: int32 = (+ (i, decpt))
					  in
					     case (< (j, length)) of
					       true => (sub (cs, j))
					     | false => 0x30
					  end)))
		   in
		      (concat_2 [sign, whole, ".", frac])
		   end
	      end
	 end)
val rec
   sci: real64 * int32 -> string = 
      (fn x_1396: real64 * int32 =>
       case x_1396 of
	 ((x: real64, ndig: int32)) =>
	 let val sign: string = case (< (x, zero)) of true => "~" | false => ""
	     val (cs: word64, decpt: int32) =
		(gdtoa (x, Sci, (+ (0x1, ndig)), (getRoundingMode ())))
	     val length: int32 = (length cs)
	     val whole: string =
		(tabulate_4 (0x1,
			     (fn x_1398: int32 =>
			      case x_1398 of
				_ => (sub (cs, 0x0)))))
	     val frac: string =
		case (= (int32) (0x0, ndig)) of
		  true => ""
		| false =>
		  (concat_2 [".",
			     (tabulate_4 (ndig,
					  (fn x_1397: int32 =>
					   case x_1397 of
					     i: int32 =>
					     let val j: int32 = (+ (i, 0x1))
					     in
						case (< (j, length)) of
						  true => (sub (cs, j))
						| false => 0x30
					     end)))])
	     val exp: int32 = (- (decpt, 0x1))
	     val exp: string =
		let val (exp: int32, sign: string) =
		       case (< (exp, 0x0)) of
			 true => ((~ exp), "~") | false => (exp, "")
		in
		   (concat_2 [sign, (toString exp)])
		end
	 in
	    (concat_2 [sign, whole, frac, "E", exp])
	 end)
val rec
   gen: real64 * int32 -> string = 
      (fn x_1399: real64 * int32 =>
       case x_1399 of
	 ((x: real64, n: int32)) =>
	 case (class x) of
	   INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	 | NAN => "nan"
	 | _ =>
	   let val (prefix: string, x: real64) =
		  case (< (x, zero)) of
		    true => ("~", (~ x)) | false => ("", x)
	       val ss: char8 Sequence.Slice.t = (full_2 (sci (x, (- (n, 0x1)))))
	       val rec
		  isE: char8 -> bool = 
		     (fn x_1406: char8 =>
		      case x_1406 of
			(c: char8) => (= (char8) (c, 0x45)))
	       val rec
		  isZero: char8 -> bool = 
		     (fn x_1405: char8 =>
		      case x_1405 of
			(c: char8) => (= (char8) (c, 0x30)))
	       val expS: string =
		  (string ((taker_2 (o_1 (char8, bool, bool) (not, isE))) ss))
	       val exp: int32 = (valOf_1 (int32) (fromString expS))
	       val man: string =
		  ((translate_2 (fn x_1404: char8 =>
				 case x_1404 of
				   0x2E => "" | c: char8 => (str c))) (string ((dropr_2 isZero) ((takel_2 (o_1 (char8,
									     bool,
									     bool) (not,
										    isE))) ss))))
	       val manSize: int32 = (size man)
	       val rec
		  zeros: int32 -> string = 
		     (fn x_1402: int32 =>
		      case x_1402 of
			(i: int32) =>
			(tabulate_4 (i,
				     (fn x_1403: int32 =>
				      case x_1403 of
					_ => 0x30))))
	       val rec
		  dotAt: int32 -> string = 
		     (fn x_1401: int32 =>
		      case x_1401 of
			(i: int32) =>
			(concat_2 [(substring (man, 0x0, i)),
				   ".",
				   (extract (man, i, NONE[int32]))]))
	       val rec
		  sci: unit -> string = 
		     (fn x_1400: unit =>
		      case x_1400 of
			(()) =>
			(concat_2 [prefix,
				   case (= (int32) (manSize, 0x1)) of
				     true => man | false => (dotAt 0x1),
				   "E",
				   expS]))
	       val -: int32 * int32 -> int32 = -
	       val +: int32 * int32 -> int32 = +
	       val ~: int32 -> int32 = ~
	       val >=: int32 * int32 -> bool = >=
	   in
	      case (>= (exp,
			case (= (int32) (manSize, 0x1)) of
			  true => 0x3 | false => (+ (manSize, 0x3)))) of
		true => (sci ())
	      | false =>
		case (>= (exp, (- (manSize, 0x1)))) of
		  true =>
		  (concat_2 [prefix, man, (zeros (- (exp, (- (manSize, 0x1)))))])
		| false =>
		  case (>= (exp, 0x0)) of
		    true => (concat_2 [prefix, (dotAt (+ (exp, 0x1)))])
		  | false =>
		    case (>= (exp,
			      case (= (int32) (manSize, 0x1)) of
				true => 0xFFFFFFFE | false => 0xFFFFFFFD)) of
		      true =>
		      (concat_2 [prefix, "0.", (zeros (- ((~ exp), 0x1))), man])
		    | false => (sci ())
	   end)
val rec
   fmt: StringCvt.realfmt -> real64 -> string = 
      (fn x_1407: StringCvt.realfmt =>
       case x_1407 of
	 (spec: StringCvt.realfmt) =>
	 let val doit: real64 -> string =
		case spec of
		  EXACT =>
		  (o_1 (real64,
			string,
			{class: IEEEReal.float_class,
			 digits: int32 list,
			 exp: int32,
			 sign: bool}) (toString, toDecimal))
		| FIX opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1408: real64 =>
		      case x_1408 of
			x: real64 =>
			let val sign: string =
			       case (< (x, zero)) of
				 true => "~" | false => ""
			    val (cs: word64, decpt: int32) =
			       (gdtoa (x, Fix, n, (getRoundingMode ())))
			in
			   (fix (sign, cs, decpt, n))
			end)
		  end
		| GEN opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0xC
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x1)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1409: real64 =>
		      case x_1409 of
			x: real64 => (gen (x, n)))
		  end
		| SCI opt: int32 Primitive.Option.t =>
		  let val n: int32 =
			 case opt of
			   NONE[int32] => 0x6
			 | SOME[int32] n: int32 =>
			   case case safe of
				  true => (< (n, 0x0)) | false => false of
			     true => raise Size | false => n
		  in
		     (fn x_1410: real64 =>
		      case x_1410 of
			x: real64 => (sci (x, n)))
		  end
	 in
	    (fn x_1411: real64 =>
	     case x_1411 of
	       x: real64 =>
	       case (class x) of
		 NAN => "nan"
	       | INF => case (> (x, zero)) of true => "inf" | false => "~inf"
	       | _ => (doit x))
	 end)
val rec 'a
   make: {fromIntUnsafe: 'a -> real64,
	  other: {maxInt': 'a, minInt': 'a, precision': int32},
	  toIntUnsafe: real64 -> 'a}
	 -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
      (fn x_1412: {fromIntUnsafe: 'a -> real64,
		   other: {maxInt': 'a, minInt': 'a, precision': int32},
		   toIntUnsafe: real64 -> 'a} =>
       case x_1412 of
	 ({fromIntUnsafe = fromIntUnsafe: 'a -> real64,
	   toIntUnsafe = toIntUnsafe: real64 -> 'a,
	   other = other: {maxInt': 'a, minInt': 'a, precision': int32}}) =>
	 (fromIntUnsafe,
	  case (< (precision,
		   ((fn x_1422: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1422 of
		       {precision' = #: int32} => #) other))) of
	    true =>
	    let val maxInt': 'a =
		   ((fn x_1415: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1415 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1414: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1414 of
		       {minInt' = #: 'a} => #) other)
		val (maxInt: real64, minInt: real64) =
		   (withRoundingMode_0 (real64 * real64) (TO_ZERO,
							  (fn x_1413: unit =>
							   case x_1413 of
							     () =>
							     ((fromIntUnsafe maxInt'),
							      (fromIntUnsafe minInt')))))
	    in
	       (fn x_1416: IEEEReal.RoundingMode.t =>
		case x_1416 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1417: real64 =>
		   case x_1417 of
		     x: real64 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true => raise Overflow | false => raise Domain))
	    end
	  | false =>
	    let val maxInt': 'a =
		   ((fn x_1419: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1419 of
		       {maxInt' = #: 'a} => #) other)
		val minInt': 'a =
		   ((fn x_1418: {maxInt': 'a, minInt': 'a, precision': int32} =>
		     case x_1418 of
		       {minInt' = #: 'a} => #) other)
		val maxInt: real64 = (fromIntUnsafe maxInt')
		val minInt: real64 = (fromIntUnsafe minInt')
	    in
	       (fn x_1420: IEEEReal.RoundingMode.t =>
		case x_1420 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1421: real64 =>
		   case x_1421 of
		     x: real64 =>
		     case (<= (minInt, x)) of
		       true =>
		       case (<= (x, maxInt)) of
			 true => (toIntUnsafe (roundReal (x, m)))
		       | false =>
			 case (< (x, (+ (maxInt, one)))) of
			   true =>
			   case m of
			     TO_NEGINF => maxInt'
			   | TO_POSINF => raise Overflow
			   | TO_ZERO => maxInt'
			   | TO_NEAREST =>
			     case (>= ((- (x, maxInt)), half)) of
			       true => raise Overflow | false => maxInt'
			 | false => raise Overflow
		     | false =>
		       case (< (x, minInt)) of
			 true =>
			 case (< ((- (minInt, one)), x)) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => minInt'
			   | TO_ZERO => minInt'
			   | TO_NEAREST =>
			     case (< ((- (x, minInt)), (~ half))) of
			       true => raise Overflow | false => minInt'
			 | false => raise Overflow
		       | false => raise Domain))
	    end))
val (fromInt8: int8 -> real64, toInt8: IEEEReal.RoundingMode.t -> real64 -> int8) =
   (make (int8) {fromIntUnsafe = fromInt8Unsafe,
		 toIntUnsafe = toInt8Unsafe,
		 other = {maxInt' = maxInt',
			  minInt' = minInt',
			  precision' = precision'}})
val (fromInt16: int16 -> real64,
     toInt16: IEEEReal.RoundingMode.t -> real64 -> int16) =
   (make (int16) {fromIntUnsafe = fromInt16Unsafe,
		  toIntUnsafe = toInt16Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt32: int32 -> real64,
     toInt32: IEEEReal.RoundingMode.t -> real64 -> int32) =
   (make (int32) {fromIntUnsafe = fromInt32Unsafe,
		  toIntUnsafe = toInt32Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val (fromInt64: int64 -> real64,
     toInt64: IEEEReal.RoundingMode.t -> real64 -> int64) =
   (make (int64) {fromIntUnsafe = fromInt64Unsafe,
		  toIntUnsafe = toInt64Unsafe,
		  other = {maxInt' = maxInt',
			   minInt' = minInt',
			   precision' = precision'}})
val fromIntInf: intInf -> real64 =
   (fn x_1423: intInf =>
    case x_1423 of
      i: intInf =>
      let val str: string =
	     case (< (i, 0)) of
	       true => (^ ("-", (toString (~ i)))) | false => (toString i)
	  val x: real64 = (strto ((nullTerm str), (getRoundingMode ())))
      in
	 x
      end)
val toIntInf: IEEEReal.RoundingMode.t -> real64 -> intInf =
   (fn x_1424: IEEEReal.RoundingMode.t =>
    case x_1424 of
      mode: IEEEReal.RoundingMode.t =>
      (fn x_1425: real64 =>
       case x_1425 of
	 x: real64 =>
	 case (class x) of
	   INF => raise Overflow
	 | NAN => raise Domain
	 | ZERO => 0
	 | _ =>
	   let val x: real64 = (roundReal (x, mode))
	   in
	      case (class x) of
		INF => raise Overflow
	      | _ =>
		(valOf_1 (intInf) (fromString ((fmt (FIX (SOME[int32] 0x0))) x)))
	   end))
val fInt8: int8 -> real64 = fromInt8
val fInt16: int16 -> real64 = fromInt16
val fInt64: int64 -> real64 = fromInt64
val fIntInf: intInf -> real64 = fromIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: int8 -> real64 = fromInt8
val fInt16: int16 -> real64 = fromInt16
val fInt32: int32 -> real64 = fromInt32
val fInt64: int64 -> real64 = fromInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val fInt8: IEEEReal.RoundingMode.t -> real64 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real64 -> int16 = toInt16
val fInt64: IEEEReal.RoundingMode.t -> real64 -> int64 = toInt64
val fIntInf: IEEEReal.RoundingMode.t -> real64 -> intInf = toIntInf
val _ = fInt8
val _ = fInt16
val _ = fInt64
val _ = fIntInf
val fInt8: IEEEReal.RoundingMode.t -> real64 -> int8 = toInt8
val fInt16: IEEEReal.RoundingMode.t -> real64 -> int16 = toInt16
val fInt32: IEEEReal.RoundingMode.t -> real64 -> int32 = toInt32
val fInt64: IEEEReal.RoundingMode.t -> real64 -> int64 = toInt64
val _ = fInt8
val _ = fInt16
val _ = fInt32
val _ = fInt64
val rec 'a
   make: {fromWordUnsafe: 'a -> real64,
	  other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
	  toWordUnsafe: real64 -> 'a}
	 -> ('a -> real64) * (IEEEReal.RoundingMode.t -> real64 -> 'a) = 
      (fn x_1426: {fromWordUnsafe: 'a -> real64,
		   other: {maxWord': 'a, wordSize: int32, zeroWord: 'a},
		   toWordUnsafe: real64 -> 'a} =>
       case x_1426 of
	 ({fromWordUnsafe = fromWordUnsafe: 'a -> real64,
	   toWordUnsafe = toWordUnsafe: real64 -> 'a,
	   other = other: {maxWord': 'a, wordSize: int32, zeroWord: 'a}}) =>
	 (fromWordUnsafe,
	  case (<= (precision,
		    ((fn x_1436: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		      case x_1436 of
			{wordSize = #: int32} => #) other))) of
	    true =>
	    let val maxWord': 'a =
		   ((fn x_1429: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1429 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real64 =
		   (withRoundingMode_0 (real64) (TO_ZERO,
						 (fn x_1428: unit =>
						  case x_1428 of
						    () =>
						    (fromWordUnsafe maxWord'))))
		val zeroWord: 'a =
		   ((fn x_1427: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1427 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1430: IEEEReal.RoundingMode.t =>
		case x_1430 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1431: real64 =>
		   case x_1431 of
		     x: real64 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end
	  | false =>
	    let val maxWord': 'a =
		   ((fn x_1433: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1433 of
		       {maxWord' = #: 'a} => #) other)
		val maxWord: real64 = (fromWordUnsafe maxWord')
		val zeroWord: 'a =
		   ((fn x_1432: {maxWord': 'a, wordSize: int32, zeroWord: 'a} =>
		     case x_1432 of
		       {zeroWord = #: 'a} => #) other)
	    in
	       (fn x_1434: IEEEReal.RoundingMode.t =>
		case x_1434 of
		  m: IEEEReal.RoundingMode.t =>
		  (fn x_1435: real64 =>
		   case x_1435 of
		     x: real64 =>
		     case (class x) of
		       INF => raise Overflow
		     | NAN => raise Domain
		     | _ =>
		       case (<= (zero, x)) of
			 true =>
			 case (<= (x, maxWord)) of
			   true => (toWordUnsafe (roundReal (x, m)))
			 | false =>
			   case (< (x, (+ (maxWord, one)))) of
			     true =>
			     case m of
			       TO_NEGINF => maxWord'
			     | TO_POSINF => raise Overflow
			     | TO_ZERO => maxWord'
			     | TO_NEAREST =>
			       case (>= ((- (x, maxWord)), half)) of
				 true => raise Overflow | false => maxWord'
			   | false => raise Overflow
		       | false =>
			 case (> (x, (~ one))) of
			   true =>
			   case m of
			     TO_NEGINF => raise Overflow
			   | TO_POSINF => zeroWord
			   | TO_ZERO => zeroWord
			   | TO_NEAREST =>
			     case (< (x, (~ half))) of
			       true => raise Overflow | false => zeroWord
			 | false => raise Overflow))
	    end))
val (fromWord8: word8 -> real64,
     toWord8: IEEEReal.RoundingMode.t -> real64 -> word8) =
   (make (word8) {fromWordUnsafe = fromWord8Unsafe,
		  toWordUnsafe = toWord8Unsafe,
		  other = {maxWord' = maxWord',
			   wordSize = wordSize,
			   zeroWord = zero}})
val (fromWord16: word16 -> real64,
     toWord16: IEEEReal.RoundingMode.t -> real64 -> word16) =
   (make (word16) {fromWordUnsafe = fromWord16Unsafe,
		   toWordUnsafe = toWord16Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord32: word32 -> real64,
     toWord32: IEEEReal.RoundingMode.t -> real64 -> word32) =
   (make (word32) {fromWordUnsafe = fromWord32Unsafe,
		   toWordUnsafe = toWord32Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val (fromWord64: word64 -> real64,
     toWord64: IEEEReal.RoundingMode.t -> real64 -> word64) =
   (make (word64) {fromWordUnsafe = fromWord64Unsafe,
		   toWordUnsafe = toWord64Unsafe,
		   other = {maxWord' = maxWord',
			    wordSize = wordSize,
			    zeroWord = zero}})
val fWord8: word8 -> real64 = fromWord8
val fWord16: word16 -> real64 = fromWord16
val fWord64: word64 -> real64 = fromWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: word8 -> real64 = fromWord8
val fWord16: word16 -> real64 = fromWord16
val fWord32: word32 -> real64 = fromWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val fWord8: IEEEReal.RoundingMode.t -> real64 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real64 -> word16 = toWord16
val fWord64: IEEEReal.RoundingMode.t -> real64 -> word64 = toWord64
val _ = fWord8
val _ = fWord16
val _ = fWord64
val fWord8: IEEEReal.RoundingMode.t -> real64 -> word8 = toWord8
val fWord16: IEEEReal.RoundingMode.t -> real64 -> word16 = toWord16
val fWord32: IEEEReal.RoundingMode.t -> real64 -> word32 = toWord32
val _ = fWord8
val _ = fWord16
val _ = fWord32
val bswap: word32 -> word32 = bswap
val subArrRev: word8 array * int64 -> real32 =
   (o_1 (word8 array * int64, real32, word32) ((o_1 (word32, real32, word32) (castFromWord,
									      bswap)),
					       subArr))
val subVecRev: word8 vector * int64 -> real32 =
   (o_1 (word8 vector * int64, real32, word32) ((o_1 (word32, real32, word32) (castFromWord,
									       bswap)),
						subVec))
val rec
   updateRev: word8 array * int64 * real32 -> unit = 
      (fn x_1437: word8 array * int64 * real32 =>
       case x_1437 of
	 ((a: word8 array, i: int64, r: real32)) =>
	 (update (a, i, (bswap (castToWord r)))))
val subArr: word8 array * int64 -> real32 =
   (o_1 (word8 array * int64, real32, word32) (castFromWord, subArr))
val subVec: word8 vector * int64 -> real32 =
   (o_1 (word8 vector * int64, real32, word32) (castFromWord, subVec))
val update: word8 array * int64 * real32 -> unit =
   (fn x_1438: word8 array * int64 * real32 =>
    case x_1438 of
      (a: word8 array, i: int64, r: real32) => (update (a, i, (castToWord r))))
val fReal32: int32 = realSize
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArr
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVec
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = update
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArrRev
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVecRev
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = updateRev
val _ = fReal32
val fReal32: int32 = realSize
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArr
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVec
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = update
val _ = fReal32
val fReal32: word8 array * int64 -> real32 = subArrRev
val _ = fReal32
val fReal32: word8 vector * int64 -> real32 = subVecRev
val _ = fReal32
val fReal32: word8 array * int64 * real32 -> unit = updateRev
val _ = fReal32
datatype Time.time = T of intInf
exception Time
datatype Date.weekday = Mon
			| Tue
			| Wed
			| Thu
			| Fri
			| Sat
			| Sun
datatype Date.month = Jan
		      | Feb
		      | Mar
		      | Apr
		      | May
		      | Jun
		      | Jul
		      | Aug
		      | Sep
		      | Oct
		      | Nov
		      | Dec
datatype Date.t = T of {day: int32,
			hour: int32,
			isDst: bool Primitive.Option.t,
			minute: int32,
			month: Date.month,
			offset: int32 Primitive.Option.t,
			second: int32,
			weekDay: Date.weekday,
			year: int32,
			yearDay: int32}
exception Date
exception BlockingNotSupported
exception ClosedStream
exception Io of {cause: exn, function: string, name: string}
val _ =
   (addExnMessager (fn x_1439: exn =>
		    case x_1439 of
		      e: exn =>
		      case e of
			Io {cause = cause: exn,
			    function = function: string,
			    name = name: string} =>
			(SOME[string] (concat_2 ["Io: ",
						 function,
						 " "",
						 name,
						 "" failed with ",
						 (exnMessage cause)]))
		      | _ => NONE[string]))
exception NonblockingNotSupported
exception RandomAccessNotSupported
datatype IO.buffer_mode = NO_BUF
			  | LINE_BUF
			  | BLOCK_BUF
datatype PrimIO.reader = RD of {avail: unit -> int32 Primitive.Option.t,
				block: (unit -> unit) Primitive.Option.t,
				canInput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				readArr: (word8 Sequence.Slice.t -> int32) Primitive.Option.t,
				readArrNB: (word8 Sequence.Slice.t
					    -> int32 Primitive.Option.t) Primitive.Option.t,
				readVec: (int32 -> word8 vector) Primitive.Option.t,
				readVecNB: (int32
					    -> word8 vector Primitive.Option.t) Primitive.Option.t,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t}
datatype PrimIO.writer = WR of {block: (unit -> unit) Primitive.Option.t,
				canOutput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t,
				writeArr: (word8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeArrNB: (word8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t,
				writeVec: (word8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeVecNB: (word8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t}
datatype PrimIO.reader = RD of {avail: unit -> int32 Primitive.Option.t,
				block: (unit -> unit) Primitive.Option.t,
				canInput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				readArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
				readArrNB: (char8 Sequence.Slice.t
					    -> int32 Primitive.Option.t) Primitive.Option.t,
				readVec: (int32 -> string) Primitive.Option.t,
				readVecNB: (int32 -> string Primitive.Option.t) Primitive.Option.t,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t}
datatype PrimIO.writer = WR of {block: (unit -> unit) Primitive.Option.t,
				canOutput: (unit -> bool) Primitive.Option.t,
				chunkSize: int32,
				close: unit -> unit,
				endPos: (unit -> int64) Primitive.Option.t,
				getPos: (unit -> int64) Primitive.Option.t,
				ioDesc: int32 Primitive.Option.t,
				name: string,
				setPos: (int64 -> unit) Primitive.Option.t,
				verifyPos: (unit -> int64) Primitive.Option.t,
				writeArr: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeArrNB: (char8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t,
				writeVec: (char8 Sequence.Slice.t -> int32) Primitive.Option.t,
				writeVecNB: (char8 Sequence.Slice.t
					     -> int32 Primitive.Option.t) Primitive.Option.t}
datatype PosixFileSys.dirstream = DS of word64 Primitive.Option.t ref
datatype PosixFileSys.open_mode = O_RDONLY
				  | O_WRONLY
				  | O_RDWR
datatype PosixFileSys.ST.stat = T of {atime: Time.time,
				      ctime: Time.time,
				      dev: int32,
				      gid: word32,
				      ino: word64,
				      mode: word16,
				      mtime: Time.time,
				      nlink: int32,
				      size: int64,
				      uid: word32}
datatype PosixFileSys.access_mode = A_READ
				    | A_WRITE
				    | A_EXEC
datatype PosixIO.whence = SEEK_SET
			  | SEEK_CUR
			  | SEEK_END
datatype PosixIO.lock_type = F_RDLCK
			     | F_WRLCK
			     | F_UNLCK
datatype PosixProcess.waitpid_arg = W_ANY_CHILD
				    | W_CHILD of int32
				    | W_SAME_GROUP
				    | W_GROUP of int32
datatype PosixProcess.exit_status = W_EXITED
				    | W_EXITSTATUS of word8
				    | W_SIGNALED of int32
				    | W_STOPPED of int32
datatype PosixProcess.killpid_arg = K_PROC of int32
				    | K_SAME_GROUP
				    | K_GROUP of int32
datatype StreamIOExtra.buf = Buf of {array: word8 array, size: int32 ref}
datatype StreamIOExtra.bufferMode = NO_BUF
				    | LINE_BUF of StreamIOExtra.buf
				    | BLOCK_BUF of StreamIOExtra.buf
datatype StreamIOExtra.state = Active
			       | Terminated
			       | Closed
datatype StreamIOExtra.outstream = Out of {augmented_writer: PrimIO.writer,
					   bufferMode: StreamIOExtra.bufferMode ref,
					   state: StreamIOExtra.state ref,
					   writer: PrimIO.writer}
datatype StreamIOExtra.out_pos = OutPos of {outstream: StreamIOExtra.outstream,
					    pos: int64}
datatype StreamIOExtra.state = Link of {buf: StreamIOExtra.buf}
			       | Eos of {buf: StreamIOExtra.buf}
			       | End
			       | Truncated
			       | Closed
	 StreamIOExtra.buf = Buf of {base: int64 Primitive.Option.t,
				     inp: word8 vector,
				     next: StreamIOExtra.state ref}
datatype StreamIOExtra.instream = In of {buf: StreamIOExtra.buf,
					 common: {augmented_reader: PrimIO.reader,
						  reader: PrimIO.reader,
						  tail: StreamIOExtra.state ref ref},
					 pos: int32}
datatype StreamIOExtra.Close.t = T of {close: unit -> unit,
				       name: string,
				       tail: StreamIOExtra.state ref ref}
datatype ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
datatype ImperativeIOExtra.state = Closed
				   | Open of {eos: bool}
				   | Stream of StreamIOExtra.instream
datatype ImperativeIOExtra.instream = In of {augmentedReader: PrimIO.reader,
					     buf: word8 array,
					     first: int32 ref,
					     last: int32 ref,
					     reader: PrimIO.reader,
					     state: ImperativeIOExtra.state ref}
datatype StreamIOExtra.buf = Buf of {array: char8 array, size: int32 ref}
datatype StreamIOExtra.bufferMode = NO_BUF
				    | LINE_BUF of StreamIOExtra.buf
				    | BLOCK_BUF of StreamIOExtra.buf
datatype StreamIOExtra.state = Active
			       | Terminated
			       | Closed
datatype StreamIOExtra.outstream = Out of {augmented_writer: PrimIO.writer,
					   bufferMode: StreamIOExtra.bufferMode ref,
					   state: StreamIOExtra.state ref,
					   writer: PrimIO.writer}
datatype StreamIOExtra.out_pos = OutPos of {outstream: StreamIOExtra.outstream,
					    pos: int64}
datatype StreamIOExtra.state = Link of {buf: StreamIOExtra.buf}
			       | Eos of {buf: StreamIOExtra.buf}
			       | End
			       | Truncated
			       | Closed
	 StreamIOExtra.buf = Buf of {base: int64 Primitive.Option.t,
				     inp: string,
				     next: StreamIOExtra.state ref}
datatype StreamIOExtra.instream = In of {buf: StreamIOExtra.buf,
					 common: {augmented_reader: PrimIO.reader,
						  reader: PrimIO.reader,
						  tail: StreamIOExtra.state ref ref},
					 pos: int32}
datatype StreamIOExtra.Close.t = T of {close: unit -> unit,
				       name: string,
				       tail: StreamIOExtra.state ref ref}
datatype ImperativeIOExtra.Outstream.t = T of StreamIOExtra.outstream ref
datatype ImperativeIOExtra.state = Closed
				   | Open of {eos: bool}
				   | Stream of StreamIOExtra.instream
datatype ImperativeIOExtra.instream = In of {augmentedReader: PrimIO.reader,
					     buf: char8 array,
					     first: int32 ref,
					     last: int32 ref,
					     reader: PrimIO.reader,
					     state: ImperativeIOExtra.state ref}
exception Path
exception InvalidArc
datatype OS_FileSys.file_id = FID of {dev: word64, ino: word64}
exception Sqrt
exception Ln
exception Ord
exception Io of string
exception Interrupt
val rec ('a_3801, 'a_3800)
   wrap: ('a_3801 * int64 -> 'a_3800) -> 'a_3801 * int32 -> 'a_3800 = 
      (fn x_1440: 'a_3801 * int64 -> 'a_3800 =>
       (fn x_1441: 'a_3801 * int32 =>
	case (x_1440, x_1441) of
	  (f: 'a_3801 * int64 -> 'a_3800, (p: 'a_3801, i: int32)) =>
	  (f (p, (fromInt i)))))
val getInt32: cpointer * int32 -> int32 = (wrap (cpointer, int32) getInt32)
val getWord32: cpointer * int32 -> word32 = (wrap (cpointer, word32) getWord32)
val gcState: cpointer = gcState
val current: unit -> Primitive.MLton.CallStack.t =
   (fn x_1442: unit =>
    case x_1442 of
      () =>
      case (not keep) of
	true => (T (array_0 (word32) (0x0, 0x0)))
      | false =>
	let val a: word32 array =
	       (arrayUninit_0 (word32) (toInt (numStackFrames gcState)))
	    val () = (callStack (gcState, a))
	in
	   (T a)
	end)
val toStrings: Primitive.MLton.CallStack.t -> string list =
   (fn x_1443: Primitive.MLton.CallStack.t =>
    case x_1443 of
      T a: word32 array =>
      case (not keep) of
	true => []
      | false =>
	let val skip: int32 = (- ((length_6 (word32) a), 0x1))
	in
	   (((foldri_1 (string list, word32) (fn x_1444: int32
							 * word32
							 * string list =>
					      case x_1444 of
						(i: int32,
						 frameIndex: word32,
						 ac: string list) =>
						case (>= (i, skip)) of
						  true => ac
						| false =>
						  let val p: cpointer =
							 (frameIndexSourceSeq (gcState,
									       frameIndex))
						      val max: int32 =
							 (toInt (getInt32 (p,
									   0x0)))
						      val rec
							 loop: int32
							       * string list
							       -> string list = 
							    (fn x_1445: int32
									* string list =>
							     case x_1445 of
							       ((j: int32,
								 ac: string list)) =>
							       case (> (j, max)) of
								 true => ac
							       | false =>
								 (loop ((+ (j,
									    0x1)),
									(::[string] ((toString (sourceName (gcState,
													    (getWord32 (p,
															j))))),
										     ac)))))
						  in
						     (loop (0x1, ac))
						  end)) []) a)
	end)
val fromInt: int32 -> int32 = (o_1 (int32, int32, int32) (fromRep, fromInt))
val toInt: int32 -> int32 = (o_1 (int32, int32, int32) (toInt, toRep))
val failure: int32 = (fromInt 0x1)
val success: int32 = (fromInt 0x0)
val exiting: bool ref = (ref[bool] false)
val rec
   halt: int32 -> unit = 
      (fn x_1446: int32 =>
       case x_1446 of
	 (status: int32) => (halt (toRep status)))
val rec 'a
   exit: int32 -> 'a = 
      (fn x_1447: int32 =>
       case x_1447 of
	 (status: int32) =>
	 case (!_1 (bool) exiting) of
	   true => raise (Fail "MLton.Exit.exit")
	 | false =>
	   let val _ = (:=_1 (bool) (exiting, true))
	       val i: int32 = (toInt status)
	   in
	      case case (<= (0x0, i)) of
		     true => (< (i, 0x100)) | false => false of
		true =>
		let 
		in
		   (clean atExit)
		end
		;(halt status)
		;raise (Fail "MLton.Exit.exit")
	      | false =>
		raise (Fail (concat_2 ["MLton.Exit.exit(",
				       (toString i),
				       "): ",
				       "exit must have 0 <= status < 256"]))
	   end)
val message: string -> unit = print
val rec 'a
   wrapSuffix: (unit -> unit) -> unit -> 'a = 
      (fn x_1448: unit -> unit =>
       (fn x_1449: unit =>
	case (x_1448, x_1449) of
	  (suffix: unit -> unit, ()) =>
	  (suffix ())
	  ;(message "Top-level suffix returned.
")
	  ;(exit ('a) failure)
	  handle x_1450 => case x_1450 of
			     _ =>
			     (message "Top-level suffix raised exception.
")
			     ;(halt failure)
			     ;raise (Fail "MLton.Exit.wrapSuffix")))
val rec
   suffixArchiveOrLibrary: unit -> unit = 
      (fn x_1451: unit =>
       case x_1451 of
	 (()) =>
	 let val () = (returnToC ())
	     val _ = (:=_1 (bool) (exiting, true))
	     val () = let  in (clean atExit) end
	     val () = (returnToC ())
	 in
	    ()
	 end)
val rec 'a_3807
   suffixExecutable: unit -> 'a_3807 = 
      (fn x_1452: unit =>
       case x_1452 of
	 (()) => (exit ('a_3807) success))
val defaultSuffix: unit -> unit =
   let 
   in
      case host of
	Archive => suffixArchiveOrLibrary
      | Executable => suffixExecutable (unit)
      | LibArchive => suffixArchiveOrLibrary
      | Library => suffixArchiveOrLibrary
   end
val rec 'a
   defaultTopLevelSuffix: unit -> 'a = 
      (fn x_1453: unit =>
       case x_1453 of
	 (()) => ((wrapSuffix ('a) defaultSuffix) ()))
val history: exn -> string list =
   case keepHistory of
     true =>
     (setExtendExtra (fn x_1454: Primitive.MLton.CallStack.t Primitive.Option.t =>
		      case x_1454 of
			e: Primitive.MLton.CallStack.t Primitive.Option.t =>
			case e of
			  NONE[Primitive.MLton.CallStack.t] =>
			  (SOME[Primitive.MLton.CallStack.t] (current ()))
			| SOME[Primitive.MLton.CallStack.t] _ => e))
     ;(fn x_1455: exn =>
       case x_1455 of
	 e: exn =>
	 case (extra e) of
	   NONE[Primitive.MLton.CallStack.t] => []
	 | SOME[Primitive.MLton.CallStack.t] cs: Primitive.MLton.CallStack.t =>
	   let val rec
		  loop: string list -> string list = 
		     (fn x_1456: string list =>
		      case x_1456 of
			(xs: string list) =>
			case xs of
			  [] => []
			| ::[string] (x: string, xs: string list) =>
			  case ((isPrefix "MLtonExn.fn ") x) of
			    true => xs | false => (loop xs))
	   in
	      (loop (toStrings cs))
	   end)
   | false => (fn x_1457: exn => case x_1457 of _ => [])
val message: string -> unit = print
val rec 'a
   wrapHandler: (exn -> unit) -> exn -> 'a = 
      (fn x_1458: exn -> unit =>
       (fn x_1459: exn =>
	case (x_1458, x_1459) of
	  (handler: exn -> unit, exn: exn) =>
	  (handler exn)
	  ;(message "Top-level handler returned.
")
	  ;(exit ('a) failure)
	  handle x_1460 => case x_1460 of
			     _ =>
			     (message "Top-level handler raised exception.
")
			     ;(halt failure)
			     ;raise (Fail "MLton.Exn.wrapHandler")))
val 'a_3808 defaultHandler: exn -> 'a_3808 =
   (fn x_1461: exn =>
    case x_1461 of
      exn: exn =>
      (message (concat_2 ["unhandled exception: ", (exnMessage exn), "
"]))
      ;case (history exn) of
	 [] => ()
       | l: string list =>
	 (message "with history:
")
	 ;((app_0 (string) (fn x_1462: string =>
			    case x_1462 of
			      s: string => (message (concat_2 ["	", s, "
"])))) l)
      ;(exit ('a_3808) failure))
val rec 'a
   defaultTopLevelHandler: exn -> 'a = 
      (fn x_1463: exn =>
       case x_1463 of
	 (exn: exn) => ((wrapHandler ('a) defaultHandler (unit)) exn))
datatype MLtonThread.AtomicState.t = NonAtomic
				     | Atomic of int32
datatype 'a MLtonThread.thread = Dead
				 | Interrupted of thread
				 | New of 'a -> unit
				 | Paused of ((unit -> 'a) -> unit) * thread
datatype 'a MLtonThread.t = T of 'a MLtonThread.thread ref
datatype MLtonThread.state = Normal
			     | InHandler
datatype MLtonSignal.Mask.t = AllBut of int32 list
			      | Some of int32 list
datatype MLtonSignal.Handler.t = Default
				 | Handler of unit MLtonThread.t
					      -> unit MLtonThread.t
				 | Ignore
				 | InvalidSignal
exception MisuseOfForget
exception DoublyRedirected
datatype 'use MLtonProcess.Child.childt = FileDesc of int32
					  | Stream of 'use * ('use -> unit)
					  | Term
datatype ('use, 'dir) MLtonProcess.Param.t = File of string
					     | FileDesc of int32
					     | Pipe
					     | Self
datatype ('stdin, 'stdout, 'stderr) MLtonProcess.t = T of {pid: int32,
							   status: PosixProcess.exit_status Primitive.Option.t ref,
							   stderr: 'stderr MLtonProcess.Child.childt ref,
							   stdin: 'stdin MLtonProcess.Child.childt ref,
							   stdout: 'stdout MLtonProcess.Child.childt ref}
datatype OS_IO.iodesc_kind = K of string
datatype OS_IO.poll_desc = PollDesc of int32 * {pri: bool, rd: bool, wr: bool}
datatype OS_IO.poll_info = PollInfo of int32 * {pri: bool, rd: bool, wr: bool}
exception Poll
datatype Timer.SysUsr.t = T of {sys: Time.time, usr: Time.time}
val hton: word16 -> word16 = htons
val ntoh: word16 -> word16 = ntohs
val hton: int16 -> int16 =
   (o_1 (int16, int16, word16) ((o_1 (word16, int16, word16) (idFromWord16ToInt16,
							      hton)),
				idFromInt16ToWord16))
val ntoh: int16 -> int16 =
   (o_1 (int16, int16, word16) ((o_1 (word16, int16, word16) (idFromWord16ToInt16,
							      ntoh)),
				idFromInt16ToWord16))
val ('a_3954, 'a_3953) fInt8: 'a_3954 -> 'a_3953 =
   (fn x_1464: 'a_3954 =>
    case x_1464 of
      _ => raise (Fail "Net.C_Int.hton: fInt8"))
val fInt16: int16 -> int16 = hton
val ('a_3956, 'a_3955) fInt64: 'a_3956 -> 'a_3955 =
   (fn x_1465: 'a_3956 =>
    case x_1465 of
      _ => raise (Fail "Net.C_Int.hton: fInt64"))
val fInt8_0: int8 -> int8 = fInt8 (int8, int8)
val fInt64_0: int64 -> int64 = fInt64 (int64, int64)
val _ = fInt8_0
val _ = fInt16
val _ = fInt64_0
val ('a_3960, 'a_3959) fInt8: 'a_3960 -> 'a_3959 =
   (fn x_1466: 'a_3960 =>
    case x_1466 of
      _ => raise (Fail "Net.C_Int.ntoh: fInt8"))
val fInt16: int16 -> int16 = ntoh
val ('a_3962, 'a_3961) fInt64: 'a_3962 -> 'a_3961 =
   (fn x_1467: 'a_3962 =>
    case x_1467 of
      _ => raise (Fail "Net.C_Int.ntoh: fInt64"))
val fInt8_1: int8 -> int8 = fInt8 (int8, int8)
val fInt64_1: int64 -> int64 = fInt64 (int64, int64)
val _ = fInt8_1
val _ = fInt16
val _ = fInt64_1
datatype NetHostDB.entry = T of {addrType: int32,
				 addrs: word8 vector list,
				 aliases: string list,
				 name: string}
datatype NetProtDB.entry = T of {aliases: string list,
				 name: string,
				 protocol: int32}
datatype NetServDB.entry = T of {aliases: string list,
				 name: string,
				 port: int32,
				 protocol: string}
datatype Socket.sock_addr = SA of word8 vector
datatype Socket.dgram = DGRAM
datatype Socket.stream = MODE
datatype Socket.passive = PASSIVE
datatype Socket.active = ACTIVE
datatype Socket.shutdown_mode = NO_RECVS
				| NO_SENDS
				| NO_RECVS_OR_SENDS
datatype INetSock.inet = INET
datatype UnixSock.unix = UNIX
datatype MLtonItimer.t = Prof
			 | Real
			 | Virtual
val gcState: cpointer = gcState
val isOn: bool = isOn
datatype MLtonProfile.Data.t = T of {isCurrent: bool ref,
				     isFreed: bool ref,
				     raw: cpointer}
val all: MLtonProfile.Data.t list ref = (ref[MLtonProfile.Data.t list] [])
val rec 'a_4043
   make: ({isCurrent: bool ref, isFreed: bool ref, raw: cpointer} -> 'a_4043)
	 -> MLtonProfile.Data.t -> 'a_4043 = 
      (fn x_1468: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer}
		  -> 'a_4043 =>
       (fn x_1469: MLtonProfile.Data.t =>
	case (x_1468, x_1469) of
	  (f: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer} -> 'a_4043,
	   T r: {isCurrent: bool ref, isFreed: bool ref, raw: cpointer}) =>
	  (f r)))
val raw: MLtonProfile.Data.t -> cpointer =
   (make (cpointer) (fn x_1470: {isCurrent: bool ref,
				 isFreed: bool ref,
				 raw: cpointer} =>
		     case x_1470 of
		       {raw = #: cpointer} => #))
val rec
   make: cpointer -> MLtonProfile.Data.t = 
      (fn x_1471: cpointer =>
       case x_1471 of
	 (raw: cpointer) =>
	 (T {isCurrent = (ref[bool] false),
	     isFreed = (ref[bool] false),
	     raw = raw}))
val rec
   write: MLtonProfile.Data.t * string -> unit = 
      (fn x_1472: MLtonProfile.Data.t * string =>
       case x_1472 of
	 ((T {isFreed = isFreed: bool ref, raw = raw: cpointer}, file: string)) =>
	 case (not isOn) of
	   true => ()
	 | false =>
	   case (!_1 (bool) isFreed) of
	     true => raise (Fail "write of freed profile data")
	   | false => (write (gcState, raw, (fromString (nullTerm file)))))
val r: MLtonProfile.Data.t ref = (ref[MLtonProfile.Data.t] (make dummy))
val rec
   current: unit -> MLtonProfile.Data.t = 
      (fn x_1473: unit =>
       case x_1473 of
	 (()) => (!_1 (MLtonProfile.Data.t) r))
val rec
   setCurrent: MLtonProfile.Data.t -> unit = 
      (fn x_1474: MLtonProfile.Data.t =>
       case x_1474 of
	 (d: MLtonProfile.Data.t as T {isCurrent = isCurrent: bool ref,
				       isFreed = isFreed: bool ref,
				       raw = raw: cpointer}) =>
	 case (not isOn) of
	   true => ()
	 | false =>
	   case (!_1 (bool) isFreed) of
	     true => raise (Fail "setCurrent of freed profile data")
	   | false =>
	     let val T {isCurrent = ic: bool ref} = (current ())
		 val _ = (:=_1 (bool) (ic, false))
		 val _ = (:=_1 (bool) (isCurrent, true))
		 val _ = (:=_1 (MLtonProfile.Data.t) (r, d))
		 val _ = (setCurrent (gcState, raw))
	     in
		()
	     end)
val rec
   init: unit -> unit = 
      (fn x_1475: unit =>
       case x_1475 of
	 (()) => (setCurrent (make (getCurrent gcState))))
val _ =
   case (not isOn) of
     true => ()
   | false =>
     let val _ =
	    (addNew_0 (atExit,
		       (fn x_1477: unit =>
			case x_1477 of
			  () =>
			  (done gcState)
			  ;(write ((current ()), "mlmon.out"))
			  ;((app_0 (MLtonProfile.Data.t) (fn x_1478: MLtonProfile.Data.t =>
							  case x_1478 of
							    d: MLtonProfile.Data.t =>
							    (free (gcState,
								   (raw d))))) (!_1 (MLtonProfile.Data.t list) all)))))
	 val _ =
	    (addNew_0 (atLoadWorld,
		       (fn x_1476: unit =>
			case x_1476 of
			  () =>
			  (:=_1 (MLtonProfile.Data.t list) (all, [])) ;(init ()))))
     in
	(init ())
     end
datatype 'a MLtonFinalizable.t = T of {afters: (unit -> unit) list ref,
				       finalizers: ('a -> unit) list ref,
				       value: 'a ref}
datatype MLtonWorld.status = Clone
			     | Original
val _ =
   (setHandler defaultTopLevelHandler (unit))
   ;(setSuffix defaultTopLevelSuffix (unit))
exception UNKNOWN
datatype SMLofNJ.SysInfo.os_kind = BEOS
				   | MACOS
				   | OS2
				   | UNIX
				   | WIN32
exception Catalyst
